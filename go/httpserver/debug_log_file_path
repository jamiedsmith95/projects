󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3: 
󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: p
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: p |3: p |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pa
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: pa |3: pa |4: p |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pac
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: ac |3: pac |4: pa |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pack
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ck |3: pack |4: pac |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: packa
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: ka |3: packa |4: pack |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: packag
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ag |3: packag |4: packa |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ge |3: package |4: packag |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package main
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: e main |3: package main |4: package |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2: package main |3:  |4: package main |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: i |3: i |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: im
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: im |3: im |4: i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: imp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: mp |3: imp |4: im |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: impo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: po |3: impo |4: imp |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: impor
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: or |3: impor |4: impo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: rt |3: import |4: impor |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: t  |3: import  |4: import |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import (
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2:  ( |3: import ( |4: import  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2: (" |3: import (" |4: import ( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("e
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2: "e |3: import ("e |4: import (" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2: er |3: import ("er |4: import ("e |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2: rr |3: import ("err |4: import ("er |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("erro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2: ro |3: import ("erro |4: import ("err |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errof
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2: of |3: import ("errof |4: import ("erro |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("erro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2: of |3: import ("erro |4: import ("errof |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("error
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2: or |3: import ("error |4: import ("erro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2: rs |3: import ("errors |4: import ("error |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: s", |3: import ("errors", |4: import ("errors |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: ,  |3: import ("errors",  |4: import ("errors", |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  R |3: import ("errors", R |4: import ("errors",  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  R |3: import ("errors",  |4: import ("errors", R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  " |3: import ("errors", " |4: import ("errors",  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: "f |3: import ("errors", "f |4: import ("errors", " |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: fm |3: import ("errors", "fm |4: import ("errors", "f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: mt |3: import ("errors", "fmt |4: import ("errors", "fm |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 24
󰘫  |1: delta |2: t", |3: import ("errors", "fmt", |4: import ("errors", "fmt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 24
󰘫  |1: delta |2: ,  |3: import ("errors", "fmt",  |4: import ("errors", "fmt", |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 24
󰘫  |1: delta |2:  " |3: import ("errors", "fmt", " |4: import ("errors", "fmt",  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 24
󰘫  |1: delta |2: "i |3: import ("errors", "fmt", "i |4: import ("errors", "fmt", " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 24
󰘫  |1: delta |2: io |3: import ("errors", "fmt", "io |4: import ("errors", "fmt", "i |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 24
󰘫  |1: delta |2: o  |3: import ("errors", "fmt", "io  |4: import ("errors", "fmt", "io |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io o
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 24
󰘫  |1: delta |2:  o |3: import ("errors", "fmt", "io o |4: import ("errors", "fmt", "io  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 24
󰘫  |1: delta |2:  o |3: import ("errors", "fmt", "io  |4: import ("errors", "fmt", "io o |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 24
󰘫  |1: delta |2: o  |3: import ("errors", "fmt", "io |4: import ("errors", "fmt", "io  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: o", |3: import ("errors", "fmt", "io", |4: import ("errors", "fmt", "io |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: ,  |3: import ("errors", "fmt", "io",  |4: import ("errors", "fmt", "io", |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2:  " |3: import ("errors", "fmt", "io", " |4: import ("errors", "fmt", "io",  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: "n |3: import ("errors", "fmt", "io", "n |4: import ("errors", "fmt", "io", " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "ne
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: ne |3: import ("errors", "fmt", "io", "ne |4: import ("errors", "fmt", "io", "n |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "net
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: et |3: import ("errors", "fmt", "io", "net |4: import ("errors", "fmt", "io", "ne |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "net/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: t/ |3: import ("errors", "fmt", "io", "net/ |4: import ("errors", "fmt", "io", "net |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "net/h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: /h |3: import ("errors", "fmt", "io", "net/h |4: import ("errors", "fmt", "io", "net/ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "net/ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: ht |3: import ("errors", "fmt", "io", "net/ht |4: import ("errors", "fmt", "io", "net/h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "net/htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: tt |3: import ("errors", "fmt", "io", "net/htt |4: import ("errors", "fmt", "io", "net/ht |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "net/http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: tp |3: import ("errors", "fmt", "io", "net/http |4: import ("errors", "fmt", "io", "net/htt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "net/http",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 42
󰘫  |1: delta |2: p", |3: import ("errors", "fmt", "io", "net/http", |4: import ("errors", "fmt", "io", "net/http |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "net/http", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 42
󰘫  |1: delta |2: ,  |3: import ("errors", "fmt", "io", "net/http",  |4: import ("errors", "fmt", "io", "net/http", |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "net/http", "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 42
󰘫  |1: delta |2:  " |3: import ("errors", "fmt", "io", "net/http", " |4: import ("errors", "fmt", "io", "net/http",  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "net/http", "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 42
󰘫  |1: delta |2: import ("errors", "fmt", "io", "net/http", " |3: import ("errors", "fmt", "io", "net/http", " |4: import ("errors", "fmt", "io", "net/http", " |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "net/http", "o
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 42
󰘫  |1: delta |2: "o |3: import ("errors", "fmt", "io", "net/http", "o |4: import ("errors", "fmt", "io", "net/http", " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "net/http", "os
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 42
󰘫  |1: delta |2: os |3: import ("errors", "fmt", "io", "net/http", "os |4: import ("errors", "fmt", "io", "net/http", "o |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "net/http", "os
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 42
󰘫  |1: delta |2: import ("errors", "fmt", "io", "net/http", "os |3: import ("errors", "fmt", "io", "net/http", "os |4: import ("errors", "fmt", "io", "net/http", "os |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors", "fmt", "io", "net/http", "os
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 42
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: f |3: f |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: fu |3: fu |4: f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: un |3: fun |4: fu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: nc |3: func |4: fun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: c  |3: func  |4: func |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  g |3: func g |4: func  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func ge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ge |3: func ge |4: func g |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func get
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: et |3: func get |4: func ge |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getR
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: tR |3: func getR |4: func get |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: Ro |3: func getRo |4: func getR |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: oo |3: func getRoo |4: func getRo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ot |3: func getRoot |4: func getRoo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: t( |3: func getRoot( |4: func getRoot |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: (w |3: func getRoot(w |4: func getRoot( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: w  |3: func getRoot(w  |4: func getRoot(w |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:  h |3: func getRoot(w h |4: func getRoot(w  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ht |3: func getRoot(w ht |4: func getRoot(w h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: tt |3: func getRoot(w htt |4: func getRoot(w ht |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: tp |3: func getRoot(w http |4: func getRoot(w htt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: p. |3: func getRoot(w http. |4: func getRoot(w http |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: .R |3: func getRoot(w http.R |4: func getRoot(w http. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: Re |3: func getRoot(w http.Re |4: func getRoot(w http.R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.Res
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: es |3: func getRoot(w http.Res |4: func getRoot(w http.Re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.Resp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: sp |3: func getRoot(w http.Resp |4: func getRoot(w http.Res |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.Respo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: po |3: func getRoot(w http.Respo |4: func getRoot(w http.Resp |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.Respon
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: on |3: func getRoot(w http.Respon |4: func getRoot(w http.Respo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.Respons
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ns |3: func getRoot(w http.Respons |4: func getRoot(w http.Respon |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.Response
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: se |3: func getRoot(w http.Response |4: func getRoot(w http.Respons |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.Responsew
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ew |3: func getRoot(w http.Responsew |4: func getRoot(w http.Response |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.Response
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ew |3: func getRoot(w http.Response |4: func getRoot(w http.Responsew |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseW
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: eW |3: func getRoot(w http.ResponseW |4: func getRoot(w http.Response |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: Wr |3: func getRoot(w http.ResponseWr |4: func getRoot(w http.ResponseW |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ri |3: func getRoot(w http.ResponseWri |4: func getRoot(w http.ResponseWr |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWrit
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: it |3: func getRoot(w http.ResponseWrit |4: func getRoot(w http.ResponseWri |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWrite
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: te |3: func getRoot(w http.ResponseWrite |4: func getRoot(w http.ResponseWrit |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: er |3: func getRoot(w http.ResponseWriter |4: func getRoot(w http.ResponseWrite |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: r, |3: func getRoot(w http.ResponseWriter, |4: func getRoot(w http.ResponseWriter |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: ,  |3: func getRoot(w http.ResponseWriter,  |4: func getRoot(w http.ResponseWriter, |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2:  r |3: func getRoot(w http.ResponseWriter, r |4: func getRoot(w http.ResponseWriter,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: r  |3: func getRoot(w http.ResponseWriter, r  |4: func getRoot(w http.ResponseWriter, r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r 8
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2:  8 |3: func getRoot(w http.ResponseWriter, r 8 |4: func getRoot(w http.ResponseWriter, r  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2:  8 |3: func getRoot(w http.ResponseWriter, r  |4: func getRoot(w http.ResponseWriter, r 8 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2:  * |3: func getRoot(w http.ResponseWriter, r * |4: func getRoot(w http.ResponseWriter, r  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r * 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: *  |3: func getRoot(w http.ResponseWriter, r *  |4: func getRoot(w http.ResponseWriter, r * |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: *  |3: func getRoot(w http.ResponseWriter, r * |4: func getRoot(w http.ResponseWriter, r *  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r * 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: *  |3: func getRoot(w http.ResponseWriter, r *  |4: func getRoot(w http.ResponseWriter, r * |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: *  |3: func getRoot(w http.ResponseWriter, r * |4: func getRoot(w http.ResponseWriter, r *  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: *h |3: func getRoot(w http.ResponseWriter, r *h |4: func getRoot(w http.ResponseWriter, r * |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: ht |3: func getRoot(w http.ResponseWriter, r *ht |4: func getRoot(w http.ResponseWriter, r *h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: tt |3: func getRoot(w http.ResponseWriter, r *htt |4: func getRoot(w http.ResponseWriter, r *ht |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: tp |3: func getRoot(w http.ResponseWriter, r *http |4: func getRoot(w http.ResponseWriter, r *htt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: p. |3: func getRoot(w http.ResponseWriter, r *http. |4: func getRoot(w http.ResponseWriter, r *http |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *http.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: .R |3: func getRoot(w http.ResponseWriter, r *http.R |4: func getRoot(w http.ResponseWriter, r *http. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *http.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: Re |3: func getRoot(w http.ResponseWriter, r *http.Re |4: func getRoot(w http.ResponseWriter, r *http.R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *http.Requ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: equ |3: func getRoot(w http.ResponseWriter, r *http.Requ |4: func getRoot(w http.ResponseWriter, r *http.Re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *http.Reque
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: ue |3: func getRoot(w http.ResponseWriter, r *http.Reque |4: func getRoot(w http.ResponseWriter, r *http.Requ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *http.Reques
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: es |3: func getRoot(w http.ResponseWriter, r *http.Reques |4: func getRoot(w http.ResponseWriter, r *http.Reque |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *http.Request
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: st |3: func getRoot(w http.ResponseWriter, r *http.Request |4: func getRoot(w http.ResponseWriter, r *http.Reques |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *http.Request) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 53
󰘫  |1: delta |2: t)  |3: func getRoot(w http.ResponseWriter, r *http.Request)  |4: func getRoot(w http.ResponseWriter, r *http.Request |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getRoot(w http.ResponseWriter, r *http.Request) {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 54
󰘫  |1: delta |2:  { |3: func getRoot(w http.ResponseWriter, r *http.Request) { |4: func getRoot(w http.ResponseWriter, r *http.Request)  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: unc getRoot(w http.ResponseWriter, r *http.Request) { |3:    |4: func getRoot(w http.ResponseWriter, r *http.Request) { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  f |3:   f |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: fm |3:   fm |4:   f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: mt |3:   fmt |4:   fm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: t. |3:   fmt. |4:   fmt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.P
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: .P |3:   fmt.P |4:   fmt. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: Pr |3:   fmt.Pr |4:   fmt.P |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Pri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ri |3:   fmt.Pri |4:   fmt.Pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Prin
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: in |3:   fmt.Prin |4:   fmt.Pri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Print
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: nt |3:   fmt.Print |4:   fmt.Prin |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: tf |3:   fmt.Printf |4:   fmt.Print |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: f( |3:   fmt.Printf( |4:   fmt.Printf |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: (" |3:   fmt.Printf(" |4:   fmt.Printf( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("'
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: "' |3:   fmt.Printf("' |4:   fmt.Printf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("'o
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: 'o |3:   fmt.Printf("'o |4:   fmt.Printf("' |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("'ot
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ot |3:   fmt.Printf("'ot |4:   fmt.Printf("'o |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("'ot 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: t  |3:   fmt.Printf("'ot  |4:   fmt.Printf("'ot |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("'ot
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: t  |3:   fmt.Printf("'ot |4:   fmt.Printf("'ot  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("'o
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ot |3:   fmt.Printf("'o |4:   fmt.Printf("'ot |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("'
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: 'o |3:   fmt.Printf("' |4:   fmt.Printf("'o |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: "' |3:   fmt.Printf(" |4:   fmt.Printf("' |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: "g |3:   fmt.Printf("g |4:   fmt.Printf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("go
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: go |3:   fmt.Printf("go |4:   fmt.Printf("g |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ot |3:   fmt.Printf("got |4:   fmt.Printf("go |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: t  |3:   fmt.Printf("got  |4:   fmt.Printf("got |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:  / |3:   fmt.Printf("got / |4:   fmt.Printf("got  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got / 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: /  |3:   fmt.Printf("got /  |4:   fmt.Printf("got / |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got / r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:  r |3:   fmt.Printf("got / r |4:   fmt.Printf("got /  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got / re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: re |3:   fmt.Printf("got / re |4:   fmt.Printf("got / r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got / requ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: equ |3:   fmt.Printf("got / requ |4:   fmt.Printf("got / re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got / reque
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ue |3:   fmt.Printf("got / reque |4:   fmt.Printf("got / requ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got / reques
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: es |3:   fmt.Printf("got / reques |4:   fmt.Printf("got / reque |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got / request
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: st |3:   fmt.Printf("got / request |4:   fmt.Printf("got / reques |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got / requests
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ts |3:   fmt.Printf("got / requests |4:   fmt.Printf("got / request |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got / requests\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: s\ |3:   fmt.Printf("got / requests\ |4:   fmt.Printf("got / requests |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got / requests\n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: \n |3:   fmt.Printf("got / requests\n |4:   fmt.Printf("got / requests\ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:   fmt.Printf("got / requests\n |3:  |4:   fmt.Printf("got / requests\n |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  i |3:   i |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: io |3:   io |4:   i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: o. |3:   io. |4:   io |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.W
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: .W |3:   io.W |4:   io. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.Wr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: Wr |3:   io.Wr |4:   io.W |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.Wri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ri |3:   io.Wri |4:   io.Wr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.Writ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: it |3:   io.Writ |4:   io.Wri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.Write
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: te |3:   io.Write |4:   io.Writ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteS
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: eS |3:   io.WriteS |4:   io.Write |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteSt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: St |3:   io.WriteSt |4:   io.WriteS |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteStr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: tr |3:   io.WriteStr |4:   io.WriteSt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: ring |3:   io.WriteString |4:   io.WriteStr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: g( |3:   io.WriteString( |4:   io.WriteString |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: (w |3:   io.WriteString(w |4:   io.WriteString( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: w, |3:   io.WriteString(w, |4:   io.WriteString(w |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: ,  |3:   io.WriteString(w,  |4:   io.WriteString(w, |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2:  " |3:   io.WriteString(w, " |4:   io.WriteString(w,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: "This |3:   io.WriteString(w, "This |4:   io.WriteString(w, " |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: s  |3:   io.WriteString(w, "This  |4:   io.WriteString(w, "This |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2:  i |3:   io.WriteString(w, "This i |4:   io.WriteString(w, "This  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This is
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: is |3:   io.WriteString(w, "This is |4:   io.WriteString(w, "This i |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This is 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: s  |3:   io.WriteString(w, "This is  |4:   io.WriteString(w, "This is |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This is m
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2:  m |3:   io.WriteString(w, "This is m |4:   io.WriteString(w, "This is  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This is my
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: my |3:   io.WriteString(w, "This is my |4:   io.WriteString(w, "This is m |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This is my 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: y  |3:   io.WriteString(w, "This is my  |4:   io.WriteString(w, "This is my |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This is my w
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2:  w |3:   io.WriteString(w, "This is my w |4:   io.WriteString(w, "This is my  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This is my we
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: we |3:   io.WriteString(w, "This is my we |4:   io.WriteString(w, "This is my w |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This is my web
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: eb |3:   io.WriteString(w, "This is my web |4:   io.WriteString(w, "This is my we |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This is my webs
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: bs |3:   io.WriteString(w, "This is my webs |4:   io.WriteString(w, "This is my web |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This is my websi
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: si |3:   io.WriteString(w, "This is my websi |4:   io.WriteString(w, "This is my webs |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This is my websit
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: it |3:   io.WriteString(w, "This is my websit |4:   io.WriteString(w, "This is my websi |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This is my website
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: te |3:   io.WriteString(w, "This is my website |4:   io.WriteString(w, "This is my websit |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This is my website!
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: e! |3:   io.WriteString(w, "This is my website! |4:   io.WriteString(w, "This is my website |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This is my website!\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: !\ |3:   io.WriteString(w, "This is my website!\ |4:   io.WriteString(w, "This is my website! |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "This is my website!\n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: \n |3:   io.WriteString(w, "This is my website!\n |4:   io.WriteString(w, "This is my website!\ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: f |3: f |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: fu |3: fu |4: f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: un |3: fun |4: fu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: nc |3: func |4: fun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: c  |3: func  |4: func |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  g |3: func g |4: func  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func ge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ge |3: func ge |4: func g |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func get
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: et |3: func get |4: func ge |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getH
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: tH |3: func getH |4: func get |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: He |3: func getHe |4: func getH |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: el |3: func getHel |4: func getHe |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ll |3: func getHell |4: func getHel |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: lo |3: func getHello |4: func getHell |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: o( |3: func getHello( |4: func getHello |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: (w |3: func getHello(w |4: func getHello( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: w  |3: func getHello(w  |4: func getHello(w |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2:  h |3: func getHello(w h |4: func getHello(w  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: ht |3: func getHello(w ht |4: func getHello(w h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: tt |3: func getHello(w htt |4: func getHello(w ht |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: tp |3: func getHello(w http |4: func getHello(w htt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: p. |3: func getHello(w http. |4: func getHello(w http |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: .R |3: func getHello(w http.R |4: func getHello(w http. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: Re |3: func getHello(w http.Re |4: func getHello(w http.R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.Res
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: es |3: func getHello(w http.Res |4: func getHello(w http.Re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.Resp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: sp |3: func getHello(w http.Resp |4: func getHello(w http.Res |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.Respo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: po |3: func getHello(w http.Respo |4: func getHello(w http.Resp |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.Respon
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: on |3: func getHello(w http.Respon |4: func getHello(w http.Respo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.Respon 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: n  |3: func getHello(w http.Respon  |4: func getHello(w http.Respon |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.Respon
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: n  |3: func getHello(w http.Respon |4: func getHello(w http.Respon  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: nseWriter |3: func getHello(w http.ResponseWriter |4: func getHello(w http.Respon |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2: r, |3: func getHello(w http.ResponseWriter, |4: func getHello(w http.ResponseWriter |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2: ,  |3: func getHello(w http.ResponseWriter,  |4: func getHello(w http.ResponseWriter, |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2:  r |3: func getHello(w http.ResponseWriter, r |4: func getHello(w http.ResponseWriter,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2: r  |3: func getHello(w http.ResponseWriter, r  |4: func getHello(w http.ResponseWriter, r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2:  * |3: func getHello(w http.ResponseWriter, r * |4: func getHello(w http.ResponseWriter, r  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2: *h |3: func getHello(w http.ResponseWriter, r *h |4: func getHello(w http.ResponseWriter, r * |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2: ht |3: func getHello(w http.ResponseWriter, r *ht |4: func getHello(w http.ResponseWriter, r *h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2: tt |3: func getHello(w http.ResponseWriter, r *htt |4: func getHello(w http.ResponseWriter, r *ht |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2: tp |3: func getHello(w http.ResponseWriter, r *http |4: func getHello(w http.ResponseWriter, r *htt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2: p. |3: func getHello(w http.ResponseWriter, r *http. |4: func getHello(w http.ResponseWriter, r *http |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *http.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2: .R |3: func getHello(w http.ResponseWriter, r *http.R |4: func getHello(w http.ResponseWriter, r *http. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *http.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2: Re |3: func getHello(w http.ResponseWriter, r *http.Re |4: func getHello(w http.ResponseWriter, r *http.R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *http.Requ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2: equ |3: func getHello(w http.ResponseWriter, r *http.Requ |4: func getHello(w http.ResponseWriter, r *http.Re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *http.Reque
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2: ue |3: func getHello(w http.ResponseWriter, r *http.Reque |4: func getHello(w http.ResponseWriter, r *http.Requ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *http.Reques
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2: es |3: func getHello(w http.ResponseWriter, r *http.Reques |4: func getHello(w http.ResponseWriter, r *http.Reque |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *http.Request
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2: st |3: func getHello(w http.ResponseWriter, r *http.Request |4: func getHello(w http.ResponseWriter, r *http.Reques |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2: func getHello(w http.ResponseWriter, r *http.Request |3:  |4: func getHello(w http.ResponseWriter, r *http.Request |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *http.Request)
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 53
󰘫  |1: delta |2: func getHello(w http.ResponseWriter, r *http.Request) |3: func getHello(w http.ResponseWriter, r *http.Request) |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *http.Request) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 54
󰘫  |1: delta |2: )  |3: func getHello(w http.ResponseWriter, r *http.Request)  |4: func getHello(w http.ResponseWriter, r *http.Request) |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *http.Request) [
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 55
󰘫  |1: delta |2:  [ |3: func getHello(w http.ResponseWriter, r *http.Request) [ |4: func getHello(w http.ResponseWriter, r *http.Request)  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *http.Request) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 54
󰘫  |1: delta |2:  [ |3: func getHello(w http.ResponseWriter, r *http.Request)  |4: func getHello(w http.ResponseWriter, r *http.Request) [ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *http.Request) {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 55
󰘫  |1: delta |2:  { |3: func getHello(w http.ResponseWriter, r *http.Request) { |4: func getHello(w http.ResponseWriter, r *http.Request)  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: unc getHello(w http.ResponseWriter, r *http.Request) { |3:    |4: func getHello(w http.ResponseWriter, r *http.Request) { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  f |3:   f |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: fm |3:   fm |4:   f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: mt |3:   fmt |4:   fm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: t. |3:   fmt. |4:   fmt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Print
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: .Print |3:   fmt.Print |4:   fmt. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: tf |3:   fmt.Printf |4:   fmt.Print |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: f( |3:   fmt.Printf( |4:   fmt.Printf |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: (" |3:   fmt.Printf(" |4:   fmt.Printf( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: "g |3:   fmt.Printf("g |4:   fmt.Printf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("go
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: go |3:   fmt.Printf("go |4:   fmt.Printf("g |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ot |3:   fmt.Printf("got |4:   fmt.Printf("go |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: t  |3:   fmt.Printf("got  |4:   fmt.Printf("got |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:  / |3:   fmt.Printf("got / |4:   fmt.Printf("got  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: /h |3:   fmt.Printf("got /h |4:   fmt.Printf("got / |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /he
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: he |3:   fmt.Printf("got /he |4:   fmt.Printf("got /h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: el |3:   fmt.Printf("got /hel |4:   fmt.Printf("got /he |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /helo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: lo |3:   fmt.Printf("got /helo |4:   fmt.Printf("got /hel |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /heloo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: oo |3:   fmt.Printf("got /heloo |4:   fmt.Printf("got /helo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /helo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: oo |3:   fmt.Printf("got /helo |4:   fmt.Printf("got /heloo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: lo |3:   fmt.Printf("got /hel |4:   fmt.Printf("got /helo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ll |3:   fmt.Printf("got /hell |4:   fmt.Printf("got /hel |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: lo |3:   fmt.Printf("got /hello |4:   fmt.Printf("got /hell |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: o  |3:   fmt.Printf("got /hello  |4:   fmt.Printf("got /hello |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello z
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:  z |3:   fmt.Printf("got /hello z |4:   fmt.Printf("got /hello  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello zqu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: zqu |3:   fmt.Printf("got /hello zqu |4:   fmt.Printf("got /hello z |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello zque
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ue |3:   fmt.Printf("got /hello zque |4:   fmt.Printf("got /hello zqu |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello zques
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: es |3:   fmt.Printf("got /hello zques |4:   fmt.Printf("got /hello zque |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello zquest
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: st |3:   fmt.Printf("got /hello zquest |4:   fmt.Printf("got /hello zques |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello zques
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: st |3:   fmt.Printf("got /hello zques |4:   fmt.Printf("got /hello zquest |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello zque
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: es |3:   fmt.Printf("got /hello zque |4:   fmt.Printf("got /hello zques |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello zqu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ue |3:   fmt.Printf("got /hello zqu |4:   fmt.Printf("got /hello zque |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello zq
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: qu |3:   fmt.Printf("got /hello zq |4:   fmt.Printf("got /hello zqu |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello z
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: zq |3:   fmt.Printf("got /hello z |4:   fmt.Printf("got /hello zq |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:  z |3:   fmt.Printf("got /hello  |4:   fmt.Printf("got /hello z |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:  r |3:   fmt.Printf("got /hello r |4:   fmt.Printf("got /hello  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: re |3:   fmt.Printf("got /hello re |4:   fmt.Printf("got /hello r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello reu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: eu |3:   fmt.Printf("got /hello reu |4:   fmt.Printf("got /hello re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: eu |3:   fmt.Printf("got /hello re |4:   fmt.Printf("got /hello reu |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello requ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: equ |3:   fmt.Printf("got /hello requ |4:   fmt.Printf("got /hello re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello reque
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ue |3:   fmt.Printf("got /hello reque |4:   fmt.Printf("got /hello requ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello reques
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: es |3:   fmt.Printf("got /hello reques |4:   fmt.Printf("got /hello reque |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello request
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: st |3:   fmt.Printf("got /hello request |4:   fmt.Printf("got /hello reques |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello request/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: t/ |3:   fmt.Printf("got /hello request/ |4:   fmt.Printf("got /hello request |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello request
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: t/ |3:   fmt.Printf("got /hello request |4:   fmt.Printf("got /hello request/ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello request\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: t\ |3:   fmt.Printf("got /hello request\ |4:   fmt.Printf("got /hello request |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("got /hello request\n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: \n |3:   fmt.Printf("got /hello request\n |4:   fmt.Printf("got /hello request\ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  fmt.Printf("got /hello request\n |3:    |4:   fmt.Printf("got /hello request\n |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  i |3:   i |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: io |3:   io |4:   i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: o. |3:   io. |4:   io |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.W
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: .W |3:   io.W |4:   io. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.Wr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: Wr |3:   io.Wr |4:   io.W |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.Wri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ri |3:   io.Wri |4:   io.Wr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.Writ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: it |3:   io.Writ |4:   io.Wri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.Write
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: te |3:   io.Write |4:   io.Writ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteS
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: eS |3:   io.WriteS |4:   io.Write |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: String |3:   io.WriteString |4:   io.WriteS |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: g( |3:   io.WriteString( |4:   io.WriteString |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: (w |3:   io.WriteString(w |4:   io.WriteString( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: w, |3:   io.WriteString(w, |4:   io.WriteString(w |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w,R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: ,R |3:   io.WriteString(w,R |4:   io.WriteString(w, |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: ,R |3:   io.WriteString(w, |4:   io.WriteString(w,R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: ,  |3:   io.WriteString(w,  |4:   io.WriteString(w, |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2:  " |3:   io.WriteString(w, " |4:   io.WriteString(w,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: "H |3:   io.WriteString(w, "H |4:   io.WriteString(w, " |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "He
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: He |3:   io.WriteString(w, "He |4:   io.WriteString(w, "H |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "Hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: el |3:   io.WriteString(w, "Hel |4:   io.WriteString(w, "He |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "Hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: ll |3:   io.WriteString(w, "Hell |4:   io.WriteString(w, "Hel |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "Hello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: lo |3:   io.WriteString(w, "Hello |4:   io.WriteString(w, "Hell |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "Hello,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: o, |3:   io.WriteString(w, "Hello, |4:   io.WriteString(w, "Hello |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "Hello, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: ,  |3:   io.WriteString(w, "Hello,  |4:   io.WriteString(w, "Hello, |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "Hello, H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2:  H |3:   io.WriteString(w, "Hello, H |4:   io.WriteString(w, "Hello,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "Hello, HP
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: HP |3:   io.WriteString(w, "Hello, HP |4:   io.WriteString(w, "Hello, H |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "Hello, H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: HP |3:   io.WriteString(w, "Hello, H |4:   io.WriteString(w, "Hello, HP |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "Hello, HT
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: HT |3:   io.WriteString(w, "Hello, HT |4:   io.WriteString(w, "Hello, H |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "Hello, HTT
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: TT |3:   io.WriteString(w, "Hello, HTT |4:   io.WriteString(w, "Hello, HT |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "Hello, HTTP
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: TP |3:   io.WriteString(w, "Hello, HTTP |4:   io.WriteString(w, "Hello, HTT |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "Hello, HTTP!
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: P! |3:   io.WriteString(w, "Hello, HTTP! |4:   io.WriteString(w, "Hello, HTTP |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "Hello, HTTP!\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: !\ |3:   io.WriteString(w, "Hello, HTTP!\ |4:   io.WriteString(w, "Hello, HTTP! |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "Hello, HTTP!\n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: \n |3:   io.WriteString(w, "Hello, HTTP!\n |4:   io.WriteString(w, "Hello, HTTP!\ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   io.WriteString(w, "Hello, HTTP!\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2:   io.WriteString(w, "Hello, HTTP!\ |3:   io.WriteString(w, "Hello, HTTP!\ |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: i |3: i |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: if
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: if |3: if |4: i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: ifu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: fu |3: ifu |4: if |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: ifun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: un |3: ifun |4: ifu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: ifu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: un |3: ifu |4: ifun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: if
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: fu |3: if |4: ifu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: if |3: i |4: if |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2: i |3:  |4: i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: f |3: f |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: fu |3: fu |4: f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: un |3: fun |4: fu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: nc |3: func |4: fun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: c  |3: func  |4: func |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func m
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  m |3: func m |4: func  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func ma
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ma |3: func ma |4: func m |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func mai
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ai |3: func mai |4: func ma |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func main
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: in |3: func main |4: func mai |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func main(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 10
󰘫  |1: delta |2: n( |3: func main( |4: func main |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func main() 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ()  |3: func main()  |4: func main( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func main() {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2:  { |3: func main() { |4: func main()  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: unc main() { |3:    |4: func main() { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  h |3:   h |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ht |3:   ht |4:   h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: tt |3:   htt |4:   ht |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: tp |3:   http |4:   htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: p. |3:   http. |4:   http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: .H |3:   http.H |4:   http. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Hn
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: Hn |3:   http.Hn |4:   http.H |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Hnd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: nd |3:   http.Hnd |4:   http.Hn |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Hndl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: dl |3:   http.Hndl |4:   http.Hnd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Hndle
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: le |3:   http.Hndle |4:   http.Hndl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Hndl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: le |3:   http.Hndl |4:   http.Hndle |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Hnd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: dl |3:   http.Hnd |4:   http.Hndl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Hn
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: nd |3:   http.Hn |4:   http.Hnd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: Hn |3:   http.H |4:   http.Hn |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Hand
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: Hand |3:   http.Hand |4:   http.H |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Handl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: dl |3:   http.Handl |4:   http.Hand |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Handld
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: ld |3:   http.Handld |4:   http.Handl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldF
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: dF |3:   http.HandldF |4:   http.Handld |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: Fu |3:   http.HandldFu |4:   http.HandldF |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: un |3:   http.HandldFun |4:   http.HandldFu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFunc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: nc |3:   http.HandldFunc |4:   http.HandldFun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFunc(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: c( |3:   http.HandldFunc( |4:   http.HandldFunc |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFunc("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: (" |3:   http.HandldFunc(" |4:   http.HandldFunc( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFunc("/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: "/ |3:   http.HandldFunc("/ |4:   http.HandldFunc(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFunc("/",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: /", |3:   http.HandldFunc("/", |4:   http.HandldFunc("/ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFunc("/", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: ,  |3:   http.HandldFunc("/",  |4:   http.HandldFunc("/", |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFunc("/", g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2:  g |3:   http.HandldFunc("/", g |4:   http.HandldFunc("/",  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFunc("/", ge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: ge |3:   http.HandldFunc("/", ge |4:   http.HandldFunc("/", g |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFunc("/", get
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: et |3:   http.HandldFunc("/", get |4:   http.HandldFunc("/", ge |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFunc("/", getR
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: tR |3:   http.HandldFunc("/", getR |4:   http.HandldFunc("/", get |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFunc("/", getRo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: Ro |3:   http.HandldFunc("/", getRo |4:   http.HandldFunc("/", getR |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFunc("/", getRot
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: ot |3:   http.HandldFunc("/", getRot |4:   http.HandldFunc("/", getRo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFunc("/", getRo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: ot |3:   http.HandldFunc("/", getRo |4:   http.HandldFunc("/", getRot |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFunc("/", getRoo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: oo |3:   http.HandldFunc("/", getRoo |4:   http.HandldFunc("/", getRo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandldFunc("/", getRoot
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: ot |3:   http.HandldFunc("/", getRoot |4:   http.HandldFunc("/", getRoo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  http.HandldFunc("/", getRoot |3:    |4:   http.HandldFunc("/", getRoot |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  h |3:   h |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ht |3:   ht |4:   h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: tt |3:   htt |4:   ht |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: tp |3:   http |4:   htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: p. |3:   http. |4:   http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: .H |3:   http.H |4:   http. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Hand
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: Hand |3:   http.Hand |4:   http.H |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Handl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: dl |3:   http.Handl |4:   http.Hand |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Handle
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: le |3:   http.Handle |4:   http.Handl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleF
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: eF |3:   http.HandleF |4:   http.Handle |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: Fu |3:   http.HandleFu |4:   http.HandleF |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: un |3:   http.HandleFun |4:   http.HandleFu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: nc |3:   http.HandleFunc |4:   http.HandleFun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: c( |3:   http.HandleFunc( |4:   http.HandleFunc |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc(R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: (R |3:   http.HandleFunc(R |4:   http.HandleFunc( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: (R |3:   http.HandleFunc( |4:   http.HandleFunc(R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: (" |3:   http.HandleFunc(" |4:   http.HandleFunc( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: "/ |3:   http.HandleFunc("/ |4:   http.HandleFunc(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: /h |3:   http.HandleFunc("/h |4:   http.HandleFunc("/ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/he
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: he |3:   http.HandleFunc("/he |4:   http.HandleFunc("/h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: el |3:   http.HandleFunc("/hel |4:   http.HandleFunc("/he |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: ll |3:   http.HandleFunc("/hell |4:   http.HandleFunc("/hel |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: lo |3:   http.HandleFunc("/hello |4:   http.HandleFunc("/hell |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: o", |3:   http.HandleFunc("/hello", |4:   http.HandleFunc("/hello |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: ,  |3:   http.HandleFunc("/hello",  |4:   http.HandleFunc("/hello", |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2:  g |3:   http.HandleFunc("/hello", g |4:   http.HandleFunc("/hello",  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", ge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: ge |3:   http.HandleFunc("/hello", ge |4:   http.HandleFunc("/hello", g |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", get
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: et |3:   http.HandleFunc("/hello", get |4:   http.HandleFunc("/hello", ge |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", getH
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: tH |3:   http.HandleFunc("/hello", getH |4:   http.HandleFunc("/hello", get |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", getHe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: He |3:   http.HandleFunc("/hello", getHe |4:   http.HandleFunc("/hello", getH |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", getHel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: el |3:   http.HandleFunc("/hello", getHel |4:   http.HandleFunc("/hello", getHe |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", getHell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: ll |3:   http.HandleFunc("/hello", getHell |4:   http.HandleFunc("/hello", getHel |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", getHello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: lo |3:   http.HandleFunc("/hello", getHello |4:   http.HandleFunc("/hello", getHell |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  http.HandleFunc("/hello", getHello |3:    |4:   http.HandleFunc("/hello", getHello |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/bin/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2:  http.HandleFunc("/bin/ |3:   http.HandleFunc("/bin/ |4:    |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/bin
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: n/ |3:   http.HandleFunc("/bin |4:   http.HandleFunc("/bin/ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/bi
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: in |3:   http.HandleFunc("/bi |4:   http.HandleFunc("/bin |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/b
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: bi |3:   http.HandleFunc("/b |4:   http.HandleFunc("/bi |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: /b |3:   http.HandleFunc("/ |4:   http.HandleFunc("/b |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: "/ |3:   http.HandleFunc(" |4:   http.HandleFunc("/ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc(""
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: "" |3:   http.HandleFunc("" |4:   http.HandleFunc(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: "" |3:   http.HandleFunc(" |4:   http.HandleFunc("" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: "/ |3:   http.HandleFunc("/ |4:   http.HandleFunc(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: /h |3:   http.HandleFunc("/h |4:   http.HandleFunc("/ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/he
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: he |3:   http.HandleFunc("/he |4:   http.HandleFunc("/h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: el |3:   http.HandleFunc("/hel |4:   http.HandleFunc("/he |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: ll |3:   http.HandleFunc("/hell |4:   http.HandleFunc("/hel |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: lo |3:   http.HandleFunc("/hello |4:   http.HandleFunc("/hell |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: o" |3:   http.HandleFunc("/hello" |4:   http.HandleFunc("/hello |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello" 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: "  |3:   http.HandleFunc("/hello"  |4:   http.HandleFunc("/hello" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: "  |3:   http.HandleFunc("/hello" |4:   http.HandleFunc("/hello"  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: ", |3:   http.HandleFunc("/hello", |4:   http.HandleFunc("/hello" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: ,  |3:   http.HandleFunc("/hello",  |4:   http.HandleFunc("/hello", |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2:  g |3:   http.HandleFunc("/hello", g |4:   http.HandleFunc("/hello",  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", ge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: ge |3:   http.HandleFunc("/hello", ge |4:   http.HandleFunc("/hello", g |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", get
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: et |3:   http.HandleFunc("/hello", get |4:   http.HandleFunc("/hello", ge |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", getH
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: tH |3:   http.HandleFunc("/hello", getH |4:   http.HandleFunc("/hello", get |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", getHe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: He |3:   http.HandleFunc("/hello", getHe |4:   http.HandleFunc("/hello", getH |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", getHel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: el |3:   http.HandleFunc("/hello", getHel |4:   http.HandleFunc("/hello", getHe |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", getHell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: ll |3:   http.HandleFunc("/hello", getHell |4:   http.HandleFunc("/hello", getHel |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", getHello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: lo |3:   http.HandleFunc("/hello", getHello |4:   http.HandleFunc("/hello", getHell |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/hello", getHello)
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 37
󰘫  |1: delta |2: o) |3:   http.HandleFunc("/hello", getHello) |4:   http.HandleFunc("/hello", getHello |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  http.HandleFunc("/hello", getHello) |3:    |4:   http.HandleFunc("/hello", getHello) |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   e
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  e |3:   e |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: er |3:   er |4:   e |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: rr |3:   err |4:   er |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: r  |3:   err  |4:   err |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2:  : |3:   err : |4:   err  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: := |3:   err := |4:   err : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: =  |3:   err :=  |4:   err := |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:  h |3:   err := h |4:   err :=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ht |3:   err := ht |4:   err := h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: tt |3:   err := htt |4:   err := ht |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: tp |3:   err := http |4:   err := htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: p. |3:   err := http. |4:   err := http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.L
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: .L |3:   err := http.L |4:   err := http. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.Li
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: Li |3:   err := http.Li |4:   err := http.L |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.Lis
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: is |3:   err := http.Lis |4:   err := http.Li |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.List
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: st |3:   err := http.List |4:   err := http.Lis |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.Liste
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: te |3:   err := http.Liste |4:   err := http.List |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.Listen
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: en |3:   err := http.Listen |4:   err := http.Liste |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAnd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: nAnd |3:   err := http.ListenAnd |4:   err := http.Listen |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndS
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: dS |3:   err := http.ListenAndS |4:   err := http.ListenAnd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndSe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: Se |3:   err := http.ListenAndSe |4:   err := http.ListenAndS |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndSer
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: er |3:   err := http.ListenAndSer |4:   err := http.ListenAndSe |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: rv |3:   err := http.ListenAndServ |4:   err := http.ListenAndSer |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: ve |3:   err := http.ListenAndServe |4:   err := http.ListenAndServ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: e( |3:   err := http.ListenAndServe( |4:   err := http.ListenAndServe |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: (" |3:   err := http.ListenAndServe(" |4:   err := http.ListenAndServe( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: ": |3:   err := http.ListenAndServe(": |4:   err := http.ListenAndServe(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":star
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: :star |3:   err := http.ListenAndServe(":star |4:   err := http.ListenAndServe(": |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":stara
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: ra |3:   err := http.ListenAndServe(":stara |4:   err := http.ListenAndServe(":star |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":staras
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: as |3:   err := http.ListenAndServe(":staras |4:   err := http.ListenAndServe(":stara |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":stara
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: as |3:   err := http.ListenAndServe(":stara |4:   err := http.ListenAndServe(":staras |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":star
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: ra |3:   err := http.ListenAndServe(":star |4:   err := http.ListenAndServe(":stara |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":sta
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: ar |3:   err := http.ListenAndServe(":sta |4:   err := http.ListenAndServe(":star |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":st
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: ta |3:   err := http.ListenAndServe(":st |4:   err := http.ListenAndServe(":sta |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: st |3:   err := http.ListenAndServe(":s |4:   err := http.ListenAndServe(":st |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: :s |3:   err := http.ListenAndServe(": |4:   err := http.ListenAndServe(":s |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: :s |3:   err := http.ListenAndServe(":s |4:   err := http.ListenAndServe(": |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":ss
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: ss |3:   err := http.ListenAndServe(":ss |4:   err := http.ListenAndServe(":s |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":sss
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: ss |3:   err := http.ListenAndServe(":sss |4:   err := http.ListenAndServe(":ss |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":ss
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: ss |3:   err := http.ListenAndServe(":ss |4:   err := http.ListenAndServe(":sss |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: ss |3:   err := http.ListenAndServe(":s |4:   err := http.ListenAndServe(":ss |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: :s |3:   err := http.ListenAndServe(": |4:   err := http.ListenAndServe(":s |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: :3 |3:   err := http.ListenAndServe(":3 |4:   err := http.ListenAndServe(": |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":33
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: 33 |3:   err := http.ListenAndServe(":33 |4:   err := http.ListenAndServe(":3 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":333
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: 33 |3:   err := http.ListenAndServe(":333 |4:   err := http.ListenAndServe(":33 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3333
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: 33 |3:   err := http.ListenAndServe(":3333 |4:   err := http.ListenAndServe(":333 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3333",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 37
󰘫  |1: delta |2: 3", |3:   err := http.ListenAndServe(":3333", |4:   err := http.ListenAndServe(":3333 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3333", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 37
󰘫  |1: delta |2: ,  |3:   err := http.ListenAndServe(":3333",  |4:   err := http.ListenAndServe(":3333", |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3333", n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 37
󰘫  |1: delta |2:  n |3:   err := http.ListenAndServe(":3333", n |4:   err := http.ListenAndServe(":3333",  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3333", ni
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 37
󰘫  |1: delta |2: ni |3:   err := http.ListenAndServe(":3333", ni |4:   err := http.ListenAndServe(":3333", n |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3333", nil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 37
󰘫  |1: delta |2: il |3:   err := http.ListenAndServe(":3333", nil |4:   err := http.ListenAndServe(":3333", ni |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3333", ni
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 37
󰘫  |1: delta |2:   err := http.ListenAndServe(":3333", ni |3:   err := http.ListenAndServe(":3333", ni |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 		os.Exit(1)
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: 	os.Exit(1) |3: 		os.Exit(1) |4:    |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 		os.Exit(1)
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: 		os.Exit(1) |3: 		os.Exit(1) |4: 		os.Exit(1) |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: s.Exit(1) |3:      |4: 		os.Exit(1) |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     <^>}
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2:  <^>} |3:     <^>} |4:      |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     <^>
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2:     <^> |3:     <^> |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package main
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: package main |3: package main |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package main;
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: n; |3: package main; |4: package main |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: import ("errors", |3: import ("errors", |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2: ", |3: import ("errors" |4: import ("errors", |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package main;
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: package main; |3: package main; |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package main
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: n; |3: package main |4: package main; |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors" "fmt",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 23
󰘫  |1: delta |2: import ("errors" "fmt", |3: import ("errors" "fmt", |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors" "fmt"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2: ", |3: import ("errors" "fmt" |4: import ("errors" "fmt", |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors" "fmt" "io"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2: " "io" |3: import ("errors" "fmt" "io" |4: import ("errors" "fmt" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors" "fmt" "io" "net/http"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2: " "net/http" |3: import ("errors" "fmt" "io" "net/http" |4: import ("errors" "fmt" "io" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import ("errors" "fmt" "io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2: import ("errors" "fmt" "io |3: import ("errors" "fmt" "io |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import (
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 8
󰘫  |1: delta |2: import ( |3: import ( |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: mport ( |3:    |4: import ( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:    |3:  |4:    |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   }
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:    |3:   } |4:      |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Handld
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2:   http.Handld |3:   http.Handld |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Handl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ld |3:   http.Handl |4:   http.Handld |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Handle
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: le |3:   http.Handle |4:   http.Handl |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Handl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2:   http.Handl |3:   http.Handl |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   m
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  m |3:   m |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: mu |3:   mu |4:   m |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: ux |3:   mux |4:   mu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: x  |3:   mux  |4:   mux |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2:  : |3:   mux : |4:   mux  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: := |3:   mux := |4:   mux : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: =  |3:   mux :=  |4:   mux := |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:  h |3:   mux := h |4:   mux :=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ht |3:   mux := ht |4:   mux := h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: tt |3:   mux := htt |4:   mux := ht |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: tp |3:   mux := http |4:   mux := htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: p. |3:   mux := http. |4:   mux := http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := http.N
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: .N |3:   mux := http.N |4:   mux := http. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := http.Ne
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: Ne |3:   mux := http.Ne |4:   mux := http.N |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := http.New
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: ew |3:   mux := http.New |4:   mux := http.Ne |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := http.NewS
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: wS |3:   mux := http.NewS |4:   mux := http.New |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := http.NewSe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: Se |3:   mux := http.NewSe |4:   mux := http.NewS |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := http.NewSer
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: er |3:   mux := http.NewSer |4:   mux := http.NewSe |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := http.NewServ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: rv |3:   mux := http.NewServ |4:   mux := http.NewSer |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := http.NewServe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: ve |3:   mux := http.NewServe |4:   mux := http.NewServ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := http.NewServeM
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: eM |3:   mux := http.NewServeM |4:   mux := http.NewServe |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := http.NewServeMu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: Mu |3:   mux := http.NewServeMu |4:   mux := http.NewServeM |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := http.NewServeMux
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: ux |3:   mux := http.NewServeMux |4:   mux := http.NewServeMu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   mux := http.NewServeMux(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 26
󰘫  |1: delta |2: x( |3:   mux := http.NewServeMux( |4:   mux := http.NewServeMux |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 26,
      line = 21
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "NewServeMux allocates and returns a new ServeMux."
      },
      label = "NewServeMux() *http.ServeMux"
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  mux := http.NewServeMux(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: no sig
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3333", nil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 37
󰘫  |1: delta |2:   err := http.ListenAndServe(":3333", nil |3:   err := http.ListenAndServe(":3333", nil |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3333", ni
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 37
󰘫  |1: delta |2: il |3:   err := http.ListenAndServe(":3333", ni |4:   err := http.ListenAndServe(":3333", nil |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 37,
      line = 25
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  err := http.ListenAndServe(":3333",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 37,
      line = 25
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  err := http.ListenAndServe(":3333",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3:   if errors.Is(err, http.ErrServerClosed) { |4: { 26, 40 }
 |5: 24 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 25 |3: 24 |4: { "                                          handler http.Handler", "Comment" }

󰘫  |1: virtual text only : |2:  |3:   if errors.Is(err, http.ErrServerClosed) { |4: { 26, 40 }
 |5: 24 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 25 |3: 24 |4: { "                                          handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3333", n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 37
󰘫  |1: delta |2: ni |3:   err := http.ListenAndServe(":3333", n |4:   err := http.ListenAndServe(":3333", ni |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 37,
      line = 25
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  err := http.ListenAndServe(":3333",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3:   if errors.Is(err, http.ErrServerClosed) { |4: { 26, 38 }
 |5: 24 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 25 |3: 24 |4: { "                                        handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3333", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 37
󰘫  |1: delta |2:  n |3:   err := http.ListenAndServe(":3333",  |4:   err := http.ListenAndServe(":3333", n |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 37,
      line = 25
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  err := http.ListenAndServe(":3333",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3:   if errors.Is(err, http.ErrServerClosed) { |4: { 26, 38 }
 |5: 24 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 25 |3: 24 |4: { "                                        handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3333", m
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 37
󰘫  |1: delta |2:  m |3:   err := http.ListenAndServe(":3333", m |4:   err := http.ListenAndServe(":3333",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 37,
      line = 25
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  err := http.ListenAndServe(":3333",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3:   if errors.Is(err, http.ErrServerClosed) { |4: { 26, 39 }
 |5: 24 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 25 |3: 24 |4: { "                                         handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3333", mu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 37
󰘫  |1: delta |2: mu |3:   err := http.ListenAndServe(":3333", mu |4:   err := http.ListenAndServe(":3333", m |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 37,
      line = 25
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  err := http.ListenAndServe(":3333",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3:   if errors.Is(err, http.ErrServerClosed) { |4: { 26, 40 }
 |5: 24 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 25 |3: 24 |4: { "                                          handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3333", mux
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 37
󰘫  |1: delta |2: ux |3:   err := http.ListenAndServe(":3333", mux |4:   err := http.ListenAndServe(":3333", mu |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 37,
      line = 25
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  err := http.ListenAndServe(":3333",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3:   if errors.Is(err, http.ErrServerClosed) { |4: { 26, 41 }
 |5: 24 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 25 |3: 24 |4: { "                                           handler http.Handler", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   err := http.ListenAndServe(":3333", mu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 37
󰘫  |1: delta |2:   err := http.ListenAndServe(":3333", mu |3:   err := http.ListenAndServe(":3333", mu |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 37,
      line = 25
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = '  err := http.ListenAndServe(":3333",',
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  " |3:   " |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   "n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: "n |3:   "n |4:   " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   "ne
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: ne |3:   "ne |4:   "n |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   "net
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: et |3:   "net |4:   "ne |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  " |3:   " |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   "c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: "c |3:   "c |4:   " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   "co
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: co |3:   "co |4:   "c |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   "con
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: on |3:   "con |4:   "co |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   "cont
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: nt |3:   "cont |4:   "con |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   "conte
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: te |3:   "conte |4:   "cont |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   "contex
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ex |3:   "contex |4:   "conte |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   "context
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: xt |3:   "context |4:   "contex |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   "contex
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2:   "contex |3:   "contex |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: c |3: c |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: co
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: co |3: co |4: c |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: con
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: on |3: con |4: co |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: cons
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ns |3: cons |4: con |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: st |3: const |4: cons |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: t  |3: const  |4: const |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const k
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2:  k |3: const k |4: const  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const ke
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ke |3: const ke |4: const k |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const key
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ey |3: const key |4: const ke |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyS
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: yS |3: const keyS |4: const key |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keySe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: Se |3: const keySe |4: const keyS |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keySer
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: er |3: const keySer |4: const keySe |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: rv |3: const keyServ |4: const keySer |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: ve |3: const keyServe |4: const keyServ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServer
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: er |3: const keyServer |4: const keyServe |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerA
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: rA |3: const keyServerA |4: const keyServer |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: Ad |3: const keyServerAd |4: const keyServerA |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAdd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: dd |3: const keyServerAdd |4: const keyServerAd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: dr |3: const keyServerAddr |4: const keyServerAdd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: r  |3: const keyServerAddr  |4: const keyServerAddr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr =
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:  = |3: const keyServerAddr = |4: const keyServerAddr  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr = 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: =  |3: const keyServerAddr =  |4: const keyServerAddr = |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr = "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2:  " |3: const keyServerAddr = " |4: const keyServerAddr =  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr = "s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: "s |3: const keyServerAddr = "s |4: const keyServerAddr = " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr = "ser
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: ser |3: const keyServerAddr = "ser |4: const keyServerAddr = "s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr = "serv
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: rv |3: const keyServerAddr = "serv |4: const keyServerAddr = "ser |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr = "serve
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: ve |3: const keyServerAddr = "serve |4: const keyServerAddr = "serv |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr = "servers
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2: ers |3: const keyServerAddr = "servers |4: const keyServerAddr = "serve |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr = "server
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: rs |3: const keyServerAddr = "server |4: const keyServerAddr = "servers |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr = "serverA
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2: rA |3: const keyServerAddr = "serverA |4: const keyServerAddr = "server |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr = "serverAd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2: Ad |3: const keyServerAddr = "serverAd |4: const keyServerAddr = "serverA |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr = "serverAdd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: dd |3: const keyServerAddr = "serverAdd |4: const keyServerAddr = "serverAd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr = "serverAddr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 33
󰘫  |1: delta |2: dr |3: const keyServerAddr = "serverAddr |4: const keyServerAddr = "serverAdd |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: const keyServerAddr = "serverAdd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: const keyServerAddr = "serverAdd |3: const keyServerAddr = "serverAdd |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  c |3:   c |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ct |3:   ct |4:   c |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   cts
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: ts |3:   cts |4:   ct |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ts |3:   ct |4:   cts |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: tx |3:   ctx |4:   ct |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: x  |3:   ctx  |4:   ctx |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2:  : |3:   ctx : |4:   ctx  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: := |3:   ctx := |4:   ctx : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: =  |3:   ctx :=  |4:   ctx := |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:  r |3:   ctx := r |4:   ctx :=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: r. |3:   ctx := r. |4:   ctx := r |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.C
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: .C |3:   ctx := r.C |4:   ctx := r. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.Co
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: Co |3:   ctx := r.Co |4:   ctx := r.C |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.Con
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: on |3:   ctx := r.Con |4:   ctx := r.Co |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.Cont
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: nt |3:   ctx := r.Cont |4:   ctx := r.Con |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.Conte
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: te |3:   ctx := r.Conte |4:   ctx := r.Cont |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.Contex
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: ex |3:   ctx := r.Contex |4:   ctx := r.Conte |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.Context
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: xt |3:   ctx := r.Context |4:   ctx := r.Contex |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.Context(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: t( |3:   ctx := r.Context( |4:   ctx := r.Context |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 14
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Context returns the request's context. To change the context, use Clone or WithContext.\n\nThe returned context is always non-nil; it defaults to the background context.\n\nFor outgoing client requests, the context controls cancellation.\n\nFor incoming server requests, the context is canceled when the client's connection closes, the request is canceled (with HTTP/2), or when the ServeHTTP method returns."
      },
      label = "Context() context.Context"
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx := r.Context(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: no sig
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.Context()
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: () |3:   ctx := r.Context() |4:   ctx := r.Context( |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  ctx := r.Context() |3:    |4:   ctx := r.Context() |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:   fmt.Printf(" |3:   fmt.Printf(" |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: "% |3:   fmt.Printf("% |4:   fmt.Printf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: %s |3:   fmt.Printf("%s |4:   fmt.Printf("% |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: s: |3:   fmt.Printf("%s: |4:   fmt.Printf("%s |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: :  |3:   fmt.Printf("%s:  |4:   fmt.Printf("%s: |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:  g |3:   fmt.Printf("%s: g |4:   fmt.Printf("%s:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: go
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: go |3:   fmt.Printf("%s: go |4:   fmt.Printf("%s: g |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ot |3:   fmt.Printf("%s: got |4:   fmt.Printf("%s: go |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: t  |3:   fmt.Printf("%s: got  |4:   fmt.Printf("%s: got |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:  / |3:   fmt.Printf("%s: got / |4:   fmt.Printf("%s: got  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: /  |3:   fmt.Printf("%s: got /  |4:   fmt.Printf("%s: got / |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:  r |3:   fmt.Printf("%s: got / r |4:   fmt.Printf("%s: got /  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: re |3:   fmt.Printf("%s: got / re |4:   fmt.Printf("%s: got / r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / requ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: equ |3:   fmt.Printf("%s: got / requ |4:   fmt.Printf("%s: got / re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / reque
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ue |3:   fmt.Printf("%s: got / reque |4:   fmt.Printf("%s: got / requ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / reques
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: es |3:   fmt.Printf("%s: got / reques |4:   fmt.Printf("%s: got / reque |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: st |3:   fmt.Printf("%s: got / request |4:   fmt.Printf("%s: got / reques |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: t\ |3:   fmt.Printf("%s: got / request\ |4:   fmt.Printf("%s: got / request |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: \n |3:   fmt.Printf("%s: got / request\n |4:   fmt.Printf("%s: got / request\ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: n", |3:   fmt.Printf("%s: got / request\n", |4:   fmt.Printf("%s: got / request\n |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 35,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 35 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                     a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: ,  |3:   fmt.Printf("%s: got / request\n",  |4:   fmt.Printf("%s: got / request\n", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 35,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 36 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                      a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2:  c |3:   fmt.Printf("%s: got / request\n", c |4:   fmt.Printf("%s: got / request\n",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 35,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 37 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                       a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", ct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: ct |3:   fmt.Printf("%s: got / request\n", ct |4:   fmt.Printf("%s: got / request\n", c |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 35,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 38 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                        a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", ctx
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: tx |3:   fmt.Printf("%s: got / request\n", ctx |4:   fmt.Printf("%s: got / request\n", ct |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 35,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 39 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                         a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", ctx.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: x. |3:   fmt.Printf("%s: got / request\n", ctx. |4:   fmt.Printf("%s: got / request\n", ctx |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 35,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 40 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                          a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", ctx.V
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: .V |3:   fmt.Printf("%s: got / request\n", ctx.V |4:   fmt.Printf("%s: got / request\n", ctx. |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 35,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 41 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                           a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", ctx.Va
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: Va |3:   fmt.Printf("%s: got / request\n", ctx.Va |4:   fmt.Printf("%s: got / request\n", ctx.V |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 35,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 42 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                            a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", ctx.Val
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: al |3:   fmt.Printf("%s: got / request\n", ctx.Val |4:   fmt.Printf("%s: got / request\n", ctx.Va |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 35,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 43 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                             a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", ctx.Valu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: lu |3:   fmt.Printf("%s: got / request\n", ctx.Valu |4:   fmt.Printf("%s: got / request\n", ctx.Val |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 35,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 44 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                              a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", ctx.Value
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: ue |3:   fmt.Printf("%s: got / request\n", ctx.Value |4:   fmt.Printf("%s: got / request\n", ctx.Valu |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 35,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 45 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                               a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", ctx.Value(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 46
󰘫  |1: delta |2: e( |3:   fmt.Printf("%s: got / request\n", ctx.Value( |4:   fmt.Printf("%s: got / request\n", ctx.Value |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 46,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: Value(key any) any |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 46 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                                key any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", ctx.Value(k
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 46
󰘫  |1: delta |2: (k |3:   fmt.Printf("%s: got / request\n", ctx.Value(k |4:   fmt.Printf("%s: got / request\n", ctx.Value( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 46,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: Value(key any) any |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 47 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                                 key any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", ctx.Value(ke
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 46
󰘫  |1: delta |2: ke |3:   fmt.Printf("%s: got / request\n", ctx.Value(ke |4:   fmt.Printf("%s: got / request\n", ctx.Value(k |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 46,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: Value(key any) any |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 48 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                                  key any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", ctx.Value(key
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 46
󰘫  |1: delta |2: ey |3:   fmt.Printf("%s: got / request\n", ctx.Value(key |4:   fmt.Printf("%s: got / request\n", ctx.Value(ke |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 46,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: Value(key any) any |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 49 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                                   key any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", ctx.Value(keyS
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 46
󰘫  |1: delta |2: yS |3:   fmt.Printf("%s: got / request\n", ctx.Value(keyS |4:   fmt.Printf("%s: got / request\n", ctx.Value(key |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 46,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: Value(key any) any |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 50 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                                    key any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", ctx.Value(keyServerAddr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 46
󰘫  |1: delta |2: ServerAddr |3:   fmt.Printf("%s: got / request\n", ctx.Value(keyServerAddr |4:   fmt.Printf("%s: got / request\n", ctx.Value(keyS |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 46,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got / request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: Value(key any) any |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 59 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                                             key any", "Comment" }

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got / request\n", ctx.Value(keyServerAddr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 46
󰘫  |1: delta |2:   fmt.Printf("%s: got / request\n", ctx.Value(keyServerAddr |3:   fmt.Printf("%s: got / request\n", ctx.Value(keyServerAddr |4:   fmt.Printf("%s: got / request\n", ctx.Value(keyServerAddr |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 46,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = '  fmt.Printf("%s: got / request\\n", ctx.Value(',
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |3: {
  border = "rounded",
  line_to_cursor = '  fmt.Printf("%s: got / request\\n", ctx.Value(',
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: Value(key any) any |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "This is my website!\n") |4: { 17, 59 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 15 |4: { "                                                             key any", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func getHello(w http.ResponseWriter, r *http.Request) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 54
󰘫  |1: delta |2: func getHello(w http.ResponseWriter, r *http.Request)  |3: func getHello(w http.ResponseWriter, r *http.Request)  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  c |3:   c |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ct |3:   ct |4:   c |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: tx |3:   ctx |4:   ct |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: x  |3:   ctx  |4:   ctx |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2:  : |3:   ctx : |4:   ctx  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: := |3:   ctx := |4:   ctx : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: =  |3:   ctx :=  |4:   ctx := |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:  r |3:   ctx := r |4:   ctx :=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: r. |3:   ctx := r. |4:   ctx := r |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.C
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: .C |3:   ctx := r.C |4:   ctx := r. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.Co
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: Co |3:   ctx := r.Co |4:   ctx := r.C |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.Con
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: on |3:   ctx := r.Con |4:   ctx := r.Co |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.Cont
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: nt |3:   ctx := r.Cont |4:   ctx := r.Con |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.Conte
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: te |3:   ctx := r.Conte |4:   ctx := r.Cont |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.Contex
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: ex |3:   ctx := r.Contex |4:   ctx := r.Conte |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.Context
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: xt |3:   ctx := r.Context |4:   ctx := r.Contex |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx := r.Context(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: t( |3:   ctx := r.Context( |4:   ctx := r.Context |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 21
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Context returns the request's context. To change the context, use Clone or WithContext.\n\nThe returned context is always non-nil; it defaults to the background context.\n\nFor outgoing client requests, the context controls cancellation.\n\nFor incoming server requests, the context is canceled when the client's connection closes, the request is canceled (with HTTP/2), or when the ServeHTTP method returns."
      },
      label = "Context() context.Context"
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx := r.Context(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: no sig
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  ctx := r.Context( |3:    |4:   ctx := r.Context( |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:   fmt.Printf( |3:   fmt.Printf( |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 13,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  fmt.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  fmt.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "Hello, HTTP!\n") |4: { 24, 13 }
 |5: 22 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "               format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: (" |3:   fmt.Printf(" |4:   fmt.Printf( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: "% |3:   fmt.Printf("% |4:   fmt.Printf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: %s |3:   fmt.Printf("%s |4:   fmt.Printf("% |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: s: |3:   fmt.Printf("%s: |4:   fmt.Printf("%s |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: :  |3:   fmt.Printf("%s:  |4:   fmt.Printf("%s: |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:  g |3:   fmt.Printf("%s: g |4:   fmt.Printf("%s:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: go
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: go |3:   fmt.Printf("%s: go |4:   fmt.Printf("%s: g |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ot |3:   fmt.Printf("%s: got |4:   fmt.Printf("%s: go |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: t  |3:   fmt.Printf("%s: got  |4:   fmt.Printf("%s: got |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:  / |3:   fmt.Printf("%s: got / |4:   fmt.Printf("%s: got  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: /h |3:   fmt.Printf("%s: got /h |4:   fmt.Printf("%s: got / |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /he
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: he |3:   fmt.Printf("%s: got /he |4:   fmt.Printf("%s: got /h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: el |3:   fmt.Printf("%s: got /hel |4:   fmt.Printf("%s: got /he |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ll |3:   fmt.Printf("%s: got /hell |4:   fmt.Printf("%s: got /hel |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: lo |3:   fmt.Printf("%s: got /hello |4:   fmt.Printf("%s: got /hell |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: o  |3:   fmt.Printf("%s: got /hello  |4:   fmt.Printf("%s: got /hello |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:  r |3:   fmt.Printf("%s: got /hello r |4:   fmt.Printf("%s: got /hello  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: re |3:   fmt.Printf("%s: got /hello re |4:   fmt.Printf("%s: got /hello r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello requ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: equ |3:   fmt.Printf("%s: got /hello requ |4:   fmt.Printf("%s: got /hello re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello reque
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: ue |3:   fmt.Printf("%s: got /hello reque |4:   fmt.Printf("%s: got /hello requ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello reques
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: es |3:   fmt.Printf("%s: got /hello reques |4:   fmt.Printf("%s: got /hello reque |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: st |3:   fmt.Printf("%s: got /hello request |4:   fmt.Printf("%s: got /hello reques |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: t\ |3:   fmt.Printf("%s: got /hello request\ |4:   fmt.Printf("%s: got /hello request |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: \n |3:   fmt.Printf("%s: got /hello request\n |4:   fmt.Printf("%s: got /hello request\ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\n",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: n", |3:   fmt.Printf("%s: got /hello request\n", |4:   fmt.Printf("%s: got /hello request\n |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "Hello, HTTP!\n") |4: { 24, 40 }
 |5: 22 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                                          a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\n", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: ,  |3:   fmt.Printf("%s: got /hello request\n",  |4:   fmt.Printf("%s: got /hello request\n", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "Hello, HTTP!\n") |4: { 24, 41 }
 |5: 22 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                                           a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\n", c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2:  c |3:   fmt.Printf("%s: got /hello request\n", c |4:   fmt.Printf("%s: got /hello request\n",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "Hello, HTTP!\n") |4: { 24, 42 }
 |5: 22 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                                            a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\n", ct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: ct |3:   fmt.Printf("%s: got /hello request\n", ct |4:   fmt.Printf("%s: got /hello request\n", c |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "Hello, HTTP!\n") |4: { 24, 43 }
 |5: 22 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                                             a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\n", ctx
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: tx |3:   fmt.Printf("%s: got /hello request\n", ctx |4:   fmt.Printf("%s: got /hello request\n", ct |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "Hello, HTTP!\n") |4: { 24, 44 }
 |5: 22 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                                              a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\n", ctx.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: x. |3:   fmt.Printf("%s: got /hello request\n", ctx. |4:   fmt.Printf("%s: got /hello request\n", ctx |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "Hello, HTTP!\n") |4: { 24, 45 }
 |5: 22 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                                               a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\n", ctx.V
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: .V |3:   fmt.Printf("%s: got /hello request\n", ctx.V |4:   fmt.Printf("%s: got /hello request\n", ctx. |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "Hello, HTTP!\n") |4: { 24, 46 }
 |5: 22 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                                                a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\n", ctx.Va
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: Va |3:   fmt.Printf("%s: got /hello request\n", ctx.Va |4:   fmt.Printf("%s: got /hello request\n", ctx.V |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "Hello, HTTP!\n") |4: { 24, 47 }
 |5: 22 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                                                 a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\n", ctx.Value(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: alue( |3:   fmt.Printf("%s: got /hello request\n", ctx.Value( |4:   fmt.Printf("%s: got /hello request\n", ctx.Va |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 51,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: Value(key any) any |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "Hello, HTTP!\n") |4: { 24, 51 }
 |5: 22 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                                                     key any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\n", ctx.Value(k
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: (k |3:   fmt.Printf("%s: got /hello request\n", ctx.Value(k |4:   fmt.Printf("%s: got /hello request\n", ctx.Value( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 51,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: Value(key any) any |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "Hello, HTTP!\n") |4: { 24, 52 }
 |5: 22 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                                                      key any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\n", ctx.Value(ke
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: ke |3:   fmt.Printf("%s: got /hello request\n", ctx.Value(ke |4:   fmt.Printf("%s: got /hello request\n", ctx.Value(k |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 51,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: Value(key any) any |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "Hello, HTTP!\n") |4: { 24, 53 }
 |5: 22 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                                                       key any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\n", ctx.Value(key
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: ey |3:   fmt.Printf("%s: got /hello request\n", ctx.Value(key |4:   fmt.Printf("%s: got /hello request\n", ctx.Value(ke |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 51,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: Value(key any) any |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "Hello, HTTP!\n") |4: { 24, 54 }
 |5: 22 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                                                        key any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\n", ctx.Value(keyServerAddr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: yServerAddr |3:   fmt.Printf("%s: got /hello request\n", ctx.Value(keyServerAddr |4:   fmt.Printf("%s: got /hello request\n", ctx.Value(key |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 51,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n", ctx.Value(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: Value(key any) any |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:  |3:   io.WriteString(w, "Hello, HTTP!\n") |4: { 24, 64 }
 |5: 22 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                                                                  key any", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Printf("%s: got /hello request\n", ctx.Value(keyServerAdd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2:   fmt.Printf("%s: got /hello request\n", ctx.Value(keyServerAdd |3:   fmt.Printf("%s: got /hello request\n", ctx.Value(keyServerAdd |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 51,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n", ctx.Value(',
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Value returns the value associated with this context for key, or nil if no value is associated with key. Successive calls to Value with the same key returns the same result.\n\nUse context values only for request-scoped data that transits processes and API boundaries, not for passing optional parameters to functions.\n\nA key identifies a specific value in a Context. Functions that wish to store values in Context typically allocate a key in a global variable then use that key as the argument to context.WithValue and Context.Value. A key can be any type that supports equality; packages should define keys as an unexported type to avoid collisions.\n\nPackages that define a Context key should provide type-safe accessors for the values stored using that key:\n\n\t// Package user defines a User type that's stored in Contexts.\n\tpackage user\n\n\timport \"context\"\n\n\t// User is the type of value stored in the Contexts.\n\ttype User struct {...}\n\n\t// key is an unexported type for keys defined in this package.\n\t// This prevents collisions with keys defined in other packages.\n\ttype key int\n\n\t// userKey is the key for user.User values in Contexts. It is\n\t// unexported; clients use user.NewContext and user.FromContext\n\t// instead of using this key directly.\n\tvar userKey key\n\n\t// NewContext returns a new Context that carries value u.\n\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t\treturn context.WithValue(ctx, userKey, u)\n\t}\n\n\t// FromContext returns the User value stored in ctx, if any.\n\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t\tu, ok := ctx.Value(userKey).(*User)\n\t\treturn u, ok\n\t}"
      },
      label = "Value(key any) any",
      parameters = { {
          label = "key any"
        } }
    } }
}
 |3: {
  border = "rounded",
  line_to_cursor = '  fmt.Printf("%s: got /hello request\\n", ctx.Value(',
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: Value(key any) any |3: {
  label = "key any"
}

󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  c |3:   c |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ct |3:   ct |4:   c |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: tx |3:   ctx |4:   ct |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: x, |3:   ctx, |4:   ctx |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ,  |3:   ctx,  |4:   ctx, |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  c |3:   ctx, c |4:   ctx,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, ca
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ca |3:   ctx, ca |4:   ctx, c |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, can
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: an |3:   ctx, can |4:   ctx, ca |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, canr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: nr |3:   ctx, canr |4:   ctx, can |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, canre
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: re |3:   ctx, canre |4:   ctx, canr |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, canr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: re |3:   ctx, canr |4:   ctx, canre |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, canrc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: rc |3:   ctx, canrc |4:   ctx, canr |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, canr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: rc |3:   ctx, canr |4:   ctx, canrc |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, can
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: nr |3:   ctx, can |4:   ctx, canr |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, canc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: nc |3:   ctx, canc |4:   ctx, can |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cance
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ce |3:   ctx, cance |4:   ctx, canc |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: el |3:   ctx, cancel |4:   ctx, cance |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelC
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: lC |3:   ctx, cancelC |4:   ctx, cancel |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: Ct |3:   ctx, cancelCt |4:   ctx, cancelC |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: tx |3:   ctx, cancelCtx |4:   ctx, cancelCt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: x  |3:   ctx, cancelCtx  |4:   ctx, cancelCtx |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  : |3:   ctx, cancelCtx : |4:   ctx, cancelCtx  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: := |3:   ctx, cancelCtx := |4:   ctx, cancelCtx : |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: =  |3:   ctx, cancelCtx :=  |4:   ctx, cancelCtx := |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  c |3:   ctx, cancelCtx := c |4:   ctx, cancelCtx :=  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := co
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: co |3:   ctx, cancelCtx := co |4:   ctx, cancelCtx := c |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := con
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: on |3:   ctx, cancelCtx := con |4:   ctx, cancelCtx := co |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := cont
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: nt |3:   ctx, cancelCtx := cont |4:   ctx, cancelCtx := con |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := conte
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: te |3:   ctx, cancelCtx := conte |4:   ctx, cancelCtx := cont |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := contex
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ex |3:   ctx, cancelCtx := contex |4:   ctx, cancelCtx := conte |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: xt |3:   ctx, cancelCtx := context |4:   ctx, cancelCtx := contex |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: t. |3:   ctx, cancelCtx := context. |4:   ctx, cancelCtx := context |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.With
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: .With |3:   ctx, cancelCtx := context.With |4:   ctx, cancelCtx := context. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithC
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: hC |3:   ctx, cancelCtx := context.WithC |4:   ctx, cancelCtx := context.With |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCa
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: Ca |3:   ctx, cancelCtx := context.WithCa |4:   ctx, cancelCtx := context.WithC |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCan
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: an |3:   ctx, cancelCtx := context.WithCan |4:   ctx, cancelCtx := context.WithCa |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCanc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: nc |3:   ctx, cancelCtx := context.WithCanc |4:   ctx, cancelCtx := context.WithCan |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCance
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ce |3:   ctx, cancelCtx := context.WithCance |4:   ctx, cancelCtx := context.WithCanc |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: el |3:   ctx, cancelCtx := context.WithCancel |4:   ctx, cancelCtx := context.WithCance |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 39
󰘫  |1: delta |2: l( |3:   ctx, cancelCtx := context.WithCancel( |4:   ctx, cancelCtx := context.WithCancel |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 39,
      line = 32
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc) |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 33, 39 }
 |5: 31 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 32 |3: 31 |4: { "                                         parent context.Context", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 39
󰘫  |1: delta |2: (c |3:   ctx, cancelCtx := context.WithCancel(c |4:   ctx, cancelCtx := context.WithCancel( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 39,
      line = 32
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc) |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 33, 40 }
 |5: 31 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 32 |3: 31 |4: { "                                          parent context.Context", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(co
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 39
󰘫  |1: delta |2: co |3:   ctx, cancelCtx := context.WithCancel(co |4:   ctx, cancelCtx := context.WithCancel(c |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 39,
      line = 32
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc) |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 33, 41 }
 |5: 31 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 32 |3: 31 |4: { "                                           parent context.Context", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(con
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 39
󰘫  |1: delta |2: on |3:   ctx, cancelCtx := context.WithCancel(con |4:   ctx, cancelCtx := context.WithCancel(co |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(cont
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 39
󰘫  |1: delta |2: nt |3:   ctx, cancelCtx := context.WithCancel(cont |4:   ctx, cancelCtx := context.WithCancel(con |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 39,
      line = 32
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc) |3: {
  label = "parent context.Context"
}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 39,
      line = 32
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc) |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 33, 43 }
 |5: 31 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 32 |3: 31 |4: { "                                             parent context.Context", "Comment" }

󰘫  |1: virtual text only : |2:  |3: } |4: { 33, 43 }
 |5: 31 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 32 |3: 31 |4: { "                                             parent context.Context", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(conte
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 39
󰘫  |1: delta |2: te |3:   ctx, cancelCtx := context.WithCancel(conte |4:   ctx, cancelCtx := context.WithCancel(cont |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 39,
      line = 32
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc) |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 33, 44 }
 |5: 31 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 32 |3: 31 |4: { "                                              parent context.Context", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(contex
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 39
󰘫  |1: delta |2: ex |3:   ctx, cancelCtx := context.WithCancel(contex |4:   ctx, cancelCtx := context.WithCancel(conte |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 39,
      line = 32
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc) |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 33, 45 }
 |5: 31 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 32 |3: 31 |4: { "                                               parent context.Context", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(context
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 39
󰘫  |1: delta |2: xt |3:   ctx, cancelCtx := context.WithCancel(context |4:   ctx, cancelCtx := context.WithCancel(contex |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 39,
      line = 32
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc) |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 33, 46 }
 |5: 31 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 32 |3: 31 |4: { "                                                parent context.Context", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(context.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 39
󰘫  |1: delta |2: t. |3:   ctx, cancelCtx := context.WithCancel(context. |4:   ctx, cancelCtx := context.WithCancel(context |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 39,
      line = 32
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc) |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 33, 47 }
 |5: 31 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 32 |3: 31 |4: { "                                                 parent context.Context", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(context.B
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 39
󰘫  |1: delta |2: .B |3:   ctx, cancelCtx := context.WithCancel(context.B |4:   ctx, cancelCtx := context.WithCancel(context. |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 39,
      line = 32
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc) |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 33, 48 }
 |5: 31 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 32 |3: 31 |4: { "                                                  parent context.Context", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(context.Ba
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 39
󰘫  |1: delta |2: Ba |3:   ctx, cancelCtx := context.WithCancel(context.Ba |4:   ctx, cancelCtx := context.WithCancel(context.B |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 39,
      line = 32
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete."
      },
      label = "WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)",
      parameters = { {
          label = "parent context.Context"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  ctx, cancelCtx := context.WithCancel(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc) |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 33, 49 }
 |5: 31 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 32 |3: 31 |4: { "                                                   parent context.Context", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(context.Background()
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 59
󰘫  |1: delta |2: ackground() |3:   ctx, cancelCtx := context.WithCancel(context.Background() |4:   ctx, cancelCtx := context.WithCancel(context.Ba |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(context.Background())a
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 61
󰘫  |1: delta |2: ))a |3:   ctx, cancelCtx := context.WithCancel(context.Background())a |4:   ctx, cancelCtx := context.WithCancel(context.Background() |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(context.Background())
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 60
󰘫  |1: delta |2: )a |3:   ctx, cancelCtx := context.WithCancel(context.Background()) |4:   ctx, cancelCtx := context.WithCancel(context.Background())a |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(context.Background())o
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 61
󰘫  |1: delta |2: )o |3:   ctx, cancelCtx := context.WithCancel(context.Background())o |4:   ctx, cancelCtx := context.WithCancel(context.Background()) |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ctx, cancelCtx := context.WithCancel(context.Background())
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 60
󰘫  |1: delta |2: )o |3:   ctx, cancelCtx := context.WithCancel(context.Background()) |4:   ctx, cancelCtx := context.WithCancel(context.Background())o |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  s |3:   s |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   se
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: se |3:   se |4:   s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ser
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: er |3:   ser |4:   se |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serv
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: rv |3:   serv |4:   ser |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serve
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ve |3:   serve |4:   serv |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   server
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: er |3:   server |4:   serve |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverO
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: rO |3:   serverO |4:   server |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOh
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: Oh |3:   serverOh |4:   serverO |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverO
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: Oh |3:   serverO |4:   serverOh |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOn
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: On |3:   serverOn |4:   serverO |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ne |3:   serverOne |4:   serverOn |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: e  |3:   serverOne  |4:   serverOne |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2:  : |3:   serverOne : |4:   serverOne  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: := |3:   serverOne := |4:   serverOne : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: =  |3:   serverOne :=  |4:   serverOne := |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2:  & |3:   serverOne := & |4:   serverOne :=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: &h |3:   serverOne := &h |4:   serverOne := & |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: ht |3:   serverOne := &ht |4:   serverOne := &h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: tt |3:   serverOne := &htt |4:   serverOne := &ht |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: tp |3:   serverOne := &http |4:   serverOne := &htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: p. |3:   serverOne := &http. |4:   serverOne := &http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &http.S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: .S |3:   serverOne := &http.S |4:   serverOne := &http. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &http.Se
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: Se |3:   serverOne := &http.Se |4:   serverOne := &http.S |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &http.Ser
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: er |3:   serverOne := &http.Ser |4:   serverOne := &http.Se |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &http.Serv
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: rv |3:   serverOne := &http.Serv |4:   serverOne := &http.Ser |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &http.Serve
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: ve |3:   serverOne := &http.Serve |4:   serverOne := &http.Serv |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &http.Server
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: er |3:   serverOne := &http.Server |4:   serverOne := &http.Serve |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &http.Server(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: r( |3:   serverOne := &http.Server( |4:   serverOne := &http.Server |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: erverOne := &http.Server( |3:      |4:   serverOne := &http.Server( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     A
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  A |3:     A |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Ad
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: Ad |3:     Ad |4:     A |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Ads
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ds |3:     Ads |4:     Ad |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Adst
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: st |3:     Adst |4:     Ads |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Ads
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: st |3:     Ads |4:     Adst |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Ad
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ds |3:     Ad |4:     Ads |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Add
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: dd |3:     Add |4:     Ad |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Addr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: dr |3:     Addr |4:     Add |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Addr:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: r: |3:     Addr: |4:     Addr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Addr: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: :  |3:     Addr:  |4:     Addr: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Addr: "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2:  " |3:     Addr: " |4:     Addr:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Addr: ":
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:  " |3:   Addr: ": |4:     Addr: " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Addr: ":3
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: :3 |3:   Addr: ":3 |4:   Addr: ": |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Addr: ":33
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: 33 |3:   Addr: ":33 |4:   Addr: ":3 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Addr: ":333
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: 33 |3:   Addr: ":333 |4:   Addr: ":33 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Addr: ":3333
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: 33 |3:   Addr: ":3333 |4:   Addr: ":333 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Addr: ":3333",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: 3", |3:   Addr: ":3333", |4:   Addr: ":3333 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  Addr: ":3333", |3:    |4:   Addr: ":3333", |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  H |3:   H |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Hand
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: Hand |3:   Hand |4:   H |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Handl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: dl |3:   Handl |4:   Hand |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Handle
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: le |3:   Handle |4:   Handl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Handler
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: er |3:   Handler |4:   Handle |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Handler:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: r: |3:   Handler: |4:   Handler |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Handler: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: :  |3:   Handler:  |4:   Handler: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Handler: m
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2:  m |3:   Handler: m |4:   Handler:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Handler: mu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: mu |3:   Handler: mu |4:   Handler: m |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Handler: mux
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: ux |3:   Handler: mux |4:   Handler: mu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Handler: mux,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: x, |3:   Handler: mux, |4:   Handler: mux |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  Handler: mux, |3:    |4:   Handler: mux, |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   B
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  B |3:   B |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Ba
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: Ba |3:   Ba |4:   B |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Bas
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: as |3:   Bas |4:   Ba |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Base
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: se |3:   Base |4:   Bas |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseC
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: eC |3:   BaseC |4:   Base |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseCo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: Co |3:   BaseCo |4:   BaseC |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseCon
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: on |3:   BaseCon |4:   BaseCo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseCont
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: nt |3:   BaseCont |4:   BaseCon |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseConte
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: te |3:   BaseConte |4:   BaseCont |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContex
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ex |3:   BaseContex |4:   BaseConte |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: xt |3:   BaseContext |4:   BaseContex |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: t  |3:   BaseContext  |4:   BaseContext |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: t  |3:   BaseContext |4:   BaseContext  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: t: |3:   BaseContext: |4:   BaseContext |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: :  |3:   BaseContext:  |4:   BaseContext: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2:  f |3:   BaseContext: f |4:   BaseContext:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: fu |3:   BaseContext: fu |4:   BaseContext: f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: un |3:   BaseContext: fun |4:   BaseContext: fu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: nc |3:   BaseContext: func |4:   BaseContext: fun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: c( |3:   BaseContext: func( |4:   BaseContext: func |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: (1 |3:   BaseContext: func(1 |4:   BaseContext: func( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: 1  |3:   BaseContext: func(1  |4:   BaseContext: func(1 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2:  n |3:   BaseContext: func(1 n |4:   BaseContext: func(1  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 ne
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: ne |3:   BaseContext: func(1 ne |4:   BaseContext: func(1 n |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: et |3:   BaseContext: func(1 net |4:   BaseContext: func(1 ne |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: t. |3:   BaseContext: func(1 net. |4:   BaseContext: func(1 net |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.N
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: .N |3:   BaseContext: func(1 net.N |4:   BaseContext: func(1 net. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: .N |3:   BaseContext: func(1 net. |4:   BaseContext: func(1 net.N |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.L
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: .L |3:   BaseContext: func(1 net.L |4:   BaseContext: func(1 net. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Li
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: Li |3:   BaseContext: func(1 net.Li |4:   BaseContext: func(1 net.L |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Lis
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: is |3:   BaseContext: func(1 net.Lis |4:   BaseContext: func(1 net.Li |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.List
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: st |3:   BaseContext: func(1 net.List |4:   BaseContext: func(1 net.Lis |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Liste
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: te |3:   BaseContext: func(1 net.Liste |4:   BaseContext: func(1 net.List |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listen
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: en |3:   BaseContext: func(1 net.Listen |4:   BaseContext: func(1 net.Liste |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listene
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: ne |3:   BaseContext: func(1 net.Listene |4:   BaseContext: func(1 net.Listen |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: er |3:   BaseContext: func(1 net.Listener |4:   BaseContext: func(1 net.Listene |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 36
󰘫  |1: delta |2: r)  |3:   BaseContext: func(1 net.Listener)  |4:   BaseContext: func(1 net.Listener |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 37
󰘫  |1: delta |2:  c |3:   BaseContext: func(1 net.Listener) c |4:   BaseContext: func(1 net.Listener)  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) co
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 38
󰘫  |1: delta |2: co |3:   BaseContext: func(1 net.Listener) co |4:   BaseContext: func(1 net.Listener) c |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) con
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 39
󰘫  |1: delta |2: on |3:   BaseContext: func(1 net.Listener) con |4:   BaseContext: func(1 net.Listener) co |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) cont
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 40
󰘫  |1: delta |2: nt |3:   BaseContext: func(1 net.Listener) cont |4:   BaseContext: func(1 net.Listener) con |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) conte
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 41
󰘫  |1: delta |2: te |3:   BaseContext: func(1 net.Listener) conte |4:   BaseContext: func(1 net.Listener) cont |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) contex
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 42
󰘫  |1: delta |2: ex |3:   BaseContext: func(1 net.Listener) contex |4:   BaseContext: func(1 net.Listener) conte |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) context
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 43
󰘫  |1: delta |2: xt |3:   BaseContext: func(1 net.Listener) context |4:   BaseContext: func(1 net.Listener) contex |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) context.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 44
󰘫  |1: delta |2: t. |3:   BaseContext: func(1 net.Listener) context. |4:   BaseContext: func(1 net.Listener) context |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) context.c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 45
󰘫  |1: delta |2: .c |3:   BaseContext: func(1 net.Listener) context.c |4:   BaseContext: func(1 net.Listener) context. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) context.co
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 46
󰘫  |1: delta |2: co |3:   BaseContext: func(1 net.Listener) context.co |4:   BaseContext: func(1 net.Listener) context.c |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) context.c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 45
󰘫  |1: delta |2: co |3:   BaseContext: func(1 net.Listener) context.c |4:   BaseContext: func(1 net.Listener) context.co |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) context.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 44
󰘫  |1: delta |2: .c |3:   BaseContext: func(1 net.Listener) context. |4:   BaseContext: func(1 net.Listener) context.c |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) context.C
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 45
󰘫  |1: delta |2: .C |3:   BaseContext: func(1 net.Listener) context.C |4:   BaseContext: func(1 net.Listener) context. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) context.Co
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 46
󰘫  |1: delta |2: Co |3:   BaseContext: func(1 net.Listener) context.Co |4:   BaseContext: func(1 net.Listener) context.C |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) context.Con
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 47
󰘫  |1: delta |2: on |3:   BaseContext: func(1 net.Listener) context.Con |4:   BaseContext: func(1 net.Listener) context.Co |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) context.Cont
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 48
󰘫  |1: delta |2: nt |3:   BaseContext: func(1 net.Listener) context.Cont |4:   BaseContext: func(1 net.Listener) context.Con |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) context.Conte
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 49
󰘫  |1: delta |2: te |3:   BaseContext: func(1 net.Listener) context.Conte |4:   BaseContext: func(1 net.Listener) context.Cont |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) context.Contex
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 50
󰘫  |1: delta |2: ex |3:   BaseContext: func(1 net.Listener) context.Contex |4:   BaseContext: func(1 net.Listener) context.Conte |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) context.Context
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 51
󰘫  |1: delta |2: xt |3:   BaseContext: func(1 net.Listener) context.Context |4:   BaseContext: func(1 net.Listener) context.Contex |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) context.Context 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 52
󰘫  |1: delta |2: t  |3:   BaseContext: func(1 net.Listener) context.Context  |4:   BaseContext: func(1 net.Listener) context.Context |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1 net.Listener) context.Context {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 53
󰘫  |1: delta |2:  { |3:   BaseContext: func(1 net.Listener) context.Context { |4:   BaseContext: func(1 net.Listener) context.Context  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: aseContext: func(1 net.Listener) context.Context { |3:      |4:   BaseContext: func(1 net.Listener) context.Context { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  c |3:     c |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ct |3:     ct |4:     c |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: tx |3:     ctx |4:     ct |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: x  |3:     ctx  |4:     ctx |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx =
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2:  = |3:     ctx = |4:     ctx  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: =  |3:     ctx =  |4:     ctx = |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2:  c |3:     ctx = c |4:     ctx =  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = co
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: co |3:     ctx = co |4:     ctx = c |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = con
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: on |3:     ctx = con |4:     ctx = co |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = cont
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: nt |3:     ctx = cont |4:     ctx = con |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = conte
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: te |3:     ctx = conte |4:     ctx = cont |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = contex
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: ex |3:     ctx = contex |4:     ctx = conte |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: xt |3:     ctx = context |4:     ctx = contex |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: t. |3:     ctx = context. |4:     ctx = context |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.With
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: .With |3:     ctx = context.With |4:     ctx = context. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithV
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: hV |3:     ctx = context.WithV |4:     ctx = context.With |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithVa
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: Va |3:     ctx = context.WithVa |4:     ctx = context.WithV |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithVal
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: al |3:     ctx = context.WithVal |4:     ctx = context.WithVa |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: lu |3:     ctx = context.WithValu |4:     ctx = context.WithVal |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: ue |3:     ctx = context.WithValue |4:     ctx = context.WithValu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: e( |3:     ctx = context.WithValue( |4:     ctx = context.WithValue |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 28,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 28 }
 |5: 38 |6:   }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 38 |4: { "                           parent context.Context", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: (c |3:     ctx = context.WithValue(c |4:     ctx = context.WithValue( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 28,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 29 }
 |5: 37
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 37 |4: { "  parent context.Context", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: ct |3:     ctx = context.WithValue(ct |4:     ctx = context.WithValue(c |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 28,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 30 }
 |5: 37
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 37 |4: { "  parent context.Context", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: tx |3:     ctx = context.WithValue(ctx |4:     ctx = context.WithValue(ct |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 28,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 31 }
 |5: 37
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 37 |4: { "  parent context.Context", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 32
󰘫  |1: delta |2: x, |3:     ctx = context.WithValue(ctx, |4:     ctx = context.WithValue(ctx |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 32,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 32 }
 |5: 38 |6:   }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 38 |4: { "                               key any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 32
󰘫  |1: delta |2: ,  |3:     ctx = context.WithValue(ctx,  |4:     ctx = context.WithValue(ctx, |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 32,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 33 }
 |5: 38 |6:   }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 38 |4: { "                                key any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, k
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 32
󰘫  |1: delta |2:  k |3:     ctx = context.WithValue(ctx, k |4:     ctx = context.WithValue(ctx,  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 32,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 34 }
 |5: 37
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 37 |4: { "  key any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, ke
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 32
󰘫  |1: delta |2: ke |3:     ctx = context.WithValue(ctx, ke |4:     ctx = context.WithValue(ctx, k |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 32,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 35 }
 |5: 37
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 37 |4: { "  key any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 32
󰘫  |1: delta |2: eyServerAddr |3:     ctx = context.WithValue(ctx, keyServerAddr |4:     ctx = context.WithValue(ctx, ke |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 32,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "key any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "key any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 46 }
 |5: 38 |6:   }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 38 |4: { "                                             key any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 47
󰘫  |1: delta |2: r, |3:     ctx = context.WithValue(ctx, keyServerAddr, |4:     ctx = context.WithValue(ctx, keyServerAddr |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 47,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx, keyServerAddr,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "val any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "val any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 47 }
 |5: 38 |6:   }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 38 |4: { "                                              val any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 47
󰘫  |1: delta |2: ,  |3:     ctx = context.WithValue(ctx, keyServerAddr,  |4:     ctx = context.WithValue(ctx, keyServerAddr, |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 47,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx, keyServerAddr,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "val any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "val any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 48 }
 |5: 38 |6:   }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 38 |4: { "                                               val any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 1
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 47
󰘫  |1: delta |2:  1 |3:     ctx = context.WithValue(ctx, keyServerAddr, 1 |4:     ctx = context.WithValue(ctx, keyServerAddr,  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 47,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx, keyServerAddr,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "val any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "val any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 49 }
 |5: 38 |6:   }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 38 |4: { "                                                val any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 1.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 47
󰘫  |1: delta |2: 1. |3:     ctx = context.WithValue(ctx, keyServerAddr, 1. |4:     ctx = context.WithValue(ctx, keyServerAddr, 1 |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 47,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx, keyServerAddr,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "val any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "val any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 50 }
 |5: 38 |6:   }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 38 |4: { "                                                 val any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 1.A
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 47
󰘫  |1: delta |2: .A |3:     ctx = context.WithValue(ctx, keyServerAddr, 1.A |4:     ctx = context.WithValue(ctx, keyServerAddr, 1. |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 47,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx, keyServerAddr,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "val any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "val any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 51 }
 |5: 37
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 37 |4: { "  val any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 1.Ad
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 47
󰘫  |1: delta |2: Ad |3:     ctx = context.WithValue(ctx, keyServerAddr, 1.Ad |4:     ctx = context.WithValue(ctx, keyServerAddr, 1.A |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 47,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx, keyServerAddr,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "val any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "val any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 52 }
 |5: 37
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 37 |4: { "  val any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 1.Add
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 47
󰘫  |1: delta |2: dd |3:     ctx = context.WithValue(ctx, keyServerAddr, 1.Add |4:     ctx = context.WithValue(ctx, keyServerAddr, 1.Ad |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 47,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx, keyServerAddr,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "val any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "val any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 53 }
 |5: 37
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 37 |4: { "  val any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 47
󰘫  |1: delta |2: dr |3:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr |4:     ctx = context.WithValue(ctx, keyServerAddr, 1.Add |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 47,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx, keyServerAddr,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "val any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "val any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(1 net.Listener) context.Context { |3:   } |4: { 38, 54 }
 |5: 36 |6:   BaseContext: func(1 net.Listener) context.Context {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 36 |4: { "  val any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 55
󰘫  |1: delta |2: r( |3:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr( |4:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 55,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 3,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx, keyServerAddr, 1.Addr(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 3 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara:
󰘫  |1: no next param
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 57
󰘫  |1: delta |2: (). |3:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr(). |4:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 58
󰘫  |1: delta |2: .S |3:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().S |4:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr(). |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().St
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 59
󰘫  |1: delta |2: St |3:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().St |4:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().S |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().Str
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 60
󰘫  |1: delta |2: tr |3:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().Str |4:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().St |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().String
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 63
󰘫  |1: delta |2: ring |3:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().String |4:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().Str |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().String(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 64
󰘫  |1: delta |2: g( |3:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().String( |4:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().String |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 64,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 3,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().String(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 3 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara:
󰘫  |1: no next param
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().String( |3:      |4:     ctx = context.WithValue(ctx, keyServerAddr, 1.Addr().String( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  r |3:     r |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: re |3:     re |4:     r |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ret
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: et |3:     ret |4:     re |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     retu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: tu |3:     retu |4:     ret |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     retur
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ur |3:     retur |4:     retu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     return
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: rn |3:     return |4:     retur |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     return 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: n  |3:     return  |4:     return |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     return c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2:  c |3:     return c |4:     return  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     return ct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: ct |3:     return ct |4:     return c |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     return ctx
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: tx |3:     return ctx |4:     return ct |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   }
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:   } |3:   } |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   },
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: }, |3:   }, |4:   } |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 4,
      line = 39
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 4,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  },",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 4 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:     return ctx |3:     ) |4: { 40, 4 }
 |5: 40 |6:     )
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 39 |3: 40 |4: { "  parent context.Context", "Comment" }

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   },
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2:   }, |3:   }, |4:   }, |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 4,
      line = 39
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 4,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "  },",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 4 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:     return ctx |3:     ) |4: { 40, 4 }
 |5: 40 |6:     )
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 39 |3: 40 |4: { "  parent context.Context", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 4,
      line = 40
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 4,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "    ",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 4 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "parent context.Context"
}

󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	}
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: 	 |3: 	 |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 1,
      line = 48
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 6,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "\t",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 6 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "parent context.Context"
}

󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &http.Server(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2:   serverOne := &http.Server( |3:   serverOne := &http.Server( |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &http.Server
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: r( |3:   serverOne := &http.Server |4:   serverOne := &http.Server( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &http.Server{
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: r{ |3:   serverOne := &http.Server{ |4:   serverOne := &http.Server |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   serverOne := &http.Server{
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     )
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:     ) |3:     ) |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  ) |3:      |4:     ) |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   }
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:    |3:   } |4:      |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: 	 |3: 	 |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 1,
      line = 48
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 6,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "\t",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 6 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "parent context.Context"
}

󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  g |3:   g |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   go
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: go |3:   go |4:   g |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   go 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: o  |3:   go  |4:   go |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   go f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  f |3:   go f |4:   go  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   go fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: fu |3:   go fu |4:   go f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   go fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: un |3:   go fun |4:   go fu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   go func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: nc |3:   go func |4:   go fun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   go func(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 10
󰘫  |1: delta |2: c( |3:   go func( |4:   go func |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   go func() 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ()  |3:   go func()  |4:   go func( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   go func() {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2:  { |3:   go func() { |4:   go func()  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: o func() { |3:      |4:   go func() { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     e
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  e |3:     e |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: er |3:     er |4:     e |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: rr |3:     err |4:     er |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: r  |3:     err  |4:     err |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2:  : |3:     err : |4:     err  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: := |3:     err := |4:     err : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: =  |3:     err :=  |4:     err := |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2:  s |3:     err := s |4:     err :=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := se
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: se |3:     err := se |4:     err := s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := ser
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: er |3:     err := ser |4:     err := se |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serv
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: rv |3:     err := serv |4:     err := ser |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serve
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: ve |3:     err := serve |4:     err := serv |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := server
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: er |3:     err := server |4:     err := serve |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverO
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: rO |3:     err := serverO |4:     err := server |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOh
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: Oh |3:     err := serverOh |4:     err := serverO |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverO
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: Oh |3:     err := serverO |4:     err := serverOh |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOn
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: On |3:     err := serverOn |4:     err := serverO |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: ne |3:     err := serverOne |4:     err := serverOn |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: e. |3:     err := serverOne. |4:     err := serverOne |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.L
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: .L |3:     err := serverOne.L |4:     err := serverOne. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.Li
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: Li |3:     err := serverOne.Li |4:     err := serverOne.L |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.Lis
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: is |3:     err := serverOne.Lis |4:     err := serverOne.Li |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.List
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: st |3:     err := serverOne.List |4:     err := serverOne.Lis |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.Liste
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: te |3:     err := serverOne.Liste |4:     err := serverOne.List |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.Listen
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: en |3:     err := serverOne.Listen |4:     err := serverOne.Liste |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.Listenand
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2: nand |3:     err := serverOne.Listenand |4:     err := serverOne.Listen |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.Listenan
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: nd |3:     err := serverOne.Listenan |4:     err := serverOne.Listenand |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.Listena
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: an |3:     err := serverOne.Listena |4:     err := serverOne.Listenan |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.Listen
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: na |3:     err := serverOne.Listen |4:     err := serverOne.Listena |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.ListenAnd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2: nAnd |3:     err := serverOne.ListenAnd |4:     err := serverOne.Listen |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.ListenAndS
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2: dS |3:     err := serverOne.ListenAndS |4:     err := serverOne.ListenAnd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.ListenAndSe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: Se |3:     err := serverOne.ListenAndSe |4:     err := serverOne.ListenAndS |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.ListenAndSer
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 33
󰘫  |1: delta |2: er |3:     err := serverOne.ListenAndSer |4:     err := serverOne.ListenAndSe |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.ListenAndServ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: rv |3:     err := serverOne.ListenAndServ |4:     err := serverOne.ListenAndSer |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.ListenAndServe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 35
󰘫  |1: delta |2: ve |3:     err := serverOne.ListenAndServe |4:     err := serverOne.ListenAndServ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     err := serverOne.ListenAndServe(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 36
󰘫  |1: delta |2: e( |3:     err := serverOne.ListenAndServe( |4:     err := serverOne.ListenAndServe |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  err := serverOne.ListenAndServe( |3:      |4:     err := serverOne.ListenAndServe( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  i |3:     i |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: if |3:     if |4:     i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: f  |3:     if  |4:     if |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if e
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2:  e |3:     if e |4:     if  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: er |3:     if er |4:     if e |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: rr |3:     if err |4:     if er |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if erro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ro |3:     if erro |4:     if err |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if error
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: or |3:     if error |4:     if erro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: rs |3:     if errors |4:     if error |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: s. |3:     if errors. |4:     if errors |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.I
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: .I |3:     if errors.I |4:     if errors. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: Is |3:     if errors.Is |4:     if errors.I |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: s( |3:     if errors.Is( |4:     if errors.Is |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 17,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "err error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "err error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 17 }
 |5: 53 |6:   }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 53 |4: { "                err error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(e
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: (e |3:     if errors.Is(e |4:     if errors.Is( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 17,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "err error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "err error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 18 }
 |5: 52
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 52 |4: { "  err error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: er |3:     if errors.Is(er |4:     if errors.Is(e |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 17,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "err error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "err error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 19 }
 |5: 52
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 52 |4: { "  err error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: rr |3:     if errors.Is(err |4:     if errors.Is(er |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 17,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "err error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "err error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 20 }
 |5: 52
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 52 |4: { "  err error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 21
󰘫  |1: delta |2: r, |3:     if errors.Is(err, |4:     if errors.Is(err |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 21,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(err,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Is(err error, target error) bool
󰘫  |1: nextpara: |2: {
  label = "target error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "target error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 21 }
 |5: 53 |6:   }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 53 |4: { "                    target error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 21
󰘫  |1: delta |2: ,  |3:     if errors.Is(err,  |4:     if errors.Is(err, |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 21,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(err,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Is(err error, target error) bool
󰘫  |1: nextpara: |2: {
  label = "target error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "target error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 22 }
 |5: 53 |6:   }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 53 |4: { "                     target error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err, h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 21
󰘫  |1: delta |2:  h |3:     if errors.Is(err, h |4:     if errors.Is(err,  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 21,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(err,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Is(err error, target error) bool
󰘫  |1: nextpara: |2: {
  label = "target error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "target error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 23 }
 |5: 52
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 52 |4: { "  target error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err, ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 21
󰘫  |1: delta |2: ht |3:     if errors.Is(err, ht |4:     if errors.Is(err, h |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 21,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(err,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Is(err error, target error) bool
󰘫  |1: nextpara: |2: {
  label = "target error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "target error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 24 }
 |5: 52
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 52 |4: { "  target error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err, htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 21
󰘫  |1: delta |2: tt |3:     if errors.Is(err, htt |4:     if errors.Is(err, ht |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 21,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(err,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Is(err error, target error) bool
󰘫  |1: nextpara: |2: {
  label = "target error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "target error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 25 }
 |5: 52
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 52 |4: { "  target error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err, http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 21
󰘫  |1: delta |2: tp |3:     if errors.Is(err, http |4:     if errors.Is(err, htt |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 21,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(err,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Is(err error, target error) bool
󰘫  |1: nextpara: |2: {
  label = "target error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "target error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 26 }
 |5: 52
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 52 |4: { "  target error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err, http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 21
󰘫  |1: delta |2: p. |3:     if errors.Is(err, http. |4:     if errors.Is(err, http |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 21,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(err,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Is(err error, target error) bool
󰘫  |1: nextpara: |2: {
  label = "target error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "target error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 27 }
 |5: 52
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 52 |4: { "  target error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err, http.E
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 21
󰘫  |1: delta |2: .E |3:     if errors.Is(err, http.E |4:     if errors.Is(err, http. |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 21,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(err,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Is(err error, target error) bool
󰘫  |1: nextpara: |2: {
  label = "target error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "target error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 28 }
 |5: 52
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 52 |4: { "  target error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err, http.Er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 21
󰘫  |1: delta |2: Er |3:     if errors.Is(err, http.Er |4:     if errors.Is(err, http.E |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 21,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(err,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Is(err error, target error) bool
󰘫  |1: nextpara: |2: {
  label = "target error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "target error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 29 }
 |5: 52
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 52 |4: { "  target error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err, http.Err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 21
󰘫  |1: delta |2: rr |3:     if errors.Is(err, http.Err |4:     if errors.Is(err, http.Er |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 21,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(err,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Is(err error, target error) bool
󰘫  |1: nextpara: |2: {
  label = "target error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "target error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 30 }
 |5: 52
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 52 |4: { "  target error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err, http.ErrS
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 21
󰘫  |1: delta |2: rS |3:     if errors.Is(err, http.ErrS |4:     if errors.Is(err, http.Err |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 21,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(err,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Is(err error, target error) bool
󰘫  |1: nextpara: |2: {
  label = "target error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "target error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 31 }
 |5: 52
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 52 |4: { "  target error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err, http.ErrSe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 21
󰘫  |1: delta |2: Se |3:     if errors.Is(err, http.ErrSe |4:     if errors.Is(err, http.ErrS |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 21,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(err,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Is(err error, target error) bool
󰘫  |1: nextpara: |2: {
  label = "target error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "target error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 32 }
 |5: 52
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 52 |4: { "  target error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err, http.ErrServerClosed
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 21
󰘫  |1: delta |2: erverClosed |3:     if errors.Is(err, http.ErrServerClosed |4:     if errors.Is(err, http.ErrSe |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 21,
      line = 52
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Is reports whether any error in err's tree matches target.\n\nThe tree consists of err itself, followed by the errors obtained by repeatedly calling Unwrap. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.\n\nAn error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.\n\nAn error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines\n\n\tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\nthen Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is](https://pkg.go.dev/syscall#Errno.Is) for an example in the standard library. An Is method should only shallowly compare err and the target and not call Unwrap on either."
      },
      label = "Is(err error, target error) bool",
      parameters = { {
          label = "err error"
        }, {
          label = "target error"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    if errors.Is(err,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Is(err error, target error) bool
󰘫  |1: nextpara: |2: {
  label = "target error"
}

󰘫  |1: func |2: Is(err error, target error) bool |3: {
  label = "target error"
}

󰘫  |1: virtual text only : |2:     err := serverOne.ListenAndServe() |3:   } |4: { 53, 42 }
 |5: 51 |6:     err := serverOne.ListenAndServe()
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 52 |3: 51 |4: { "       target error", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err, http.ErrServerClosed) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 44
󰘫  |1: delta |2: d)  |3:     if errors.Is(err, http.ErrServerClosed)  |4:     if errors.Is(err, http.ErrServerClosed |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     if errors.Is(err, http.ErrServerClosed) {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 45
󰘫  |1: delta |2:  { |3:     if errors.Is(err, http.ErrServerClosed) { |4:     if errors.Is(err, http.ErrServerClosed)  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: f errors.Is(err, http.ErrServerClosed) { |3:        |4:     if errors.Is(err, http.ErrServerClosed) { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2:  f |3:       f |4:        |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: fm |3:       fm |4:       f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fms
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ms |3:       fms |4:       fm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ms |3:       fm |4:       fms |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: mt |3:       fmt |4:       fm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: t. |3:       fmt. |4:       fmt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Print
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: .Print |3:       fmt.Print |4:       fmt. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: tf |3:       fmt.Printf |4:       fmt.Print |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: f( |3:       fmt.Printf( |4:       fmt.Printf |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 17,
      line = 53
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "      fmt.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "      fmt.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     if errors.Is(err, http.ErrServerClosed) { |3:     } |4: { 54, 17 }
 |5: 54 |6:     }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 53 |3: 54 |4: { "              format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: (" |3:       fmt.Printf(" |4:       fmt.Printf( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: "r |3:       fmt.Printf("r |4:       fmt.Printf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: re |3:       fmt.Printf("re |4:       fmt.Printf("r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("rer
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: er |3:       fmt.Printf("rer |4:       fmt.Printf("re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: er |3:       fmt.Printf("re |4:       fmt.Printf("rer |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: re |3:       fmt.Printf("r |4:       fmt.Printf("re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("ri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: ri |3:       fmt.Printf("ri |4:       fmt.Printf("r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("ris
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: is |3:       fmt.Printf("ris |4:       fmt.Printf("ri |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("ri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: is |3:       fmt.Printf("ri |4:       fmt.Printf("ris |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: ri |3:       fmt.Printf("r |4:       fmt.Printf("ri |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: "r |3:       fmt.Printf(" |4:       fmt.Printf("r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: "s |3:       fmt.Printf("s |4:       fmt.Printf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("se
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: se |3:       fmt.Printf("se |4:       fmt.Printf("s |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("ser
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: er |3:       fmt.Printf("ser |4:       fmt.Printf("se |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("serv
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: rv |3:       fmt.Printf("serv |4:       fmt.Printf("ser |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("serve
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: ve |3:       fmt.Printf("serve |4:       fmt.Printf("serv |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: er |3:       fmt.Printf("server |4:       fmt.Printf("serve |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: r  |3:       fmt.Printf("server  |4:       fmt.Printf("server |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server o
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  o |3:       fmt.Printf("server o |4:       fmt.Printf("server  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server on
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: on |3:       fmt.Printf("server on |4:       fmt.Printf("server o |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: ne |3:       fmt.Printf("server one |4:       fmt.Printf("server on |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: e  |3:       fmt.Printf("server one  |4:       fmt.Printf("server one |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  c |3:       fmt.Printf("server one c |4:       fmt.Printf("server one  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one cl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: cl |3:       fmt.Printf("server one cl |4:       fmt.Printf("server one c |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one clo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: lo |3:       fmt.Printf("server one clo |4:       fmt.Printf("server one cl |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one clos
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: os |3:       fmt.Printf("server one clos |4:       fmt.Printf("server one clo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one close
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: se |3:       fmt.Printf("server one close |4:       fmt.Printf("server one clos |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one closed
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: ed |3:       fmt.Printf("server one closed |4:       fmt.Printf("server one close |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one closedno
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: dno |3:       fmt.Printf("server one closedno |4:       fmt.Printf("server one closed |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one closednon
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: on |3:       fmt.Printf("server one closednon |4:       fmt.Printf("server one closedno |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one closednon 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: n  |3:       fmt.Printf("server one closednon  |4:       fmt.Printf("server one closednon |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one closednon
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: n  |3:       fmt.Printf("server one closednon |4:       fmt.Printf("server one closednon  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one closedno
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: on |3:       fmt.Printf("server one closedno |4:       fmt.Printf("server one closednon |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one closedn
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: no |3:       fmt.Printf("server one closedn |4:       fmt.Printf("server one closedno |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one closed
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: dn |3:       fmt.Printf("server one closed |4:       fmt.Printf("server one closedn |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one closedm 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: dm  |3:       fmt.Printf("server one closedm  |4:       fmt.Printf("server one closed |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one closedm n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  n |3:       fmt.Printf("server one closedm n |4:       fmt.Printf("server one closedm  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one closedm 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  n |3:       fmt.Printf("server one closedm  |4:       fmt.Printf("server one closedm n |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one closedm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: m  |3:       fmt.Printf("server one closedm |4:       fmt.Printf("server one closedm  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one closed
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: dm |3:       fmt.Printf("server one closed |4:       fmt.Printf("server one closedm |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one closed\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: d\ |3:       fmt.Printf("server one closed\ |4:       fmt.Printf("server one closed |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("server one closed\n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: \n |3:       fmt.Printf("server one closed\n |4:       fmt.Printf("server one closed\ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  fmt.Printf("server one closed\n |3:        |4:       fmt.Printf("server one closed\n |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     }
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:     } |3:     } |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: }  |3:     }  |4:     } |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } e
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2:  e |3:     } e |4:     }  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } el
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: el |3:     } el |4:     } e |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } els
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ls |3:     } els |4:     } el |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: se |3:     } else |4:     } els |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: e  |3:     } else  |4:     } else |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2:  i |3:     } else i |4:     } else  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else if
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: if |3:     } else if |4:     } else i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else if 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: f  |3:     } else if  |4:     } else if |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else if e
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2:  e |3:     } else if e |4:     } else if  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else if er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: er |3:     } else if er |4:     } else if e |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else if err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: rr |3:     } else if err |4:     } else if er |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else if err 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: r  |3:     } else if err  |4:     } else if err |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else if err !
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2:  ! |3:     } else if err ! |4:     } else if err  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else if err !=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: != |3:     } else if err != |4:     } else if err ! |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else if err != 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: =  |3:     } else if err !=  |4:     } else if err != |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else if err != n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  n |3:     } else if err != n |4:     } else if err !=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else if err != ni
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: ni |3:     } else if err != ni |4:     } else if err != n |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else if err != nil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: il |3:     } else if err != nil |4:     } else if err != ni |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else if err != nil 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: l  |3:     } else if err != nil  |4:     } else if err != nil |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     } else if err != nil {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2:  { |3:     } else if err != nil { |4:     } else if err != nil  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  else if err != nil { |3:        |4:     } else if err != nil { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2:  f |3:       f |4:        |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: fm |3:       fm |4:       f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: mt |3:       fmt |4:       fm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: t. |3:       fmt. |4:       fmt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Print
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: .Print |3:       fmt.Print |4:       fmt. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: tf |3:       fmt.Printf |4:       fmt.Print |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: f( |3:       fmt.Printf( |4:       fmt.Printf |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 17,
      line = 55
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "      fmt.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "      fmt.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     } else if err != nil { |3:     } |4: { 56, 17 }
 |5: 56 |6:     }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 55 |3: 56 |4: { "              format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: (" |3:       fmt.Printf(" |4:       fmt.Printf( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("e
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: "e |3:       fmt.Printf("e |4:       fmt.Printf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: er |3:       fmt.Printf("er |4:       fmt.Printf("e |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: rr |3:       fmt.Printf("err |4:       fmt.Printf("er |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("erro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: ro |3:       fmt.Printf("erro |4:       fmt.Printf("err |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: or |3:       fmt.Printf("error |4:       fmt.Printf("erro |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: r  |3:       fmt.Printf("error  |4:       fmt.Printf("error |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  l |3:       fmt.Printf("error l |4:       fmt.Printf("error  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error li
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: li |3:       fmt.Printf("error li |4:       fmt.Printf("error l |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error lis
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: is |3:       fmt.Printf("error lis |4:       fmt.Printf("error li |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error list
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: st |3:       fmt.Printf("error list |4:       fmt.Printf("error lis |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error liste
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: te |3:       fmt.Printf("error liste |4:       fmt.Printf("error list |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listen
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: en |3:       fmt.Printf("error listen |4:       fmt.Printf("error liste |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: ning |3:       fmt.Printf("error listening |4:       fmt.Printf("error listen |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: g  |3:       fmt.Printf("error listening  |4:       fmt.Printf("error listening |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  for |3:       fmt.Printf("error listening for |4:       fmt.Printf("error listening  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: r  |3:       fmt.Printf("error listening for  |4:       fmt.Printf("error listening for |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  s |3:       fmt.Printf("error listening for s |4:       fmt.Printf("error listening for  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for se
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: se |3:       fmt.Printf("error listening for se |4:       fmt.Printf("error listening for s |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for ser
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: er |3:       fmt.Printf("error listening for ser |4:       fmt.Printf("error listening for se |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for serv
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: rv |3:       fmt.Printf("error listening for serv |4:       fmt.Printf("error listening for ser |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for servz
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: vz |3:       fmt.Printf("error listening for servz |4:       fmt.Printf("error listening for serv |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for servz 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: z  |3:       fmt.Printf("error listening for servz  |4:       fmt.Printf("error listening for servz |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for servz o
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  o |3:       fmt.Printf("error listening for servz o |4:       fmt.Printf("error listening for servz  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for servz 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  o |3:       fmt.Printf("error listening for servz  |4:       fmt.Printf("error listening for servz o |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for servz
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: z  |3:       fmt.Printf("error listening for servz |4:       fmt.Printf("error listening for servz  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for serv
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: vz |3:       fmt.Printf("error listening for serv |4:       fmt.Printf("error listening for servz |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for serve
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: ve |3:       fmt.Printf("error listening for serve |4:       fmt.Printf("error listening for serv |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: er |3:       fmt.Printf("error listening for server |4:       fmt.Printf("error listening for serve |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: r  |3:       fmt.Printf("error listening for server  |4:       fmt.Printf("error listening for server |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server o
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  o |3:       fmt.Printf("error listening for server o |4:       fmt.Printf("error listening for server  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server on
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: on |3:       fmt.Printf("error listening for server on |4:       fmt.Printf("error listening for server o |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: ne |3:       fmt.Printf("error listening for server one |4:       fmt.Printf("error listening for server on |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: e: |3:       fmt.Printf("error listening for server one: |4:       fmt.Printf("error listening for server one |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: :  |3:       fmt.Printf("error listening for server one:  |4:       fmt.Printf("error listening for server one: |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one: \
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  \ |3:       fmt.Printf("error listening for server one: \ |4:       fmt.Printf("error listening for server one:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one: \t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: \t |3:       fmt.Printf("error listening for server one: \t |4:       fmt.Printf("error listening for server one: \ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one: \
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: \t |3:       fmt.Printf("error listening for server one: \ |4:       fmt.Printf("error listening for server one: \t |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one: \s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: \s |3:       fmt.Printf("error listening for server one: \s |4:       fmt.Printf("error listening for server one: \ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one: \s\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: s\ |3:       fmt.Printf("error listening for server one: \s\ |4:       fmt.Printf("error listening for server one: \s |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one: \s\n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: \n |3:       fmt.Printf("error listening for server one: \s\n |4:       fmt.Printf("error listening for server one: \s\ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  \s\n |3:       fmt.Printf("error listening for server one:  |4:       fmt.Printf("error listening for server one: \s\n |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one: %
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2:  % |3:       fmt.Printf("error listening for server one: % |4:       fmt.Printf("error listening for server one:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one: %s\n",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 56
󰘫  |1: delta |2: %s\n", |3:       fmt.Printf("error listening for server one: %s\n", |4:       fmt.Printf("error listening for server one: % |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 56,
      line = 55
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '      fmt.Printf("error listening for server one: %s\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:     } else if err != nil { |3:     } |4: { 56, 56 }
 |5: 54 |6:     } else if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 55 |3: 54 |4: { "                                a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one: %s\n", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 56
󰘫  |1: delta |2: ,  |3:       fmt.Printf("error listening for server one: %s\n",  |4:       fmt.Printf("error listening for server one: %s\n", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 56,
      line = 55
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '      fmt.Printf("error listening for server one: %s\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:     } else if err != nil { |3:     } |4: { 56, 57 }
 |5: 54 |6:     } else if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 55 |3: 54 |4: { "                                 a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one: %s\n", e
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 56
󰘫  |1: delta |2:  e |3:       fmt.Printf("error listening for server one: %s\n", e |4:       fmt.Printf("error listening for server one: %s\n",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 56,
      line = 55
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '      fmt.Printf("error listening for server one: %s\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:     } else if err != nil { |3:     } |4: { 56, 58 }
 |5: 54 |6:     } else if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 55 |3: 54 |4: { "                                  a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one: %s\n", er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 56
󰘫  |1: delta |2: er |3:       fmt.Printf("error listening for server one: %s\n", er |4:       fmt.Printf("error listening for server one: %s\n", e |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 56,
      line = 55
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '      fmt.Printf("error listening for server one: %s\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:     } else if err != nil { |3:     } |4: { 56, 59 }
 |5: 54 |6:     } else if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 55 |3: 54 |4: { "                                   a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:       fmt.Printf("error listening for server one: %s\n", err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 56
󰘫  |1: delta |2: rr |3:       fmt.Printf("error listening for server one: %s\n", err |4:       fmt.Printf("error listening for server one: %s\n", er |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 56,
      line = 55
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '      fmt.Printf("error listening for server one: %s\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:     } else if err != nil { |3:     } |4: { 56, 60 }
 |5: 54 |6:     } else if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 55 |3: 54 |4: { "                                    a ...any", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  c |3:     c |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ca
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ca |3:     ca |4:     c |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     can
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: an |3:     can |4:     ca |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     canc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: nc |3:     canc |4:     can |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     cance
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ce |3:     cance |4:     canc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     cancel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: el |3:     cancel |4:     cance |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     cancelC
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: lC |3:     cancelC |4:     cancel |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     cancelCt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: Ct |3:     cancelCt |4:     cancelC |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     cancelCtx
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: tx |3:     cancelCtx |4:     cancelCt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     cancelCtx(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: x( |3:     cancelCtx( |4:     cancelCtx |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 14,
      line = 57
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = ""
      },
      label = "cancelCtx()"
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    cancelCtx(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: no sig
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     cancelCtx
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2:     cancelCtx |3:     cancelCtx |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 13,
      line = 57
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = ""
      },
      label = "cancelCtx()"
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "    cancelCtx",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: no sig
󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   }
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:   } |3:   } |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   }(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: }( |3:   }( |4:   } |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 4,
      line = 58
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = ""
      },
      label = "func()"
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  }(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: no sig
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 2,
      line = 60
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 8,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "  ",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 8 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "parent context.Context"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "parent context.Context"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 61, 2 }
 |5: 59 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 60 |3: 59 |4: { "    parent context.Context", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	<-ctx.Done()
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: <-ctx.Done() |3: 	<-ctx.Done() |4:    |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	<-ctx.Done(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: 	<-ctx.Done( |3: 	<-ctx.Done( |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 12,
      line = 70
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Done returns a channel that's closed when work done on behalf of this context should be canceled. Done may return nil if this context can never be canceled. Successive calls to Done return the same value. The close of the Done channel may happen asynchronously, after the cancel function returns.\n\nWithCancel arranges for Done to be closed when cancel is called; WithDeadline arranges for Done to be closed when the deadline expires; WithTimeout arranges for Done to be closed when the timeout elapses.\n\nDone is provided for use in select statements:\n\n\t// Stream generates values with DoSomething and sends them to out\n\t// until DoSomething returns an error or ctx.Done is closed.\n\tfunc Stream(ctx context.Context, out chan<- Value) error {\n\t\tfor {\n\t\t\tv, err := DoSomething(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn ctx.Err()\n\t\t\tcase out <- v:\n\t\t\t}\n\t\t}\n\t}\n\nSee [https://blog.golang.org/pipelines](https://blog.golang.org/pipelines) for more examples of how to use a Done channel for cancellation."
      },
      label = "Done() <-chan struct{}"
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "\t<-ctx.Done(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: no sig
󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(1
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2:   BaseContext: func(1 |3:   BaseContext: func(1 |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: (1 |3:   BaseContext: func( |4:   BaseContext: func(1 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   BaseContext: func(l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 20
󰘫  |1: delta |2: (l |3:   BaseContext: func(l |4:   BaseContext: func( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 1
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 47
󰘫  |1: delta |2:     ctx = context.WithValue(ctx, keyServerAddr, 1 |3:     ctx = context.WithValue(ctx, keyServerAddr, 1 |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 47,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx, keyServerAddr,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "val any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "val any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(l net.Listener) context.Context { |3:     return ctx |4: { 38, 49 }
 |5: 38 |6:     return ctx
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 38 |4: { "                                     val any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 47
󰘫  |1: delta |2:  1 |3:     ctx = context.WithValue(ctx, keyServerAddr,  |4:     ctx = context.WithValue(ctx, keyServerAddr, 1 |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 47,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx, keyServerAddr,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "val any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "val any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(l net.Listener) context.Context { |3:     return ctx |4: { 38, 48 }
 |5: 38 |6:     return ctx
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 38 |4: { "                                    val any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ctx = context.WithValue(ctx, keyServerAddr, l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 47
󰘫  |1: delta |2:  l |3:     ctx = context.WithValue(ctx, keyServerAddr, l |4:     ctx = context.WithValue(ctx, keyServerAddr,  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 47,
      line = 37
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/httpserver/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "WithValue returns a copy of parent in which the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface."
      },
      label = "WithValue(parent context.Context, key any, val any) context.Context",
      parameters = { {
          label = "parent context.Context"
        }, {
          label = "key any"
        }, {
          label = "val any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ctx = context.WithValue(ctx, keyServerAddr,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: WithValue(parent context.Context, key any, val any) context.Context
󰘫  |1: nextpara: |2: {
  label = "val any"
}

󰘫  |1: func |2: WithValue(parent context.Context, key any, val any) context.Context |3: {
  label = "val any"
}

󰘫  |1: virtual text only : |2:   BaseContext: func(l net.Listener) context.Context { |3:     return ctx |4: { 38, 49 }
 |5: 37
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 37 |3: 37 |4: { "  val any", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 		Addr:    ":4444"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: 		Addr:    ":4444" |3: 		Addr:    ":4444" |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:  
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: 		Addr:    ":4444" |3:   |4: 		Addr:    ":4444" |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
