󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: p
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: p |3: p |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pa
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: pa |3: pa |4: p |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pacn
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: acn |3: pacn |4: pa |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package handlers
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: kage handlers |3: package handlers |4: pacn |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2: package handlers |3:  |4: package handlers |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: i |3: i |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: im
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: im |3: im |4: i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: imp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: mp |3: imp |4: im |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: impl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: pl |3: impl |4: imp |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: imp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: pl |3: imp |4: impl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: impo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: po |3: impo |4: imp |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: impor
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: or |3: impor |4: impo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: rt |3: import |4: impor |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: t  |3: import  |4: import |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2:  " |3: import " |4: import  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: "l |3: import "l |4: import " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: lo |3: import "lo |4: import "l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: og |3: import "log |4: import "lo |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: t |3: t |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: ty
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: ty |3: ty |4: t |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: typ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: yp |3: typ |4: ty |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: pe |3: type |4: typ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: e  |3: type  |4: type |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Good
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2:  Good |3: type Good |4: type  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Goodb
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: db |3: type Goodb |4: type Good |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Goodby
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: by |3: type Goodby |4: type Goodb |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Goodbye
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ye |3: type Goodbye |4: type Goodby |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Goodbye 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: e  |3: type Goodbye  |4: type Goodbye |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Goodbye s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2:  s |3: type Goodbye s |4: type Goodbye  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Goodbye st
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: st |3: type Goodbye st |4: type Goodbye s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Goodbye str
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: tr |3: type Goodbye str |4: type Goodbye st |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Goodbye stru
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: ru |3: type Goodbye stru |4: type Goodbye str |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Goodbye struc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: uc |3: type Goodbye struc |4: type Goodbye stru |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Goodbye struct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: ct |3: type Goodbye struct |4: type Goodbye struc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Goodbye struct 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: t  |3: type Goodbye struct  |4: type Goodbye struct |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Goodbye struct {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:  { |3: type Goodbye struct { |4: type Goodbye struct  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: ype Goodbye struct { |3:    |4: type Goodbye struct { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  l |3:   l |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: l  |3:   l  |4:   l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  * |3:   l * |4:   l  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: *l |3:   l *l |4:   l * |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: lo |3:   l *lo |4:   l *l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: og |3:   l *log |4:   l *lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: g. |3:   l *log. |4:   l *log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: .l |3:   l *log.l |4:   l *log. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: lo |3:   l *log.lo |4:   l *log.l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: og |3:   l *log.log |4:   l *log.lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.logg
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: gg |3:   l *log.logg |4:   l *log.log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: gg |3:   l *log.log |4:   l *log.logg |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: og |3:   l *log.lo |4:   l *log.log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: lo |3:   l *log.l |4:   l *log.lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: .l |3:   l *log. |4:   l *log.l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.L
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: .L |3:   l *log.L |4:   l *log. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: Lo |3:   l *log.Lo |4:   l *log.L |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: og |3:   l *log.Log |4:   l *log.Lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Logg
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: gg |3:   l *log.Logg |4:   l *log.Log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Logge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: ge |3:   l *log.Logge |4:   l *log.Logg |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Logger
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: er |3:   l *log.Logger |4:   l *log.Logge |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: o
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: o |3: o |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2: o |3:  |4: o |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: f |3: f |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: fu |3: fu |4: f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: un |3: fun |4: fu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: nc |3: func |4: fun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: c  |3: func  |4: func |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func N
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  N |3: func N |4: func  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func Ne
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: Ne |3: func Ne |4: func N |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func Nea
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ea |3: func Nea |4: func Ne |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func Ne
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ea |3: func Ne |4: func Nea |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func New
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ew |3: func New |4: func Ne |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewG
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: wG |3: func NewG |4: func New |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGO
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: GO |3: func NewGO |4: func NewG |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewG
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: GO |3: func NewG |4: func NewGO |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: Go |3: func NewGo |4: func NewG |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: oo |3: func NewGoo |4: func NewGo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGood
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: od |3: func NewGood |4: func NewGoo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodb
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: db |3: func NewGoodb |4: func NewGood |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodby
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: by |3: func NewGoodby |4: func NewGoodb |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: ye |3: func NewGoodbye |4: func NewGoodby |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: e( |3: func NewGoodbye( |4: func NewGoodbye |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: (l |3: func NewGoodbye(l |4: func NewGoodbye( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: l  |3: func NewGoodbye(l  |4: func NewGoodbye(l |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2:  * |3: func NewGoodbye(l * |4: func NewGoodbye(l  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: *l |3: func NewGoodbye(l *l |4: func NewGoodbye(l * |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: lo |3: func NewGoodbye(l *lo |4: func NewGoodbye(l *l |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: og |3: func NewGoodbye(l *log |4: func NewGoodbye(l *lo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: g. |3: func NewGoodbye(l *log. |4: func NewGoodbye(l *log |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log.L
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: .L |3: func NewGoodbye(l *log.L |4: func NewGoodbye(l *log. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log.Lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: Lo |3: func NewGoodbye(l *log.Lo |4: func NewGoodbye(l *log.L |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log.Log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: og |3: func NewGoodbye(l *log.Log |4: func NewGoodbye(l *log.Lo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log.Logg
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: gg |3: func NewGoodbye(l *log.Logg |4: func NewGoodbye(l *log.Log |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log.Logge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ge |3: func NewGoodbye(l *log.Logge |4: func NewGoodbye(l *log.Logg |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log.Logger
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: er |3: func NewGoodbye(l *log.Logger |4: func NewGoodbye(l *log.Logge |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log.Logger) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2: r)  |3: func NewGoodbye(l *log.Logger)  |4: func NewGoodbye(l *log.Logger |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log.Logger) *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2:  * |3: func NewGoodbye(l *log.Logger) * |4: func NewGoodbye(l *log.Logger)  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log.Logger) *Good
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 36
󰘫  |1: delta |2: *Good |3: func NewGoodbye(l *log.Logger) *Good |4: func NewGoodbye(l *log.Logger) * |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log.Logger) *Goodb
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 37
󰘫  |1: delta |2: db |3: func NewGoodbye(l *log.Logger) *Goodb |4: func NewGoodbye(l *log.Logger) *Good |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log.Logger) *Goodby
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 38
󰘫  |1: delta |2: by |3: func NewGoodbye(l *log.Logger) *Goodby |4: func NewGoodbye(l *log.Logger) *Goodb |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log.Logger) *Goodbye
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 39
󰘫  |1: delta |2: ye |3: func NewGoodbye(l *log.Logger) *Goodbye |4: func NewGoodbye(l *log.Logger) *Goodby |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log.Logger) *Goodbye 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 40
󰘫  |1: delta |2: e  |3: func NewGoodbye(l *log.Logger) *Goodbye  |4: func NewGoodbye(l *log.Logger) *Goodbye |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewGoodbye(l *log.Logger) *Goodbye {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 41
󰘫  |1: delta |2:  { |3: func NewGoodbye(l *log.Logger) *Goodbye { |4: func NewGoodbye(l *log.Logger) *Goodbye  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: unc NewGoodbye(l *log.Logger) *Goodbye { |3:    |4: func NewGoodbye(l *log.Logger) *Goodbye { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  r |3:   r |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: re |3:   re |4:   r |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ret
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: et |3:   ret |4:   re |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   reti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ti |3:   reti |4:   ret |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   retir
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ir |3:   retir |4:   reti |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   retirn
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: rn |3:   retirn |4:   retir |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   retir
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: rn |3:   retir |4:   retirn |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   reti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ir |3:   reti |4:   retir |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ret
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: ti |3:   ret |4:   reti |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: et |3:   re |4:   ret |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ret
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: et |3:   ret |4:   re |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   retu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: tu |3:   retu |4:   ret |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   retur
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ur |3:   retur |4:   retu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: rn |3:   return |4:   retur |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: n  |3:   return  |4:   return |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:  & |3:   return & |4:   return  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Good
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: &Good |3:   return &Good |4:   return & |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Goodb
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: db |3:   return &Goodb |4:   return &Good |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Goodby
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: by |3:   return &Goodby |4:   return &Goodb |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Goodbye
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: ye |3:   return &Goodbye |4:   return &Goodby |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Goodbye{
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: e{ |3:   return &Goodbye{ |4:   return &Goodbye |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Goodbye{l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: {l |3:   return &Goodbye{l |4:   return &Goodbye{ |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Goodbye{
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2:   return &Goodbye{ |3:   return &Goodbye{ |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: f |3: f |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: fu |3: fu |4: f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: un |3: fun |4: fu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: nc |3: func |4: fun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: c  |3: func  |4: func |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  ( |3: func ( |4: func  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: (g |3: func (g |4: func ( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: g* |3: func (g* |4: func (g |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*G
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: *G |3: func (g*G |4: func (g* |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Good
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: Good |3: func (g*Good |4: func (g*G |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodb
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: db |3: func (g*Goodb |4: func (g*Good |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodby
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: by |3: func (g*Goodby |4: func (g*Goodb |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ye |3: func (g*Goodbye |4: func (g*Goodby |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: func (g*Goodbye |3: func (g*Goodbye |4: func (g*Goodbye |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: e)  |3: func (g*Goodbye)  |4: func (g*Goodbye |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2:  S |3: func (g*Goodbye) S |4: func (g*Goodbye)  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) Se
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: Se |3: func (g*Goodbye) Se |4: func (g*Goodbye) S |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) Ser
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: er |3: func (g*Goodbye) Ser |4: func (g*Goodbye) Se |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) Serv
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: rv |3: func (g*Goodbye) Serv |4: func (g*Goodbye) Ser |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) Serve
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: ve |3: func (g*Goodbye) Serve |4: func (g*Goodbye) Serv |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeH
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: eH |3: func (g*Goodbye) ServeH |4: func (g*Goodbye) Serve |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHT
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: HT |3: func (g*Goodbye) ServeHT |4: func (g*Goodbye) ServeH |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTT
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: TT |3: func (g*Goodbye) ServeHTT |4: func (g*Goodbye) ServeHT |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: TP |3: func (g*Goodbye) ServeHTTP |4: func (g*Goodbye) ServeHTT |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: P( |3: func (g*Goodbye) ServeHTTP( |4: func (g*Goodbye) ServeHTTP |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: (r |3: func (g*Goodbye) ServeHTTP(r |4: func (g*Goodbye) ServeHTTP( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: rw |3: func (g*Goodbye) ServeHTTP(rw |4: func (g*Goodbye) ServeHTTP(r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: w  |3: func (g*Goodbye) ServeHTTP(rw  |4: func (g*Goodbye) ServeHTTP(rw |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2:  h |3: func (g*Goodbye) ServeHTTP(rw h |4: func (g*Goodbye) ServeHTTP(rw  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: ht |3: func (g*Goodbye) ServeHTTP(rw ht |4: func (g*Goodbye) ServeHTTP(rw h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: tt |3: func (g*Goodbye) ServeHTTP(rw htt |4: func (g*Goodbye) ServeHTTP(rw ht |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: tp |3: func (g*Goodbye) ServeHTTP(rw http |4: func (g*Goodbye) ServeHTTP(rw htt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: p. |3: func (g*Goodbye) ServeHTTP(rw http. |4: func (g*Goodbye) ServeHTTP(rw http |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: func (g*Goodbye) ServeHTTP(rw http. |3: func (g*Goodbye) ServeHTTP(rw http. |4: func (g*Goodbye) ServeHTTP(rw http. |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: .R |3: func (g*Goodbye) ServeHTTP(rw http.R |4: func (g*Goodbye) ServeHTTP(rw http. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: Re |3: func (g*Goodbye) ServeHTTP(rw http.Re |4: func (g*Goodbye) ServeHTTP(rw http.R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.Res
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: es |3: func (g*Goodbye) ServeHTTP(rw http.Res |4: func (g*Goodbye) ServeHTTP(rw http.Re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: sponseWriter |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter |4: func (g*Goodbye) ServeHTTP(rw http.Res |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 50
󰘫  |1: delta |2: r, |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 50
󰘫  |1: delta |2: ,  |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter,  |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 50
󰘫  |1: delta |2:  r |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 50
󰘫  |1: delta |2: r  |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r  |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 50
󰘫  |1: delta |2:  * |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r * |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 50
󰘫  |1: delta |2: *h |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *h |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r * |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 50
󰘫  |1: delta |2: ht |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *ht |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 50
󰘫  |1: delta |2: tt |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *htt |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *ht |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 50
󰘫  |1: delta |2: tp |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *htt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 50
󰘫  |1: delta |2: p. |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http. |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 50
󰘫  |1: delta |2: .R |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.R |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 50
󰘫  |1: delta |2: Re |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Re |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 50
󰘫  |1: delta |2: equest |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 68
󰘫  |1: delta |2: t)  |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request)  |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 69
󰘫  |1: delta |2:  { |3: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request) { |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request)  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: unc (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request) { |3:    |4: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request) { |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  r |3:   r |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: rw |3:   rw |4:   r |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: w. |3:   rw. |4:   rw |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.w
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: .w |3:   rw.w |4:   rw. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.wr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: wr |3:   rw.wr |4:   rw.w |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 11
󰘫  |1: delta |2: rite( |3:   rw.Write( |4:   rw.wr |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 11,
      line = 19
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/goodbye.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "[]byte"
}

󰘫  |1: func |2: Write([]byte) (int, error) |3: {
  label = "[]byte"
}

󰘫  |1: virtual text only : |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request) { |3: } |4: { 20, 11 }
 |5: 20 |6: }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 19 |3: 20 |4: { "            []byte", "Comment" }

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 11
󰘫  |1: delta |2:   rw.Write( |3:   rw.Write( |4:   rw.Write( |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 11,
      line = 19
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/goodbye.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "  rw.Write(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |3: {
  border = "rounded",
  line_to_cursor = "  rw.Write(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "[]byte"
}

󰘫  |1: func |2: Write([]byte) (int, error) |3: {
  label = "[]byte"
}

󰘫  |1: virtual text only : |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request) { |3: } |4: { 20, 11 }
 |5: 20 |6: }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 19 |3: 20 |4: { "            []byte", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 11
󰘫  |1: delta |2: ([ |3:   rw.Write([ |4:   rw.Write( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 11,
      line = 19
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/goodbye.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "[]byte"
}

󰘫  |1: func |2: Write([]byte) (int, error) |3: {
  label = "[]byte"
}

󰘫  |1: virtual text only : |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request) { |3: } |4: { 20, 12 }
 |5: 20 |6: }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 19 |3: 20 |4: { "             []byte", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]b
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 11
󰘫  |1: delta |2: []b |3:   rw.Write([]b |4:   rw.Write([ |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 11,
      line = 19
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/goodbye.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "[]byte"
}

󰘫  |1: func |2: Write([]byte) (int, error) |3: {
  label = "[]byte"
}

󰘫  |1: virtual text only : |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request) { |3: } |4: { 20, 14 }
 |5: 19
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 19 |3: 19 |4: { "  []byte", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]by
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 11
󰘫  |1: delta |2: by |3:   rw.Write([]by |4:   rw.Write([]b |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 11,
      line = 19
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/goodbye.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "[]byte"
}

󰘫  |1: func |2: Write([]byte) (int, error) |3: {
  label = "[]byte"
}

󰘫  |1: virtual text only : |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request) { |3: } |4: { 20, 15 }
 |5: 19
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 19 |3: 19 |4: { "  []byte", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]byt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 11
󰘫  |1: delta |2: yt |3:   rw.Write([]byt |4:   rw.Write([]by |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 11,
      line = 19
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/goodbye.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "[]byte"
}

󰘫  |1: func |2: Write([]byte) (int, error) |3: {
  label = "[]byte"
}

󰘫  |1: virtual text only : |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request) { |3: } |4: { 20, 16 }
 |5: 19
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 19 |3: 19 |4: { "  []byte", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]byte
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 11
󰘫  |1: delta |2: te |3:   rw.Write([]byte |4:   rw.Write([]byt |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 11,
      line = 19
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/goodbye.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "[]byte"
}

󰘫  |1: func |2: Write([]byte) (int, error) |3: {
  label = "[]byte"
}

󰘫  |1: virtual text only : |2: func (g*Goodbye) ServeHTTP(rw http.ResponseWriter, r *http.Request) { |3: } |4: { 20, 17 }
 |5: 19
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 19 |3: 19 |4: { "  []byte", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]byte(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: e( |3:   rw.Write([]byte( |4:   rw.Write([]byte |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]byte("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: (" |3:   rw.Write([]byte(" |4:   rw.Write([]byte( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]byte("B
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: "B |3:   rw.Write([]byte("B |4:   rw.Write([]byte(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]byte("By
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: By |3:   rw.Write([]byte("By |4:   rw.Write([]byte("B |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]byte("Bye
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: ye |3:   rw.Write([]byte("Bye |4:   rw.Write([]byte("By |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]byte("Byee
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: ee |3:   rw.Write([]byte("Byee |4:   rw.Write([]byte("Bye |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]byte("Byee
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2:   rw.Write([]byte("Byee |3:   rw.Write([]byte("Byee |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]byte("Byee!
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: e! |3:   rw.Write([]byte("Byee! |4:   rw.Write([]byte("Byee |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]byte("Byee
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2:   rw.Write([]byte("Byee |3:   rw.Write([]byte("Byee |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  signature_result = {
    cfgActiveSignature = 0,
    signatures = { {
        documentation = {
          kind = "markdown",
          value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
        },
        label = "Write([]byte) (int, error)",
        parameters = { {
            label = "[]byte"
          } }
      } }
  },
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]byte("Byee!
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2:   rw.Write([]byte("Byee! |3:   rw.Write([]byte("Byee! |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]byte("Byee!\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: !\ |3:   rw.Write([]byte("Byee!\ |4:   rw.Write([]byte("Byee! |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]byte("Byee!\n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: \n |3:   rw.Write([]byte("Byee!\n |4:   rw.Write([]byte("Byee!\ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write([]byte("Byee!\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2:   rw.Write([]byte("Byee!\ |3:   rw.Write([]byte("Byee!\ |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:   rw.Write([]byte("Byee!\ |3:  |4:   rw.Write([]byte("Byee!\ |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  signature_result = {
    cfgActiveSignature = 0,
    signatures = { {
        documentation = {
          kind = "markdown",
          value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
        },
        label = "Write([]byte) (int, error)",
        parameters = { {
            label = "[]byte"
          } }
      } }
  },
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: p
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: p |3: p |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pa
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: pa |3: pa |4: p |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pac
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: ac |3: pac |4: pa |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pack
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ck |3: pack |4: pac |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: packa
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: ka |3: packa |4: pack |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: packag
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ag |3: packag |4: packa |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ge |3: package |4: packag |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: e  |3: package  |4: package |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package d
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2:  d |3: package d |4: package  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package da
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: da |3: package da |4: package d |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package dat
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: at |3: package dat |4: package da |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package data
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ta |3: package data |4: package dat |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2: package data |3:  |4: package data |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: i |3: i |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: im
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: im |3: im |4: i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: imp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: mp |3: imp |4: im |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: impo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: po |3: impo |4: imp |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: impor
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: or |3: impor |4: impo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: rt |3: import |4: impor |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: t  |3: import  |4: import |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2:  t |3: import t |4: import  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2:  t |3: import  |4: import t |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2:  " |3: import " |4: import  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: "g |3: import "g |4: import " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "gm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: gm |3: import "gm |4: import "g |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "gme
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: me |3: import "gme |4: import "gm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "gmei
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ei |3: import "gmei |4: import "gme |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "gme
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ei |3: import "gme |4: import "gmei |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "gm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: me |3: import "gm |4: import "gme |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: gm |3: import "g |4: import "gm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: "g |3: import " |4: import "g |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: "t |3: import "t |4: import " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "ti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: ti |3: import "ti |4: import "t |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "tim
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: im |3: import "tim |4: import "ti |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "time
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: me |3: import "time |4: import "tim |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "tim
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: import "tim |3: import "tim |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: t |3: t |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: ty
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: ty |3: ty |4: t |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: typ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: yp |3: typ |4: ty |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: pe |3: type |4: typ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: e  |3: type  |4: type |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type p
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  p |3: type p |4: type  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  p |3: type  |4: type p |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type P
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  P |3: type P |4: type  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: Pr |3: type Pr |4: type P |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Pro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ro |3: type Pro |4: type Pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Prod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: od |3: type Prod |4: type Pro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Produ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: du |3: type Produ |4: type Prod |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Produc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: uc |3: type Produc |4: type Produ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Product
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ct |3: type Product |4: type Produc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Product 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: t  |3: type Product  |4: type Product |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Product s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2:  s |3: type Product s |4: type Product  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Product st
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: st |3: type Product st |4: type Product s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Product str
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: tr |3: type Product str |4: type Product st |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Product stru
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: ru |3: type Product stru |4: type Product str |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Product struc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: uc |3: type Product struc |4: type Product stru |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Product struct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: ct |3: type Product struct |4: type Product struc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Product struct 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: t  |3: type Product struct  |4: type Product struct |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Product struct {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:  { |3: type Product struct { |4: type Product struct  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: ype Product struct { |3:    |4: type Product struct { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   I
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  I |3:   I |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ID |3:   ID |4:   I |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: D  |3:   ID  |4:   ID |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  i |3:   ID i |4:   ID  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID in
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: in |3:   ID in |4:   ID i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID int
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: nt |3:   ID int |4:   ID in |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  ID int |3:    |4:   ID int |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   N
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  N |3:   N |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Na
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: Na |3:   Na |4:   N |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Nam
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: am |3:   Nam |4:   Na |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: me |3:   Name |4:   Nam |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: e  |3:   Name  |4:   Name |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2:  s |3:   Name s |4:   Name  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name st
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: st |3:   Name st |4:   Name s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name str
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: tr |3:   Name str |4:   Name st |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name string
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: ring |3:   Name string |4:   Name str |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  Name string |3:    |4:   Name string |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   D
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  D |3:   D |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   De
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: De |3:   De |4:   D |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Des
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: es |3:   Des |4:   De |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Desc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: sc |3:   Desc |4:   Des |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Descr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: cr |3:   Descr |4:   Desc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Descri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ri |3:   Descri |4:   Descr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Descrip
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ip |3:   Descrip |4:   Descri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Descript
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: pt |3:   Descript |4:   Descrip |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: tion |3:   Description |4:   Descript |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: n  |3:   Description  |4:   Description |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2:  s |3:   Description s |4:   Description  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description st
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: st |3:   Description st |4:   Description s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description str
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: tr |3:   Description str |4:   Description st |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description string
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: ring |3:   Description string |4:   Description str |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  Description string |3:    |4:   Description string |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   P
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  P |3:   P |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: Pr |3:   Pr |4:   P |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Pri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: ri |3:   Pri |4:   Pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Pric
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ic |3:   Pric |4:   Pri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ce |3:   Price |4:   Pric |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: e  |3:   Price  |4:   Price |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2:  f |3:   Price f |4:   Price  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price fl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: fl |3:   Price fl |4:   Price f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price flo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: lo |3:   Price flo |4:   Price fl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price floa
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: oa |3:   Price floa |4:   Price flo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price float
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: at |3:   Price float |4:   Price floa |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price float3
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: t3 |3:   Price float3 |4:   Price float |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price float32
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: 32 |3:   Price float32 |4:   Price float3 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  Price float32 |3:    |4:   Price float32 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  S |3:   S |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   SK
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: SK |3:   SK |4:   S |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   SKU
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: KU |3:   SKU |4:   SK |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   SKU 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: U  |3:   SKU  |4:   SKU |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   SKU s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2:  s |3:   SKU s |4:   SKU  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   SKU st
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: st |3:   SKU st |4:   SKU s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   SKU str
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: tr |3:   SKU str |4:   SKU st |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   SKU string
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ring |3:   SKU string |4:   SKU str |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  SKU string |3:    |4:   SKU string |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   C
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  C |3:   C |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Cr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: Cr |3:   Cr |4:   C |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Cre
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: re |3:   Cre |4:   Cr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Crea
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ea |3:   Crea |4:   Cre |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Creat
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: at |3:   Creat |4:   Crea |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Create
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: te |3:   Create |4:   Creat |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Created
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ed |3:   Created |4:   Create |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   CreatedO
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: dO |3:   CreatedO |4:   Created |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   CreatedOn
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: On |3:   CreatedOn |4:   CreatedO |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   CreatedOn 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: n  |3:   CreatedOn  |4:   CreatedOn |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   CreatedOn s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2:  s |3:   CreatedOn s |4:   CreatedOn  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   CreatedOn st
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: st |3:   CreatedOn st |4:   CreatedOn s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   CreatedOn str
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: tr |3:   CreatedOn str |4:   CreatedOn st |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   CreatedOn string
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: ring |3:   CreatedOn string |4:   CreatedOn str |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   CreatedOn string
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  CreatedOn string |3:    |4:   CreatedOn string |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   U
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  U |3:   U |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Up
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: Up |3:   Up |4:   U |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Upd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: pd |3:   Upd |4:   Up |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Upda
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: da |3:   Upda |4:   Upd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Updat
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: at |3:   Updat |4:   Upda |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Update
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: te |3:   Update |4:   Updat |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Updated
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ed |3:   Updated |4:   Update |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   UpdatedO
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: dO |3:   UpdatedO |4:   Updated |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   UpdatedOn
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: On |3:   UpdatedOn |4:   UpdatedO |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   UpdatedOn 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: n  |3:   UpdatedOn  |4:   UpdatedOn |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   UpdatedOn s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2:  s |3:   UpdatedOn s |4:   UpdatedOn  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   UpdatedOn st
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: st |3:   UpdatedOn st |4:   UpdatedOn s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   UpdatedOn str
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: tr |3:   UpdatedOn str |4:   UpdatedOn st |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   UpdatedOn string
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: ring |3:   UpdatedOn string |4:   UpdatedOn str |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   UpdatedOn string
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  UpdatedOn string |3:    |4:   UpdatedOn string |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   D
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  D |3:   D |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   De
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: De |3:   De |4:   D |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Del
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: el |3:   Del |4:   De |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Dele
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: le |3:   Dele |4:   Del |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Delet
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: et |3:   Delet |4:   Dele |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Delete
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: te |3:   Delete |4:   Delet |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Deleted
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ed |3:   Deleted |4:   Delete |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   DeletedO
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: dO |3:   DeletedO |4:   Deleted |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   DeletedOn
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: On |3:   DeletedOn |4:   DeletedO |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   DeletedOn 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: n  |3:   DeletedOn  |4:   DeletedOn |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   DeletedOn s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2:  s |3:   DeletedOn s |4:   DeletedOn  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   DeletedOn st
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: st |3:   DeletedOn st |4:   DeletedOn s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   DeletedOn str
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: tr |3:   DeletedOn str |4:   DeletedOn st |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   DeletedOn string
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: ring |3:   DeletedOn string |4:   DeletedOn str |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   DeletedOn string 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: g  |3:   DeletedOn string  |4:   DeletedOn string |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: v
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: v |3: v |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: va
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: va |3: va |4: v |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: ar |3: var |4: va |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: r  |3: var  |4: var |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var p
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  p |3: var p |4: var  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: pr |3: var pr |4: var p |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var pro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ro |3: var pro |4: var pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var prod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: od |3: var prod |4: var pro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var produ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: du |3: var produ |4: var prod |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var produc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: uc |3: var produc |4: var produ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var product
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ct |3: var product |4: var produc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productL
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: tL |3: var productL |4: var product |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productLi
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: Li |3: var productLi |4: var productL |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productLis
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: is |3: var productLis |4: var productLi |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: st |3: var productList |4: var productLis |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: t  |3: var productList  |4: var productList |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList =
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2:  = |3: var productList = |4: var productList  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList = 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: =  |3: var productList =  |4: var productList = |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList = [
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2:  [ |3: var productList = [ |4: var productList =  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList = []*
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: []* |3: var productList = []* |4: var productList = [ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList = []*P
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: *P |3: var productList = []*P |4: var productList = []* |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList = []*Pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: Pr |3: var productList = []*Pr |4: var productList = []*P |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList = []*Pro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: ro |3: var productList = []*Pro |4: var productList = []*Pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList = []*Prod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: od |3: var productList = []*Prod |4: var productList = []*Pro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList = []*Produ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: du |3: var productList = []*Produ |4: var productList = []*Prod |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList = []*Produc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: uc |3: var productList = []*Produc |4: var productList = []*Produ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList = []*Product
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: ct |3: var productList = []*Product |4: var productList = []*Produc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList = []*Product 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: t  |3: var productList = []*Product  |4: var productList = []*Product |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList = []*Product
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: t  |3: var productList = []*Product |4: var productList = []*Product  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: var productList = []*Product{
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: t{ |3: var productList = []*Product{ |4: var productList = []*Product |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: ar productList = []*Product{ |3:    |4: var productList = []*Product{ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   &
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  & |3:   & |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   &P
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: &P |3:   &P |4:   & |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   &Pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: Pr |3:   &Pr |4:   &P |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   &Pro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ro |3:   &Pro |4:   &Pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   &Prod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: od |3:   &Prod |4:   &Pro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   &Produ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: du |3:   &Produ |4:   &Prod |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   &Produc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: uc |3:   &Produc |4:   &Produ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   &Product
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: ct |3:   &Product |4:   &Produc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   &Product{
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: t{ |3:   &Product{ |4:   &Product |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: Product{ |3:      |4:   &Product{ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     I
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  I |3:     I |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ID
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ID |3:     ID |4:     I |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ID:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: D: |3:     ID: |4:     ID |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ID:1
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: :1 |3:     ID:1 |4:     ID: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ID:1,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 9
󰘫  |1: delta |2: 1, |3:     ID:1, |4:     ID:1 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  ID:1, |3:      |4:     ID:1, |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     N
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  N |3:     N |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Na
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: Na |3:     Na |4:     N |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Nam
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: am |3:     Nam |4:     Na |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: me |3:     Name |4:     Nam |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: e: |3:     Name: |4:     Name |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: :" |3:     Name:" |4:     Name: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"L
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: "L |3:     Name:"L |4:     Name:" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"La
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: La |3:     Name:"La |4:     Name:"L |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Lat
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: at |3:     Name:"Lat |4:     Name:"La |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Latt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: tt |3:     Name:"Latt |4:     Name:"Lat |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Latte
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: te |3:     Name:"Latte |4:     Name:"Latt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Latte",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: e", |3:     Name:"Latte", |4:     Name:"Latte |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  Name:"Latte", |3:      |4:     Name:"Latte", |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     D
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  D |3:     D |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     De
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: De |3:     De |4:     D |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Des
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: es |3:     Des |4:     De |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Desc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: sc |3:     Desc |4:     Des |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Descr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: cr |3:     Descr |4:     Desc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Descri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: ri |3:     Descri |4:     Descr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Descrip
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ip |3:     Descrip |4:     Descri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Descript
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: pt |3:     Descript |4:     Descrip |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: tion |3:     Description |4:     Descript |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: n: |3:     Description: |4:     Description |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: :" |3:     Description:" |4:     Description: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"RS
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: "RS |3:     Description:"RS |4:     Description:" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"RSr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: Sr |3:     Description:"RSr |4:     Description:"RS |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"RSro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: ro |3:     Description:"RSro |4:     Description:"RSr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"RSr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: ro |3:     Description:"RSr |4:     Description:"RSro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"RS
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: Sr |3:     Description:"RS |4:     Description:"RSr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: RS |3:     Description:"R |4:     Description:"RS |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: "R |3:     Description:" |4:     Description:"R |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"F
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: "F |3:     Description:"F |4:     Description:" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Fr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: Fr |3:     Description:"Fr |4:     Description:"F |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Fro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: ro |3:     Description:"Fro |4:     Description:"Fr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frot
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: ot |3:     Description:"Frot |4:     Description:"Fro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Froth
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: th |3:     Description:"Froth |4:     Description:"Frot |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frothy
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: hy |3:     Description:"Frothy |4:     Description:"Froth |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frothy 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: y  |3:     Description:"Frothy  |4:     Description:"Frothy |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frothy C
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2:  C |3:     Description:"Frothy C |4:     Description:"Frothy  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frothy Co
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: Co |3:     Description:"Frothy Co |4:     Description:"Frothy C |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frothy C
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: Co |3:     Description:"Frothy C |4:     Description:"Frothy Co |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frothy 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2:  C |3:     Description:"Frothy  |4:     Description:"Frothy C |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frothy c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2:  c |3:     Description:"Frothy c |4:     Description:"Frothy  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frothy co
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: co |3:     Description:"Frothy co |4:     Description:"Frothy c |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frothy cof
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: of |3:     Description:"Frothy cof |4:     Description:"Frothy co |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frothy co
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: of |3:     Description:"Frothy co |4:     Description:"Frothy cof |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frothy cof
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: of |3:     Description:"Frothy cof |4:     Description:"Frothy co |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frothy coff
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: ff |3:     Description:"Frothy coff |4:     Description:"Frothy cof |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frothy coffe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: fe |3:     Description:"Frothy coffe |4:     Description:"Frothy coff |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frothy coffee
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2: ee |3:     Description:"Frothy coffee |4:     Description:"Frothy coffe |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Frothy coffee",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 32
󰘫  |1: delta |2: e", |3:     Description:"Frothy coffee", |4:     Description:"Frothy coffee |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  Description:"Frothy coffee", |3:      |4:     Description:"Frothy coffee", |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  S |3:     S |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SN
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: SN |3:     SN |4:     S |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: SN |3:     S |4:     SN |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SK
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: SK |3:     SK |4:     S |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: KU |3:     SKU |4:     SK |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: U: |3:     SKU: |4:     SKU |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: :  |3:     SKU:  |4:     SKU: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:  " |3:     SKU: " |4:     SKU:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "a
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: "a |3:     SKU: "a |4:     SKU: " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "ab
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ab |3:     SKU: "ab |4:     SKU: "a |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "abr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: br |3:     SKU: "abr |4:     SKU: "ab |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "ab
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: br |3:     SKU: "ab |4:     SKU: "abr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "abc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: bc |3:     SKU: "abc |4:     SKU: "ab |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "abc3
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: c3 |3:     SKU: "abc3 |4:     SKU: "abc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "abc32
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: 32 |3:     SKU: "abc32 |4:     SKU: "abc3 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "abc323
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: 23 |3:     SKU: "abc323 |4:     SKU: "abc32 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "abc323",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: 3", |3:     SKU: "abc323", |4:     SKU: "abc323 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  SKU: "abc323", |3:      |4:     SKU: "abc323", |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     C
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  C |3:     C |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Cr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: Cr |3:     Cr |4:     C |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Cre
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: re |3:     Cre |4:     Cr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Crea
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ea |3:     Crea |4:     Cre |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Creat
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: at |3:     Creat |4:     Crea |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Create
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: te |3:     Create |4:     Creat |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Created
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ed |3:     Created |4:     Create |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedO
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: dO |3:     CreatedO |4:     Created |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: On |3:     CreatedOn |4:     CreatedO |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: n  |3:     CreatedOn  |4:     CreatedOn |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: n  |3:     CreatedOn |4:     CreatedOn  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: n: |3:     CreatedOn: |4:     CreatedOn |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: :  |3:     CreatedOn:  |4:     CreatedOn: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2:  t |3:     CreatedOn: t |4:     CreatedOn:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: ti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: ti |3:     CreatedOn: ti |4:     CreatedOn: t |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: tim
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: im |3:     CreatedOn: tim |4:     CreatedOn: ti |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: me |3:     CreatedOn: time |4:     CreatedOn: tim |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: e. |3:     CreatedOn: time. |4:     CreatedOn: time |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.N
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: .N |3:     CreatedOn: time.N |4:     CreatedOn: time. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.No
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: No |3:     CreatedOn: time.No |4:     CreatedOn: time.N |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: ow |3:     CreatedOn: time.Now |4:     CreatedOn: time.No |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 24
󰘫  |1: delta |2: w( |3:     CreatedOn: time.Now( |4:     CreatedOn: time.Now |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now()>
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: ()> |3:     CreatedOn: time.Now()> |4:     CreatedOn: time.Now( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now()
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: )> |3:     CreatedOn: time.Now() |4:     CreatedOn: time.Now()> |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now().
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: ). |3:     CreatedOn: time.Now(). |4:     CreatedOn: time.Now() |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now().U
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: .U |3:     CreatedOn: time.Now().U |4:     CreatedOn: time.Now(). |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now().UT
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: UT |3:     CreatedOn: time.Now().UT |4:     CreatedOn: time.Now().U |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now().UTC
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: TC |3:     CreatedOn: time.Now().UTC |4:     CreatedOn: time.Now().UT |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now().UTC(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: C( |3:     CreatedOn: time.Now().UTC( |4:     CreatedOn: time.Now().UTC |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now().UTC().
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: (). |3:     CreatedOn: time.Now().UTC(). |4:     CreatedOn: time.Now().UTC( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now().UTC().S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 33
󰘫  |1: delta |2: .S |3:     CreatedOn: time.Now().UTC().S |4:     CreatedOn: time.Now().UTC(). |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now().UTC().ST
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: ST |3:     CreatedOn: time.Now().UTC().ST |4:     CreatedOn: time.Now().UTC().S |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now().UTC().S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 33
󰘫  |1: delta |2: ST |3:     CreatedOn: time.Now().UTC().S |4:     CreatedOn: time.Now().UTC().ST |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now().UTC().St
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: St |3:     CreatedOn: time.Now().UTC().St |4:     CreatedOn: time.Now().UTC().S |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now().UTC().Str
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 35
󰘫  |1: delta |2: tr |3:     CreatedOn: time.Now().UTC().Str |4:     CreatedOn: time.Now().UTC().St |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now().UTC().String
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 38
󰘫  |1: delta |2: ring |3:     CreatedOn: time.Now().UTC().String |4:     CreatedOn: time.Now().UTC().Str |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now().UTC().String(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 39
󰘫  |1: delta |2: g( |3:     CreatedOn: time.Now().UTC().String( |4:     CreatedOn: time.Now().UTC().String |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     CreatedOn: time.Now().UTC().String(),
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 41
󰘫  |1: delta |2: (), |3:     CreatedOn: time.Now().UTC().String(), |4:     CreatedOn: time.Now().UTC().String( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Created
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2:     Created |3:     Created |4:  |5: {}

󰘫  |1: mode:    |2: niI
󰘫  |1: mode:  niI  |2: niI
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     U
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  U |3:     U |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Up
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: Up |3:     Up |4:     U |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Upd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: pd |3:     Upd |4:     Up |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Upda
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: da |3:     Upda |4:     Upd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Updat
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: at |3:     Updat |4:     Upda |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Update
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: te |3:     Update |4:     Updat |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Updated
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ed |3:     Updated |4:     Update |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Update
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:     Update |3:     Update |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   }
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:   } |3:   } |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   },
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: }, |3:   }, |4:   } |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   },
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2:   }, |3:   }, |4:   }, |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ID:1
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2:     ID:1 |3:     ID:1 |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ID:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: :1 |3:     ID: |4:     ID:1 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ID:2
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: :2 |3:     ID:2 |4:     ID: |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:     Name:" |3:     Name:" |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"E
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: "E |3:     Name:"E |4:     Name:" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Es
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: Es |3:     Name:"Es |4:     Name:"E |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Esp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: sp |3:     Name:"Esp |4:     Name:"Es |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Espr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: pr |3:     Name:"Espr |4:     Name:"Esp |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Espre
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: re |3:     Name:"Espre |4:     Name:"Espr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Espres
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: es |3:     Name:"Espres |4:     Name:"Espre |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Espress
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: ss |3:     Name:"Espress |4:     Name:"Espres |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Espres
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: ss |3:     Name:"Espres |4:     Name:"Espress |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Espre
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: es |3:     Name:"Espre |4:     Name:"Espres |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Espr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: re |3:     Name:"Espr |4:     Name:"Espre |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Esp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: pr |3:     Name:"Esp |4:     Name:"Espr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Es
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: sp |3:     Name:"Es |4:     Name:"Esp |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Ess
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: ss |3:     Name:"Ess |4:     Name:"Es |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Essp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: sp |3:     Name:"Essp |4:     Name:"Ess |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Esspr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: pr |3:     Name:"Esspr |4:     Name:"Essp |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Esspre
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: re |3:     Name:"Esspre |4:     Name:"Esspr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Esspres
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: es |3:     Name:"Esspres |4:     Name:"Esspre |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Esspress
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: ss |3:     Name:"Esspress |4:     Name:"Esspres |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Name:"Esspresso
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: so |3:     Name:"Esspresso |4:     Name:"Esspress |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2:     Description:" |3:     Description:" |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: "S |3:     Description:"S |4:     Description:" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Sh
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: Sh |3:     Description:"Sh |4:     Description:"S |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Sho
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: ho |3:     Description:"Sho |4:     Description:"Sh |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Shor
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: or |3:     Description:"Shor |4:     Description:"Sho |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: rt |3:     Description:"Short |4:     Description:"Shor |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: t  |3:     Description:"Short  |4:     Description:"Short |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short and
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2:  and |3:     Description:"Short and |4:     Description:"Short  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short and 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: d  |3:     Description:"Short and  |4:     Description:"Short and |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short and s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2:  s |3:     Description:"Short and s |4:     Description:"Short and  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short and st
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: st |3:     Description:"Short and st |4:     Description:"Short and s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short and str
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2: tr |3:     Description:"Short and str |4:     Description:"Short and st |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short and stro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2: ro |3:     Description:"Short and stro |4:     Description:"Short and str |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short and stron
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: on |3:     Description:"Short and stron |4:     Description:"Short and stro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short and strong
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 33
󰘫  |1: delta |2: ng |3:     Description:"Short and strong |4:     Description:"Short and stron |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short and strong 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: g  |3:     Description:"Short and strong  |4:     Description:"Short and strong |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short and strong c
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 35
󰘫  |1: delta |2:  c |3:     Description:"Short and strong c |4:     Description:"Short and strong  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short and strong co
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 36
󰘫  |1: delta |2: co |3:     Description:"Short and strong co |4:     Description:"Short and strong c |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short and strong cof
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 37
󰘫  |1: delta |2: of |3:     Description:"Short and strong cof |4:     Description:"Short and strong co |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short and strong coff
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 38
󰘫  |1: delta |2: ff |3:     Description:"Short and strong coff |4:     Description:"Short and strong cof |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short and strong coffe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 39
󰘫  |1: delta |2: fe |3:     Description:"Short and strong coffe |4:     Description:"Short and strong coff |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Description:"Short and strong coffee
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 40
󰘫  |1: delta |2: ee |3:     Description:"Short and strong coffee |4:     Description:"Short and strong coffe |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:     SKU: " |3:     SKU: " |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: "f |3:     SKU: "f |4:     SKU: " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "fj
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: fj |3:     SKU: "fj |4:     SKU: "f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "fjd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: jd |3:     SKU: "fjd |4:     SKU: "fj |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "fjd3
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: d3 |3:     SKU: "fjd3 |4:     SKU: "fjd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     SKU: "fjd34
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: 34 |3:     SKU: "fjd34 |4:     SKU: "fjd3 |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   P
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  P |3:   P |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  P |3:    |4:   P |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:     |3:      |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     P
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  P |3:     P |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: Pr |3:     Pr |4:     P |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Pri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ri |3:     Pri |4:     Pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Pric
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ic |3:     Pric |4:     Pri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Price
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ce |3:     Price |4:     Pric |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Price:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: e: |3:     Price: |4:     Price |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Price:1
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: :1 |3:     Price:1 |4:     Price: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Price:1.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: 1. |3:     Price:1. |4:     Price:1 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Price:1.9
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: .9 |3:     Price:1.9 |4:     Price:1. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Price:1.99
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: 99 |3:     Price:1.99 |4:     Price:1.9 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Price:1.99,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: 9, |3:     Price:1.99, |4:     Price:1.99 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:     |3:      |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     P
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  P |3:     P |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: Pr |3:     Pr |4:     P |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Pri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ri |3:     Pri |4:     Pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Pric
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ic |3:     Pric |4:     Pri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Price
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ce |3:     Price |4:     Pric |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Price:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: e: |3:     Price: |4:     Price |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Price: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: :  |3:     Price:  |4:     Price: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Price: 2
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2:  2 |3:     Price: 2 |4:     Price:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Price: 2.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: 2. |3:     Price: 2. |4:     Price: 2 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Price: 2.4
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: .4 |3:     Price: 2.4 |4:     Price: 2. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Price: 2.45
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: 45 |3:     Price: 2.45 |4:     Price: 2.4 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Price: 2.45,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: 5, |3:     Price: 2.45, |4:     Price: 2.45 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: }
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: } |3: } |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: },
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 2
󰘫  |1: delta |2: }, |3: }, |4: } |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: }
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: } |3: } |4:  |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: packag
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: packag |3: packag |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2: packag |3:  |4: packag |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: }
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: } |3: } |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: }}
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: }} |3: }} |4: } |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: }}I
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: }I |3: }}I |4: }} |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: }}
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: }I |3: }} |4: }}I |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2: }} |3:  |4: }} |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: }
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: } |3: } |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: },
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 2
󰘫  |1: delta |2: }, |3: }, |4: } |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: p
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: p |3: p |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pa
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: pa |3: pa |4: p |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pac
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: ac |3: pac |4: pa |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pack
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ck |3: pack |4: pac |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: packa
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: ka |3: packa |4: pack |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: packag
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ag |3: packag |4: packa |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ge |3: package |4: packag |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: e  |3: package  |4: package |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2:  h |3: package h |4: package  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package handlers
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: handlers |3: package handlers |4: package h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package handlers
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package handlers
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: package handlers |3: package handlers |4: package handlers |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2: package handlers |3:  |4: package handlers |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: t |3: t |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: ty
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: ty |3: ty |4: t |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: typ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: yp |3: typ |4: ty |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: typh
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ph |3: typh |4: typ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: typ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: ph |3: typ |4: typh |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: pe |3: type |4: typ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: typ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: pe |3: typ |4: type |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: pe |3: type |4: typ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: e  |3: type  |4: type |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type P
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  P |3: type P |4: type  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: Pr |3: type Pr |4: type P |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Pro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ro |3: type Pro |4: type Pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Prod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: od |3: type Prod |4: type Pro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Produ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: du |3: type Produ |4: type Prod |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Produc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: uc |3: type Produc |4: type Produ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Product
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ct |3: type Product |4: type Produc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Products
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: ts |3: type Products |4: type Product |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Products 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: s  |3: type Products  |4: type Products |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Products {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2:  { |3: type Products { |4: type Products  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: ype Products { |3:    |4: type Products { |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Products 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: type Products  |3: type Products  |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Products s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2:  s |3: type Products s |4: type Products  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Products st
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: st |3: type Products st |4: type Products s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Products str
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: tr |3: type Products str |4: type Products st |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Products stru
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: ru |3: type Products stru |4: type Products str |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Products struc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: uc |3: type Products struc |4: type Products stru |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Products struct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: ct |3: type Products struct |4: type Products struc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Products struct 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: t  |3: type Products struct  |4: type Products struct |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: ype Products struct  |3:    |4: type Products struct  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  l |3:   l |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: l  |3:   l  |4:   l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  * |3:   l * |4:   l  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: *l |3:   l *l |4:   l * |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: lo |3:   l *lo |4:   l *l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: og |3:   l *log |4:   l *lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: g. |3:   l *log. |4:   l *log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.L
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: .L |3:   l *log.L |4:   l *log. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: Lo |3:   l *log.Lo |4:   l *log.L |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: og |3:   l *log.Log |4:   l *log.Lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Logg
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: gg |3:   l *log.Logg |4:   l *log.Log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Logge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: ge |3:   l *log.Logge |4:   l *log.Logg |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Logger
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: er |3:   l *log.Logger |4:   l *log.Logge |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Logger
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Logger
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: f |3: f |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: fu |3: fu |4: f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: un |3: fun |4: fu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: nc |3: func |4: fun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: c  |3: func  |4: func |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func N
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  N |3: func N |4: func  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func Ne
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: Ne |3: func Ne |4: func N |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func New
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ew |3: func New |4: func Ne |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewP
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: wP |3: func NewP |4: func New |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewPr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: Pr |3: func NewPr |4: func NewP |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewPro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ro |3: func NewPro |4: func NewPr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: od |3: func NewProd |4: func NewPro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProdu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: du |3: func NewProdu |4: func NewProd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProduc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: uc |3: func NewProduc |4: func NewProdu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProduct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: ct |3: func NewProduct |4: func NewProduc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: ts |3: func NewProducts |4: func NewProduct |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: s( |3: func NewProducts( |4: func NewProducts |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: (l |3: func NewProducts(l |4: func NewProducts( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: l* |3: func NewProducts(l* |4: func NewProducts(l |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: *l |3: func NewProducts(l*l |4: func NewProducts(l* |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: lo |3: func NewProducts(l*lo |4: func NewProducts(l*l |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: og |3: func NewProducts(l*log |4: func NewProducts(l*lo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: g. |3: func NewProducts(l*log. |4: func NewProducts(l*log |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.L
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: .L |3: func NewProducts(l*log.L |4: func NewProducts(l*log. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: Lo |3: func NewProducts(l*log.Lo |4: func NewProducts(l*log.L |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: og |3: func NewProducts(l*log.Log |4: func NewProducts(l*log.Lo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Logg
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: gg |3: func NewProducts(l*log.Logg |4: func NewProducts(l*log.Log |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Logge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: ge |3: func NewProducts(l*log.Logge |4: func NewProducts(l*log.Logg |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Logger
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: er |3: func NewProducts(l*log.Logger |4: func NewProducts(l*log.Logge |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Logger) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2: r)  |3: func NewProducts(l*log.Logger)  |4: func NewProducts(l*log.Logger |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Logger) *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2:  * |3: func NewProducts(l*log.Logger) * |4: func NewProducts(l*log.Logger)  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Logger) *P
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 33
󰘫  |1: delta |2: *P |3: func NewProducts(l*log.Logger) *P |4: func NewProducts(l*log.Logger) * |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Logger) *Pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: Pr |3: func NewProducts(l*log.Logger) *Pr |4: func NewProducts(l*log.Logger) *P |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Logger) *Pro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 35
󰘫  |1: delta |2: ro |3: func NewProducts(l*log.Logger) *Pro |4: func NewProducts(l*log.Logger) *Pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Logger) *Prod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 36
󰘫  |1: delta |2: od |3: func NewProducts(l*log.Logger) *Prod |4: func NewProducts(l*log.Logger) *Pro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Logger) *Produ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 37
󰘫  |1: delta |2: du |3: func NewProducts(l*log.Logger) *Produ |4: func NewProducts(l*log.Logger) *Prod |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Logger) *Produc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 38
󰘫  |1: delta |2: uc |3: func NewProducts(l*log.Logger) *Produc |4: func NewProducts(l*log.Logger) *Produ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Logger) *Product
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 39
󰘫  |1: delta |2: ct |3: func NewProducts(l*log.Logger) *Product |4: func NewProducts(l*log.Logger) *Produc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Logger) *Products
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 40
󰘫  |1: delta |2: ts |3: func NewProducts(l*log.Logger) *Products |4: func NewProducts(l*log.Logger) *Product |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Logger) *Products 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 41
󰘫  |1: delta |2: s  |3: func NewProducts(l*log.Logger) *Products  |4: func NewProducts(l*log.Logger) *Products |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts(l*log.Logger) *Products {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 42
󰘫  |1: delta |2:  { |3: func NewProducts(l*log.Logger) *Products { |4: func NewProducts(l*log.Logger) *Products  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: unc NewProducts(l*log.Logger) *Products { |3:    |4: func NewProducts(l*log.Logger) *Products { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  r |3:   r |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: re |3:   re |4:   r |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ret
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: et |3:   ret |4:   re |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   retu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: tu |3:   retu |4:   ret |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   retur
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ur |3:   retur |4:   retu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: rn |3:   return |4:   retur |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: n  |3:   return  |4:   return |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:  & |3:   return & |4:   return  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &P
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: &P |3:   return &P |4:   return & |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: Pr |3:   return &Pr |4:   return &P |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Pro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: ro |3:   return &Pro |4:   return &Pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Prod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: od |3:   return &Prod |4:   return &Pro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Products{
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: ducts{ |3:   return &Products{ |4:   return &Prod |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Products{l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: {l |3:   return &Products{l |4:   return &Products{ |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: f |3: f |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: fu |3: fu |4: f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: un |3: fun |4: fu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: nc |3: func |4: fun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: c  |3: func  |4: func |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  ( |3: func ( |4: func  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: (p |3: func (p |4: func ( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: p* |3: func (p* |4: func (p |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*At
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: *At |3: func (p*At |4: func (p* |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Atr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: tr |3: func (p*Atr |4: func (p*At |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Atro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ro |3: func (p*Atro |4: func (p*Atr |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Atrod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: od |3: func (p*Atrod |4: func (p*Atro |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Atro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: od |3: func (p*Atro |4: func (p*Atrod |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Atr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ro |3: func (p*Atr |4: func (p*Atro |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*At
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: tr |3: func (p*At |4: func (p*Atr |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*A
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: At |3: func (p*A |4: func (p*At |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: *A |3: func (p* |4: func (p*A |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*P
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: *P |3: func (p*P |4: func (p* |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: Pr |3: func (p*Pr |4: func (p*P |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Pro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ro |3: func (p*Pro |4: func (p*Pr |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Prod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: od |3: func (p*Prod |4: func (p*Pro |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Produ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: du |3: func (p*Produ |4: func (p*Prod |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Produc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: uc |3: func (p*Produc |4: func (p*Produ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Product
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ct |3: func (p*Product |4: func (p*Produc |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ts |3: func (p*Products |4: func (p*Product |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: s)  |3: func (p*Products)  |4: func (p*Products |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2:  S |3: func (p*Products) S |4: func (p*Products)  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) Se
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: Se |3: func (p*Products) Se |4: func (p*Products) S |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) Ser
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: er |3: func (p*Products) Ser |4: func (p*Products) Se |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) Serv
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: rv |3: func (p*Products) Serv |4: func (p*Products) Ser |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) Serve
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: ve |3: func (p*Products) Serve |4: func (p*Products) Serv |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeH
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: eH |3: func (p*Products) ServeH |4: func (p*Products) Serve |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHT
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: HT |3: func (p*Products) ServeHT |4: func (p*Products) ServeH |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTT
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: TT |3: func (p*Products) ServeHTT |4: func (p*Products) ServeHT |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: TP |3: func (p*Products) ServeHTTP |4: func (p*Products) ServeHTT |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: func (p*Products) ServeHTTP |3: func (p*Products) ServeHTTP |4: func (p*Products) ServeHTTP |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: P( |3: func (p*Products) ServeHTTP( |4: func (p*Products) ServeHTTP |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: (r |3: func (p*Products) ServeHTTP(r |4: func (p*Products) ServeHTTP( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: rw |3: func (p*Products) ServeHTTP(rw |4: func (p*Products) ServeHTTP(r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: w  |3: func (p*Products) ServeHTTP(rw  |4: func (p*Products) ServeHTTP(rw |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2:  h |3: func (p*Products) ServeHTTP(rw h |4: func (p*Products) ServeHTTP(rw  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: ht |3: func (p*Products) ServeHTTP(rw ht |4: func (p*Products) ServeHTTP(rw h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: tt |3: func (p*Products) ServeHTTP(rw htt |4: func (p*Products) ServeHTTP(rw ht |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: tp |3: func (p*Products) ServeHTTP(rw http |4: func (p*Products) ServeHTTP(rw htt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: p. |3: func (p*Products) ServeHTTP(rw http. |4: func (p*Products) ServeHTTP(rw http |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: .R |3: func (p*Products) ServeHTTP(rw http.R |4: func (p*Products) ServeHTTP(rw http. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: Re |3: func (p*Products) ServeHTTP(rw http.Re |4: func (p*Products) ServeHTTP(rw http.R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: esponseWriter |3: func (p*Products) ServeHTTP(rw http.ResponseWriter |4: func (p*Products) ServeHTTP(rw http.Re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: r, |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, |4: func (p*Products) ServeHTTP(rw http.ResponseWriter |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: ,  |3: func (p*Products) ServeHTTP(rw http.ResponseWriter,  |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2:  h |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, h |4: func (p*Products) ServeHTTP(rw http.ResponseWriter,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, h 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: h  |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, h  |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, h O
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2:  O |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, h O |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, h  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, h 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2:  O |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, h  |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, h O |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2:  * |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, h * |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, h  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: *h |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *h |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, h * |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: ht |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *ht |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: tt |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *htt |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *ht |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: tp |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *htt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: p. |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http. |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: .R |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.R |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: Re |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.Re |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.Request
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 51
󰘫  |1: delta |2: equest |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.Request |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.Re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.Request) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 69
󰘫  |1: delta |2: t)  |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.Request)  |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.Request |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.Request) {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 70
󰘫  |1: delta |2:  { |3: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.Request) { |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.Request)  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: unc (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.Request) { |3:    |4: func (p*Products) ServeHTTP(rw http.ResponseWriter, h *http.Request) { |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: f |3: f |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: fu |3: fu |4: f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: un |3: fun |4: fu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: nc |3: func |4: fun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: c  |3: func  |4: func |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func G
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  G |3: func G |4: func  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func Ge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: Ge |3: func Ge |4: func G |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func Get
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: et |3: func Get |4: func Ge |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetAt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: tAt |3: func GetAt |4: func Get |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetAtr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: tr |3: func GetAtr |4: func GetAt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetAtro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ro |3: func GetAtro |4: func GetAtr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetAtrod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: od |3: func GetAtrod |4: func GetAtro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetAtrodu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: du |3: func GetAtrodu |4: func GetAtrod |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetAtroduc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: uc |3: func GetAtroduc |4: func GetAtrodu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetAtroduct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: ct |3: func GetAtroduct |4: func GetAtroduc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetAtroduc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: ct |3: func GetAtroduc |4: func GetAtroduct |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetAtrodu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: uc |3: func GetAtrodu |4: func GetAtroduc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetAtrod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: du |3: func GetAtrod |4: func GetAtrodu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetAtro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: od |3: func GetAtro |4: func GetAtrod |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetAtr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ro |3: func GetAtr |4: func GetAtro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetAt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: tr |3: func GetAt |4: func GetAtr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetA
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: At |3: func GetA |4: func GetAt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func Get
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: tA |3: func Get |4: func GetA |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetP
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: tP |3: func GetP |4: func Get |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetPr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: Pr |3: func GetPr |4: func GetP |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetPro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ro |3: func GetPro |4: func GetPr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: od |3: func GetProd |4: func GetPro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProdu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: du |3: func GetProdu |4: func GetProd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProduc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: uc |3: func GetProduc |4: func GetProdu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProduct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: ct |3: func GetProduct |4: func GetProduc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: ts |3: func GetProducts |4: func GetProduct |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 17
󰘫  |1: delta |2: s( |3: func GetProducts( |4: func GetProducts |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: ()  |3: func GetProducts()  |4: func GetProducts( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() [
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2:  [ |3: func GetProducts() [ |4: func GetProducts()  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() []P
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: []P |3: func GetProducts() []P |4: func GetProducts() [ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() []Pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: Pr |3: func GetProducts() []Pr |4: func GetProducts() []P |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() []Pro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: ro |3: func GetProducts() []Pro |4: func GetProducts() []Pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() []Prod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: od |3: func GetProducts() []Prod |4: func GetProducts() []Pro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() []Produ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: du |3: func GetProducts() []Produ |4: func GetProducts() []Prod |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() []Produc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: uc |3: func GetProducts() []Produc |4: func GetProducts() []Produ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() []Product
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: ct |3: func GetProducts() []Product |4: func GetProducts() []Produc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() []Product 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: t  |3: func GetProducts() []Product  |4: func GetProducts() []Product |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() []Product {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2:  { |3: func GetProducts() []Product { |4: func GetProducts() []Product  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: unc GetProducts() []Product { |3:    |4: func GetProducts() []Product { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  r |3:   r |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: re |3:   re |4:   r |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ret
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: et |3:   ret |4:   re |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   retu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: tu |3:   retu |4:   ret |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   retur
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ur |3:   retur |4:   retu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: rn |3:   return |4:   retur |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: n  |3:   return  |4:   return |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return G
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:  G |3:   return G |4:   return  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return Ge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: Ge |3:   return Ge |4:   return G |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return Get
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: et |3:   return Get |4:   return Ge |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetP
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: tP |3:   return GetP |4:   return Get |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetPr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: Pr |3:   return GetPr |4:   return GetP |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetPro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: ro |3:   return GetPro |4:   return GetPr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetProd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: od |3:   return GetProd |4:   return GetPro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetProdu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: du |3:   return GetProdu |4:   return GetProd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetProduc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: uc |3:   return GetProduc |4:   return GetProdu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetProduct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: ct |3:   return GetProduct |4:   return GetProduc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetProducts
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: ts |3:   return GetProducts |4:   return GetProduct |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetProducts(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 21
󰘫  |1: delta |2: s( |3:   return GetProducts( |4:   return GetProducts |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 17,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 21,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/product-api/data/products.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = ""
      },
      label = "GetProducts() []Product"
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  return GetProducts(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: no sig
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetProducts(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 21
󰘫  |1: delta |2:   return GetProducts( |3:   return GetProducts( |4:   return GetProducts( |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 17,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 21,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/product-api/data/products.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = ""
      },
      label = "GetProducts() []Product"
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "  return GetProducts(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: no sig
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetProducts
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: s( |3:   return GetProducts |4:   return GetProducts( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetProductsi
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: si |3:   return GetProductsi |4:   return GetProducts |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetProducts
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: si |3:   return GetProducts |4:   return GetProductsi |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetProduct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: ts |3:   return GetProduct |4:   return GetProducts |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetProduc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: ct |3:   return GetProduc |4:   return GetProduct |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetProdu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: uc |3:   return GetProdu |4:   return GetProduc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetProd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: du |3:   return GetProd |4:   return GetProdu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetPro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: od |3:   return GetPro |4:   return GetProd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetPr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: ro |3:   return GetPr |4:   return GetPro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return GetP
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: Pr |3:   return GetP |4:   return GetPr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return Get
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: tP |3:   return Get |4:   return GetP |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return Ge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: et |3:   return Ge |4:   return Get |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return G
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: Ge |3:   return G |4:   return Ge |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2:  G |3:   return  |4:   return G |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return P
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:  P |3:   return P |4:   return  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return Pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: Pr |3:   return Pr |4:   return P |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return Pro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ro |3:   return Pro |4:   return Pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return Prod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: od |3:   return Prod |4:   return Pro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return Produ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: du |3:   return Produ |4:   return Prod |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return Prod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: du |3:   return Prod |4:   return Produ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return Pro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: od |3:   return Pro |4:   return Prod |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return Pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ro |3:   return Pr |4:   return Pro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return P
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: Pr |3:   return P |4:   return Pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2:  P |3:   return  |4:   return P |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return p
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:  p |3:   return p |4:   return  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: pr |3:   return pr |4:   return p |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return pro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ro |3:   return pro |4:   return pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return prod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: od |3:   return prod |4:   return pro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return produ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: du |3:   return produ |4:   return prod |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return produc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: uc |3:   return produc |4:   return produ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return product
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: ct |3:   return product |4:   return produc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return productList
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: tList |3:   return productList |4:   return product |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return product
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: tList |3:   return product |4:   return productList |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return product
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2:   return product |3:   return product |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return productL
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: tL |3:   return productL |4:   return product |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return productLi
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: Li |3:   return productLi |4:   return productL |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return productLis
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: is |3:   return productLis |4:   return productLi |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return productList
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: st |3:   return productList |4:   return productLis |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return productLis
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2:   return productLis |3:   return productLis |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() [
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: func GetProducts() [ |3: func GetProducts() [ |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() [*
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: [* |3: func GetProducts() [* |4: func GetProducts() [ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() [
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: [* |3: func GetProducts() [ |4: func GetProducts() [* |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() [ 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: [  |3: func GetProducts() [  |4: func GetProducts() [ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() [ o
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  o |3: func GetProducts() [ o |4: func GetProducts() [  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() [ 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:  o |3: func GetProducts() [  |4: func GetProducts() [ o |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() [
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: [  |3: func GetProducts() [ |4: func GetProducts() [  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func GetProducts() []*
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: []* |3: func GetProducts() []* |4: func GetProducts() [ |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  l |3:   l |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: lp |3:   lp |4:   l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: p  |3:   lp  |4:   lp |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  : |3:   lp : |4:   lp  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: := |3:   lp := |4:   lp : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: =  |3:   lp :=  |4:   lp := |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := d
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2:  d |3:   lp := d |4:   lp :=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := da
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: da |3:   lp := da |4:   lp := d |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := d
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: da |3:   lp := d |4:   lp := da |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2:  d |3:   lp :=  |4:   lp := d |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: =  |3:   lp := |4:   lp :=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: := |3:   lp : |4:   lp := |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp :i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: :i |3:   lp :i |4:   lp : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: :i |3:   lp : |4:   lp :i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  : |3:   lp  |4:   lp : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: p  |3:   lp |4:   lp  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: lp |3:   l |4:   lp |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   li
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: li |3:   li |4:   l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lis
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: is |3:   lis |4:   li |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   list
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: st |3:   list |4:   lis |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lis
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: st |3:   lis |4:   list |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   li
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: is |3:   li |4:   lis |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: li |3:   l |4:   li |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: lp |3:   lp |4:   l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: p  |3:   lp  |4:   lp |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  : |3:   lp : |4:   lp  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp :?
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: :? |3:   lp :? |4:   lp : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: :? |3:   lp : |4:   lp :? |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: := |3:   lp := |4:   lp : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: =  |3:   lp :=  |4:   lp := |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := d
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2:  d |3:   lp := d |4:   lp :=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := da
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: da |3:   lp := da |4:   lp := d |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := dat
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: at |3:   lp := dat |4:   lp := da |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := data
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ta |3:   lp := data |4:   lp := dat |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := data.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: a. |3:   lp := data. |4:   lp := data |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := data.G
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: .G |3:   lp := data.G |4:   lp := data. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := data.Ge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: Ge |3:   lp := data.Ge |4:   lp := data.G |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := data.Get
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: et |3:   lp := data.Get |4:   lp := data.Ge |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := data.GetProducts
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: tProducts |3:   lp := data.GetProducts |4:   lp := data.Get |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := data.GetProducts(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: s( |3:   lp := data.GetProducts( |4:   lp := data.GetProducts |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := dat
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ta.GetProducts( |3:   lp := dat |4:   lp := data.GetProducts( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := data
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ta |3:   lp := data |4:   lp := dat |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := dat
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ta |3:   lp := dat |4:   lp := data |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lp := data.GetProducts(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2:   lp := data.GetProducts( |3:   lp := data.GetProducts( |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = ""
      },
      label = "GetProducts() []*data.Product"
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "  lp := data.GetProducts(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: no sig
󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   j
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  j |3:   j |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   js
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: js |3:   js |4:   j |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   jso
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: so |3:   jso |4:   js |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   json
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: on |3:   json |4:   jso |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   json.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: n. |3:   json. |4:   json |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   json.M
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: .M |3:   json.M |4:   json. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   json.Ma
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: Ma |3:   json.Ma |4:   json.M |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   json.Marshal
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: arshal |3:   json.Marshal |4:   json.Ma |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   json.Marshal
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2:   json.Marshal |3:   json.Marshal |4:   json.Marshal |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   json.Marshal(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: l( |3:   json.Marshal( |4:   json.Marshal |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Marshal returns the JSON encoding of v.\n\nMarshal traverses the value v recursively. If an encountered value implements the Marshaler interface and is not a nil pointer, Marshal calls its MarshalJSON method to produce JSON. If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead, Marshal calls its MarshalText method and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON.\n\nOtherwise, Marshal uses the following type-dependent default encodings:\n\nBoolean values encode as JSON booleans.\n\nFloating point, integer, and Number values encode as JSON numbers. NaN and +/-Inf values will return an \\[UnsupportedValueError].\n\nString values encode as JSON strings coerced to valid UTF-8, replacing invalid bytes with the Unicode replacement rune. So that the JSON will be safe to embed inside HTML \\<script> tags, the string is encoded using HTMLEscape, which replaces \"\\<\", \">\", \"&\", U+2028, and U+2029 are escaped to \"\\\\u003c\",\"\\\\u003e\", \"\\\\u0026\", \"\\\\u2028\", and \"\\\\u2029\". This replacement can be disabled when using an Encoder, by calling SetEscapeHTML(false).\n\nArray and slice values encode as JSON arrays, except that \\[]byte encodes as a base64-encoded string, and a nil slice encodes as the null JSON value.\n\nStruct values encode as JSON objects. Each exported struct field becomes a member of the object, using the field name as the object key, unless the field is omitted for one of the reasons given below.\n\nThe encoding of each struct field can be customized by the format string stored under the \"json\" key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.\n\nThe \"omitempty\" option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any empty array, slice, map, or string.\n\nAs a special case, if the field tag is \"-\", the field is always omitted. Note that a field with name \"-\" can still be generated using the tag \"-,\".\n\nExamples of struct field tags and their meanings:\n\n\t// Field appears in JSON as key \"myName\".\n\tField int `json:\"myName\"`\n\n\t// Field appears in JSON as key \"myName\" and\n\t// the field is omitted from the object if its value is empty,\n\t// as defined above.\n\tField int `json:\"myName,omitempty\"`\n\n\t// Field appears in JSON as key \"Field\" (the default), but\n\t// the field is skipped if empty.\n\t// Note the leading comma.\n\tField int `json:\",omitempty\"`\n\n\t// Field is ignored by this package.\n\tField int `json:\"-\"`\n\n\t// Field appears in JSON as key \"-\".\n\tField int `json:\"-,\"`\n\nThe \"string\" option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs:\n\n\tInt64String int64 `json:\",string\"`\n\nThe key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.\n\nAnonymous struct fields are usually marshaled as if their inner exported fields were fields in the outer struct, subject to the usual Go visibility rules amended as described in the next paragraph. An anonymous struct field with a name given in its JSON tag is treated as having that name, rather than being anonymous. An anonymous struct field of interface type is treated the same as having that type as its name, rather than being anonymous.\n\nThe Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply:\n\n1\\) Of those fields, if any are JSON-tagged, only tagged fields are considered, even if there are multiple untagged fields that would otherwise conflict.\n\n2\\) If there is exactly one field (tagged or not according to the first rule), that is selected.\n\n3\\) Otherwise there are multiple fields, and all are ignored; no error occurs.\n\nHandling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of an anonymous struct field in both current and earlier versions, give the field a JSON tag of \"-\".\n\nMap values encode as JSON objects. The map's key type must either be a string, an integer type, or implement encoding.TextMarshaler. The map keys are sorted and used as JSON object keys by applying the following rules, subject to the UTF-8 coercion described for string values above:\n\n  - keys of any string type are used directly\n  - encoding.TextMarshalers are marshaled\n  - integer keys are converted to strings\n\nPointer values encode as the value pointed to. A nil pointer encodes as the null JSON value.\n\nInterface values encode as the value contained in the interface. A nil interface value encodes as the null JSON value.\n\nChannel, complex, and function values cannot be encoded in JSON. Attempting to encode such a value causes Marshal to return an UnsupportedTypeError.\n\nJSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an error."
      },
      label = "Marshal(v any) ([]byte, error)",
      parameters = { {
          label = "v any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  json.Marshal(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Marshal returns the JSON encoding of v.\n\nMarshal traverses the value v recursively. If an encountered value implements the Marshaler interface and is not a nil pointer, Marshal calls its MarshalJSON method to produce JSON. If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead, Marshal calls its MarshalText method and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON.\n\nOtherwise, Marshal uses the following type-dependent default encodings:\n\nBoolean values encode as JSON booleans.\n\nFloating point, integer, and Number values encode as JSON numbers. NaN and +/-Inf values will return an \\[UnsupportedValueError].\n\nString values encode as JSON strings coerced to valid UTF-8, replacing invalid bytes with the Unicode replacement rune. So that the JSON will be safe to embed inside HTML \\<script> tags, the string is encoded using HTMLEscape, which replaces \"\\<\", \">\", \"&\", U+2028, and U+2029 are escaped to \"\\\\u003c\",\"\\\\u003e\", \"\\\\u0026\", \"\\\\u2028\", and \"\\\\u2029\". This replacement can be disabled when using an Encoder, by calling SetEscapeHTML(false).\n\nArray and slice values encode as JSON arrays, except that \\[]byte encodes as a base64-encoded string, and a nil slice encodes as the null JSON value.\n\nStruct values encode as JSON objects. Each exported struct field becomes a member of the object, using the field name as the object key, unless the field is omitted for one of the reasons given below.\n\nThe encoding of each struct field can be customized by the format string stored under the \"json\" key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.\n\nThe \"omitempty\" option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any empty array, slice, map, or string.\n\nAs a special case, if the field tag is \"-\", the field is always omitted. Note that a field with name \"-\" can still be generated using the tag \"-,\".\n\nExamples of struct field tags and their meanings:\n\n\t// Field appears in JSON as key \"myName\".\n\tField int `json:\"myName\"`\n\n\t// Field appears in JSON as key \"myName\" and\n\t// the field is omitted from the object if its value is empty,\n\t// as defined above.\n\tField int `json:\"myName,omitempty\"`\n\n\t// Field appears in JSON as key \"Field\" (the default), but\n\t// the field is skipped if empty.\n\t// Note the leading comma.\n\tField int `json:\",omitempty\"`\n\n\t// Field is ignored by this package.\n\tField int `json:\"-\"`\n\n\t// Field appears in JSON as key \"-\".\n\tField int `json:\"-,\"`\n\nThe \"string\" option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs:\n\n\tInt64String int64 `json:\",string\"`\n\nThe key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.\n\nAnonymous struct fields are usually marshaled as if their inner exported fields were fields in the outer struct, subject to the usual Go visibility rules amended as described in the next paragraph. An anonymous struct field with a name given in its JSON tag is treated as having that name, rather than being anonymous. An anonymous struct field of interface type is treated the same as having that type as its name, rather than being anonymous.\n\nThe Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply:\n\n1\\) Of those fields, if any are JSON-tagged, only tagged fields are considered, even if there are multiple untagged fields that would otherwise conflict.\n\n2\\) If there is exactly one field (tagged or not according to the first rule), that is selected.\n\n3\\) Otherwise there are multiple fields, and all are ignored; no error occurs.\n\nHandling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of an anonymous struct field in both current and earlier versions, give the field a JSON tag of \"-\".\n\nMap values encode as JSON objects. The map's key type must either be a string, an integer type, or implement encoding.TextMarshaler. The map keys are sorted and used as JSON object keys by applying the following rules, subject to the UTF-8 coercion described for string values above:\n\n  - keys of any string type are used directly\n  - encoding.TextMarshalers are marshaled\n  - integer keys are converted to strings\n\nPointer values encode as the value pointed to. A nil pointer encodes as the null JSON value.\n\nInterface values encode as the value contained in the interface. A nil interface value encodes as the null JSON value.\n\nChannel, complex, and function values cannot be encoded in JSON. Attempting to encode such a value causes Marshal to return an UnsupportedTypeError.\n\nJSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an error."
      },
      label = "Marshal(v any) ([]byte, error)",
      parameters = { {
          label = "v any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  json.Marshal(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "v any"
}

󰘫  |1: func |2: Marshal(v any) ([]byte, error) |3: {
  label = "v any"
}

󰘫  |1: virtual text only : |2:   lp := data.GetProducts() |3: } |4: { 21, 15 }
 |5: 21 |6: }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 21 |4: { "                v any", "Comment" }

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   json.Marshal()
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: () |3:   json.Marshal() |4:   json.Marshal( |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   json.Marshal()l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: )l |3:   json.Marshal()l |4:   json.Marshal() |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   json.Marshal()lp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: lp |3:   json.Marshal()lp |4:   json.Marshal()l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   json.Marshal()l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: lp |3:   json.Marshal()l |4:   json.Marshal()lp |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   json.Marshal()
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: )l |3:   json.Marshal() |4:   json.Marshal()l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   json.Marshal(l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   json.Marshal(lp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: lp |3:   json.Marshal(lp |4:   json.Marshal(l |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Marshal returns the JSON encoding of v.\n\nMarshal traverses the value v recursively. If an encountered value implements the Marshaler interface and is not a nil pointer, Marshal calls its MarshalJSON method to produce JSON. If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead, Marshal calls its MarshalText method and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON.\n\nOtherwise, Marshal uses the following type-dependent default encodings:\n\nBoolean values encode as JSON booleans.\n\nFloating point, integer, and Number values encode as JSON numbers. NaN and +/-Inf values will return an \\[UnsupportedValueError].\n\nString values encode as JSON strings coerced to valid UTF-8, replacing invalid bytes with the Unicode replacement rune. So that the JSON will be safe to embed inside HTML \\<script> tags, the string is encoded using HTMLEscape, which replaces \"\\<\", \">\", \"&\", U+2028, and U+2029 are escaped to \"\\\\u003c\",\"\\\\u003e\", \"\\\\u0026\", \"\\\\u2028\", and \"\\\\u2029\". This replacement can be disabled when using an Encoder, by calling SetEscapeHTML(false).\n\nArray and slice values encode as JSON arrays, except that \\[]byte encodes as a base64-encoded string, and a nil slice encodes as the null JSON value.\n\nStruct values encode as JSON objects. Each exported struct field becomes a member of the object, using the field name as the object key, unless the field is omitted for one of the reasons given below.\n\nThe encoding of each struct field can be customized by the format string stored under the \"json\" key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.\n\nThe \"omitempty\" option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any empty array, slice, map, or string.\n\nAs a special case, if the field tag is \"-\", the field is always omitted. Note that a field with name \"-\" can still be generated using the tag \"-,\".\n\nExamples of struct field tags and their meanings:\n\n\t// Field appears in JSON as key \"myName\".\n\tField int `json:\"myName\"`\n\n\t// Field appears in JSON as key \"myName\" and\n\t// the field is omitted from the object if its value is empty,\n\t// as defined above.\n\tField int `json:\"myName,omitempty\"`\n\n\t// Field appears in JSON as key \"Field\" (the default), but\n\t// the field is skipped if empty.\n\t// Note the leading comma.\n\tField int `json:\",omitempty\"`\n\n\t// Field is ignored by this package.\n\tField int `json:\"-\"`\n\n\t// Field appears in JSON as key \"-\".\n\tField int `json:\"-,\"`\n\nThe \"string\" option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs:\n\n\tInt64String int64 `json:\",string\"`\n\nThe key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.\n\nAnonymous struct fields are usually marshaled as if their inner exported fields were fields in the outer struct, subject to the usual Go visibility rules amended as described in the next paragraph. An anonymous struct field with a name given in its JSON tag is treated as having that name, rather than being anonymous. An anonymous struct field of interface type is treated the same as having that type as its name, rather than being anonymous.\n\nThe Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply:\n\n1\\) Of those fields, if any are JSON-tagged, only tagged fields are considered, even if there are multiple untagged fields that would otherwise conflict.\n\n2\\) If there is exactly one field (tagged or not according to the first rule), that is selected.\n\n3\\) Otherwise there are multiple fields, and all are ignored; no error occurs.\n\nHandling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of an anonymous struct field in both current and earlier versions, give the field a JSON tag of \"-\".\n\nMap values encode as JSON objects. The map's key type must either be a string, an integer type, or implement encoding.TextMarshaler. The map keys are sorted and used as JSON object keys by applying the following rules, subject to the UTF-8 coercion described for string values above:\n\n  - keys of any string type are used directly\n  - encoding.TextMarshalers are marshaled\n  - integer keys are converted to strings\n\nPointer values encode as the value pointed to. A nil pointer encodes as the null JSON value.\n\nInterface values encode as the value contained in the interface. A nil interface value encodes as the null JSON value.\n\nChannel, complex, and function values cannot be encoded in JSON. Attempting to encode such a value causes Marshal to return an UnsupportedTypeError.\n\nJSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an error."
      },
      label = "Marshal(v any) ([]byte, error)",
      parameters = { {
          label = "v any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  json.Marshal(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Marshal returns the JSON encoding of v.\n\nMarshal traverses the value v recursively. If an encountered value implements the Marshaler interface and is not a nil pointer, Marshal calls its MarshalJSON method to produce JSON. If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead, Marshal calls its MarshalText method and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON.\n\nOtherwise, Marshal uses the following type-dependent default encodings:\n\nBoolean values encode as JSON booleans.\n\nFloating point, integer, and Number values encode as JSON numbers. NaN and +/-Inf values will return an \\[UnsupportedValueError].\n\nString values encode as JSON strings coerced to valid UTF-8, replacing invalid bytes with the Unicode replacement rune. So that the JSON will be safe to embed inside HTML \\<script> tags, the string is encoded using HTMLEscape, which replaces \"\\<\", \">\", \"&\", U+2028, and U+2029 are escaped to \"\\\\u003c\",\"\\\\u003e\", \"\\\\u0026\", \"\\\\u2028\", and \"\\\\u2029\". This replacement can be disabled when using an Encoder, by calling SetEscapeHTML(false).\n\nArray and slice values encode as JSON arrays, except that \\[]byte encodes as a base64-encoded string, and a nil slice encodes as the null JSON value.\n\nStruct values encode as JSON objects. Each exported struct field becomes a member of the object, using the field name as the object key, unless the field is omitted for one of the reasons given below.\n\nThe encoding of each struct field can be customized by the format string stored under the \"json\" key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.\n\nThe \"omitempty\" option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any empty array, slice, map, or string.\n\nAs a special case, if the field tag is \"-\", the field is always omitted. Note that a field with name \"-\" can still be generated using the tag \"-,\".\n\nExamples of struct field tags and their meanings:\n\n\t// Field appears in JSON as key \"myName\".\n\tField int `json:\"myName\"`\n\n\t// Field appears in JSON as key \"myName\" and\n\t// the field is omitted from the object if its value is empty,\n\t// as defined above.\n\tField int `json:\"myName,omitempty\"`\n\n\t// Field appears in JSON as key \"Field\" (the default), but\n\t// the field is skipped if empty.\n\t// Note the leading comma.\n\tField int `json:\",omitempty\"`\n\n\t// Field is ignored by this package.\n\tField int `json:\"-\"`\n\n\t// Field appears in JSON as key \"-\".\n\tField int `json:\"-,\"`\n\nThe \"string\" option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs:\n\n\tInt64String int64 `json:\",string\"`\n\nThe key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.\n\nAnonymous struct fields are usually marshaled as if their inner exported fields were fields in the outer struct, subject to the usual Go visibility rules amended as described in the next paragraph. An anonymous struct field with a name given in its JSON tag is treated as having that name, rather than being anonymous. An anonymous struct field of interface type is treated the same as having that type as its name, rather than being anonymous.\n\nThe Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply:\n\n1\\) Of those fields, if any are JSON-tagged, only tagged fields are considered, even if there are multiple untagged fields that would otherwise conflict.\n\n2\\) If there is exactly one field (tagged or not according to the first rule), that is selected.\n\n3\\) Otherwise there are multiple fields, and all are ignored; no error occurs.\n\nHandling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of an anonymous struct field in both current and earlier versions, give the field a JSON tag of \"-\".\n\nMap values encode as JSON objects. The map's key type must either be a string, an integer type, or implement encoding.TextMarshaler. The map keys are sorted and used as JSON object keys by applying the following rules, subject to the UTF-8 coercion described for string values above:\n\n  - keys of any string type are used directly\n  - encoding.TextMarshalers are marshaled\n  - integer keys are converted to strings\n\nPointer values encode as the value pointed to. A nil pointer encodes as the null JSON value.\n\nInterface values encode as the value contained in the interface. A nil interface value encodes as the null JSON value.\n\nChannel, complex, and function values cannot be encoded in JSON. Attempting to encode such a value causes Marshal to return an UnsupportedTypeError.\n\nJSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an error."
      },
      label = "Marshal(v any) ([]byte, error)",
      parameters = { {
          label = "v any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  json.Marshal(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "v any"
}

󰘫  |1: func |2: Marshal(v any) ([]byte, error) |3: {
  label = "v any"
}

󰘫  |1: virtual text only : |2:   lp := data.GetProducts() |3: } |4: { 21, 17 }
 |5: 20
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 20 |4: { "  v any", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   d
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  d |3:   d |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   d,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: d, |3:   d, |4:   d |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   d, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: ,  |3:   d,  |4:   d, |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   d, e
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2:  e |3:   d, e |4:   d,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   d, er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: er |3:   d, er |4:   d, e |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   d, err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: rr |3:   d, err |4:   d, er |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   d, erro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: ro |3:   d, erro |4:   d, err |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   d, error
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: or |3:   d, error |4:   d, erro |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   d, error 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: r  |3:   d, error  |4:   d, error |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   d, error :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2:  : |3:   d, error : |4:   d, error  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   d, error :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: := |3:   d, error := |4:   d, error : |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   d, error := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: =  |3:   d, error :=  |4:   d, error := |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  i |3:   i |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   if
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: if |3:   if |4:   i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   if 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: f  |3:   if  |4:   if |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   if e
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  e |3:   if e |4:   if  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   if er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: er |3:   if er |4:   if e |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   if err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: rr |3:   if err |4:   if er |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   if err 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: r  |3:   if err  |4:   if err |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   if err !
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:  ! |3:   if err ! |4:   if err  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   if err !=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: != |3:   if err != |4:   if err ! |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   if err != 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: =  |3:   if err !=  |4:   if err != |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   if err != n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2:  n |3:   if err != n |4:   if err !=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   if err != ni
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: ni |3:   if err != ni |4:   if err != n |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   if err != nil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: il |3:   if err != nil |4:   if err != ni |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   if err != nil 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: l  |3:   if err != nil  |4:   if err != nil |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   if err != nil {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2:  { |3:   if err != nil { |4:   if err != nil  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: f err != nil { |3:      |4:   if err != nil { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  h |3:     h |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ht |3:     ht |4:     h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: tt |3:     htt |4:     ht |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: tp |3:     http |4:     htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: p. |3:     http. |4:     http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.E
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: .E |3:     http.E |4:     http. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: Er |3:     http.Er |4:     http.E |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: rr |3:     http.Err |4:     http.Er |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Erro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: ro |3:     http.Erro |4:     http.Err |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: or |3:     http.Error |4:     http.Erro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: r( |3:     http.Error( |4:     http.Error |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "w http.ResponseWriter"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "w http.ResponseWriter"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 15 }
 |5: 23 |6:   }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 23 |4: { "              w http.ResponseWriter", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: (r |3:     http.Error(r |4:     http.Error( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "w http.ResponseWriter"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "w http.ResponseWriter"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 16 }
 |5: 22
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 22 |4: { "  w http.ResponseWriter", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: rw |3:     http.Error(rw |4:     http.Error(r |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "w http.ResponseWriter"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "w http.ResponseWriter"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 17 }
 |5: 22
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 22 |4: { "  w http.ResponseWriter", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: w, |3:     http.Error(rw, |4:     http.Error(rw |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 18 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "  error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: ,  |3:     http.Error(rw,  |4:     http.Error(rw, |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 19 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "    error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2:  " |3:     http.Error(rw, " |4:     http.Error(rw,  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 20 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "     error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "u
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: "u |3:     http.Error(rw, "u |4:     http.Error(rw, " |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 21 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "      error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "un
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: un |3:     http.Error(rw, "un |4:     http.Error(rw, "u |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 22 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "       error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "una
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: na |3:     http.Error(rw, "una |4:     http.Error(rw, "un |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 23 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "        error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unab
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: ab |3:     http.Error(rw, "unab |4:     http.Error(rw, "una |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 24 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "         error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unabl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: bl |3:     http.Error(rw, "unabl |4:     http.Error(rw, "unab |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 25 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "          error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unablu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: lu |3:     http.Error(rw, "unablu |4:     http.Error(rw, "unabl |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 26 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "           error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unablu 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: u  |3:     http.Error(rw, "unablu  |4:     http.Error(rw, "unablu |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 27 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "            error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unablu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: u  |3:     http.Error(rw, "unablu |4:     http.Error(rw, "unablu  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 26 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "           error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unabl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: lu |3:     http.Error(rw, "unabl |4:     http.Error(rw, "unablu |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 25 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "          error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: le |3:     http.Error(rw, "unable |4:     http.Error(rw, "unabl |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 26 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "           error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: e  |3:     http.Error(rw, "unable  |4:     http.Error(rw, "unable |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 27 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "            error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2:  t |3:     http.Error(rw, "unable t |4:     http.Error(rw, "unable  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: to |3:     http.Error(rw, "unable to |4:     http.Error(rw, "unable t |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: o  |3:     http.Error(rw, "unable to  |4:     http.Error(rw, "unable to |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 30 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "               error string", "Comment" }

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 30 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "               error string", "Comment" }

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 30 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "               error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to m
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2:  m |3:     http.Error(rw, "unable to m |4:     http.Error(rw, "unable to  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 31 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to ma
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: ma |3:     http.Error(rw, "unable to ma |4:     http.Error(rw, "unable to m |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 32 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                 error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to mar
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: ar |3:     http.Error(rw, "unable to mar |4:     http.Error(rw, "unable to ma |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 33 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                  error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to mars
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: rs |3:     http.Error(rw, "unable to mars |4:     http.Error(rw, "unable to mar |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 34 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                   error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marsh
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: sh |3:     http.Error(rw, "unable to marsh |4:     http.Error(rw, "unable to mars |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 35 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                    error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marsha
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: ha |3:     http.Error(rw, "unable to marsha |4:     http.Error(rw, "unable to marsh |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 36 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                     error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: al |3:     http.Error(rw, "unable to marshal |4:     http.Error(rw, "unable to marsha |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: l  |3:     http.Error(rw, "unable to marshal  |4:     http.Error(rw, "unable to marshal |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 38 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                       error string", "Comment" }

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 38 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                       error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal j
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2:  j |3:     http.Error(rw, "unable to marshal j |4:     http.Error(rw, "unable to marshal  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 39 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                        error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal ja
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: ja |3:     http.Error(rw, "unable to marshal ja |4:     http.Error(rw, "unable to marshal j |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 40 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                         error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal j
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: ja |3:     http.Error(rw, "unable to marshal j |4:     http.Error(rw, "unable to marshal ja |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 39 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                        error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal jr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: jr |3:     http.Error(rw, "unable to marshal jr |4:     http.Error(rw, "unable to marshal j |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 40 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                         error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal j
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: jr |3:     http.Error(rw, "unable to marshal j |4:     http.Error(rw, "unable to marshal jr |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 39 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                        error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal js
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: js |3:     http.Error(rw, "unable to marshal js |4:     http.Error(rw, "unable to marshal j |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 40 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                         error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal jso
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: so |3:     http.Error(rw, "unable to marshal jso |4:     http.Error(rw, "unable to marshal js |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: on |3:     http.Error(rw, "unable to marshal json |4:     http.Error(rw, "unable to marshal jso |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 42 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                           error string", "Comment" }

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    http.Error(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "error string"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "error string"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 42 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                           error string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: n", |3:     http.Error(rw, "unable to marshal json", |4:     http.Error(rw, "unable to marshal json |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 44 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                             code int", "Comment" }

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2:     http.Error(rw, "unable to marshal json", |3:     http.Error(rw, "unable to marshal json", |4:     http.Error(rw, "unable to marshal json", |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 44 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                             code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: ,h |3:     http.Error(rw, "unable to marshal json",h |4:     http.Error(rw, "unable to marshal json", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 45 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                              code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: ht |3:     http.Error(rw, "unable to marshal json",ht |4:     http.Error(rw, "unable to marshal json",h |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 46 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                               code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: tt |3:     http.Error(rw, "unable to marshal json",htt |4:     http.Error(rw, "unable to marshal json",ht |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 47 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                                code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: tp |3:     http.Error(rw, "unable to marshal json",http |4:     http.Error(rw, "unable to marshal json",htt |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 48 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                                 code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: p. |3:     http.Error(rw, "unable to marshal json",http. |4:     http.Error(rw, "unable to marshal json",http |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 49 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                                  code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",http.S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: .S |3:     http.Error(rw, "unable to marshal json",http.S |4:     http.Error(rw, "unable to marshal json",http. |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 50 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                                   code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",http.St
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: St |3:     http.Error(rw, "unable to marshal json",http.St |4:     http.Error(rw, "unable to marshal json",http.S |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 51 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                                    code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",http.Sta
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: ta |3:     http.Error(rw, "unable to marshal json",http.Sta |4:     http.Error(rw, "unable to marshal json",http.St |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 52 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                                     code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",http.Stat
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: at |3:     http.Error(rw, "unable to marshal json",http.Stat |4:     http.Error(rw, "unable to marshal json",http.Sta |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 53 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                                      code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",http.Statu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: tu |3:     http.Error(rw, "unable to marshal json",http.Statu |4:     http.Error(rw, "unable to marshal json",http.Stat |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 54 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                                       code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",http.Status
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: us |3:     http.Error(rw, "unable to marshal json",http.Status |4:     http.Error(rw, "unable to marshal json",http.Statu |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 55 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                                        code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",http.StatusI
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: sI |3:     http.Error(rw, "unable to marshal json",http.StatusI |4:     http.Error(rw, "unable to marshal json",http.Status |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",http.StatusIn
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: In |3:     http.Error(rw, "unable to marshal json",http.StatusIn |4:     http.Error(rw, "unable to marshal json",http.StatusI |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 57 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                                          code int", "Comment" }

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 57 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                                          code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",http.StatusInt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: nt |3:     http.Error(rw, "unable to marshal json",http.StatusInt |4:     http.Error(rw, "unable to marshal json",http.StatusIn |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",http.StatusInte
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: te |3:     http.Error(rw, "unable to marshal json",http.StatusInte |4:     http.Error(rw, "unable to marshal json",http.StatusInt |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 59 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                                            code int", "Comment" }

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 59 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                                            code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",http.StatusInter
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: er |3:     http.Error(rw, "unable to marshal json",http.StatusInter |4:     http.Error(rw, "unable to marshal json",http.StatusInte |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 60 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                                             code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     http.Error(rw, "unable to marshal json",http.StatusInternalServerError
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 44
󰘫  |1: delta |2: rnalServerError |3:     http.Error(rw, "unable to marshal json",http.StatusInternalServerError |4:     http.Error(rw, "unable to marshal json",http.StatusInter |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 44,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text."
      },
      label = "Error(w http.ResponseWriter, error string, code int)",
      parameters = { {
          label = "w http.ResponseWriter"
        }, {
          label = "error string"
        }, {
          label = "code int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    http.Error(rw, "unable to marshal json",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Error(w http.ResponseWriter, error string, code int)
󰘫  |1: nextpara: |2: {
  label = "code int"
}

󰘫  |1: func |2: Error(w http.ResponseWriter, error string, code int) |3: {
  label = "code int"
}

󰘫  |1: virtual text only : |2:   if err != nil { |3:   } |4: { 23, 74 }
 |5: 21 |6:   if err != nil {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 22 |3: 21 |4: { "                                                           code int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  http.Error(rw, "unable to marshal json",http.StatusInternalServerError |3:      |4:     http.Error(rw, "unable to marshal json",http.StatusInternalServerError |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   d, error
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2:   d, error |3:   d, error |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   d, erro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: or |3:   d, erro |4:   d, error |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   d, err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: ro |3:   d, err |4:   d, erro |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  r |3:   r |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: rw |3:   rw |4:   r |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: w. |3:   rw. |4:   rw |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.AR
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: .AR |3:   rw.AR |4:   rw. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.A
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: AR |3:   rw.A |4:   rw.AR |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: .A |3:   rw. |4:   rw.A |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.W
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: .W |3:   rw.W |4:   rw. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Wr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: Wr |3:   rw.Wr |4:   rw.W |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Wri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ri |3:   rw.Wri |4:   rw.Wr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Writ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: it |3:   rw.Writ |4:   rw.Wri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: te |3:   rw.Write |4:   rw.Writ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 11
󰘫  |1: delta |2: e( |3:   rw.Write( |4:   rw.Write |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 11,
      line = 24
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "[]byte"
}

󰘫  |1: func |2: Write([]byte) (int, error) |3: {
  label = "[]byte"
}

󰘫  |1: virtual text only : |2:   } |3:  |4: { 25, 11 }
 |5: 23 |6:   }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 24 |3: 23 |4: { "          []byte", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write(d
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 11
󰘫  |1: delta |2: (d |3:   rw.Write(d |4:   rw.Write( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 11,
      line = 24
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  rw.Write(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "[]byte"
}

󰘫  |1: func |2: Write([]byte) (int, error) |3: {
  label = "[]byte"
}

󰘫  |1: virtual text only : |2:   } |3:  |4: { 25, 12 }
 |5: 23 |6:   }
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 24 |3: 23 |4: { "           []byte", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   rw.Write(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 11
󰘫  |1: delta |2:   rw.Write( |3:   rw.Write( |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 16,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 11,
      line = 24
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/handlers/products.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "  rw.Write(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK) before writing the data. If the Header does not contain a Content-Type line, Write adds a Content-Type set to the result of passing the initial 512 bytes of written data to DetectContentType. Additionally, if the total size of all written data is under a few KB and there are no Flush calls, the Content-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling Write or WriteHeader may prevent future reads on the Request.Body. For HTTP/1.x requests, handlers should read any needed request body data before writing the response. Once the headers have been flushed (due to either an explicit Flusher.Flush call or writing enough data to trigger a flush), the request body may be unavailable. For HTTP/2 requests, the Go HTTP server permits handlers to continue to read the request body while concurrently writing the response. However, such behavior may not be supported by all HTTP/2 clients. Handlers should read before writing if possible to maximize compatibility."
      },
      label = "Write([]byte) (int, error)",
      parameters = { {
          label = "[]byte"
        } }
    } }
}
 |3: {
  border = "rounded",
  line_to_cursor = "  rw.Write(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "[]byte"
}

󰘫  |1: func |2: Write([]byte) (int, error) |3: {
  label = "[]byte"
}

󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProducts
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: func NewProducts |3: func NewProducts |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProduct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: ts |3: func NewProduct |4: func NewProducts |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewProduc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: func NewProduc |3: func NewProduc |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2: func NewProduc |3:  |4: func NewProduc |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package handle
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: package handle |3: package handle |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   strin
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: strin |3: 	CreatedOn   strin |4: package handle |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	ID          int
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: 	ID          int |3: 	ID          int |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	ID          int 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: t  |3: 	ID          int  |4: 	ID          int |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	ID          int '
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2:  ' |3: 	ID          int ' |4: 	ID          int  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	ID          int 'j
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: 'j |3: 	ID          int 'j |4: 	ID          int ' |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	ID          int 'js
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: js |3: 	ID          int 'js |4: 	ID          int 'j |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	ID          int 'jso
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: so |3: 	ID          int 'jso |4: 	ID          int 'js |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	ID          int 'json
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: on |3: 	ID          int 'json |4: 	ID          int 'jso |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int 'json:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: on: |3:   ID          int 'json: |4: 	ID          int 'json |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int 'json:i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: :i |3:   ID          int 'json:i |4:   ID          int 'json: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int 'json:id
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: id |3:   ID          int 'json:id |4:   ID          int 'json:i |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Name        string
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: 	Name        string |3: 	Name        string |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Name        string 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: g  |3: 	Name        string  |4: 	Name        string |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Name        string '
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:  ' |3: 	Name        string ' |4: 	Name        string  |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int 'json:id'
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2:   ID          int 'json:id' |3:   ID          int 'json:id' |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int 'json:id
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: d' |3:   ID          int 'json:id |4:   ID          int 'json:id' |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int 'json:i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: id |3:   ID          int 'json:i |4:   ID          int 'json:id |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int 'json:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: :i |3:   ID          int 'json: |4:   ID          int 'json:i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int 'json
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: n: |3:   ID          int 'json |4:   ID          int 'json: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int 'jso
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: on |3:   ID          int 'jso |4:   ID          int 'json |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int 'js
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: so |3:   ID          int 'js |4:   ID          int 'jso |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int 'j
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: js |3:   ID          int 'j |4:   ID          int 'js |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int '
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: 'j |3:   ID          int ' |4:   ID          int 'j |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2:  ' |3:   ID          int  |4:   ID          int ' |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int <
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2:  < |3:   ID          int < |4:   ID          int  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2:  < |3:   ID          int  |4:   ID          int < |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int '
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2:  ' |3:   ID          int ' |4:   ID          int  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2:  ' |3:   ID          int  |4:   ID          int ' |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2:  ` |3:   ID          int ` |4:   ID          int  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `j
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: `j |3:   ID          int `j |4:   ID          int ` |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `js
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: js |3:   ID          int `js |4:   ID          int `j |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `jso
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: so |3:   ID          int `jso |4:   ID          int `js |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `json
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: on |3:   ID          int `json |4:   ID          int `jso |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `json:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: n: |3:   ID          int `json: |4:   ID          int `json |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `json:"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: :" |3:   ID          int `json:" |4:   ID          int `json: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `json:"n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: "n |3:   ID          int `json:"n |4:   ID          int `json:" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `json:"na
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: na |3:   ID          int `json:"na |4:   ID          int `json:"n |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `json:"n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: na |3:   ID          int `json:"n |4:   ID          int `json:"na |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `json:"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: "n |3:   ID          int `json:" |4:   ID          int `json:"n |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `json:"i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: "i |3:   ID          int `json:"i |4:   ID          int `json:" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `json:"id
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: id |3:   ID          int `json:"id |4:   ID          int `json:"i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `json:"idR
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: dR |3:   ID          int `json:"idR |4:   ID          int `json:"id |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `json:"id
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: dR |3:   ID          int `json:"id |4:   ID          int `json:"idR |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ID          int `json:"id"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: d" |3:   ID          int `json:"id" |4:   ID          int `json:"id |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Name        string ''
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: 	Name        string '' |3: 	Name        string '' |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Name        string 'j
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Name        string 'js
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: js |3: 	Name        string 'js |4: 	Name        string 'j |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Name        string 'jso
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: so |3: 	Name        string 'jso |4: 	Name        string 'js |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Name        string 'json
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: on |3: 	Name        string 'json |4: 	Name        string 'jso |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: on: |3:   Name        string 'json: |4: 	Name        string 'json |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: :" |3:   Name        string 'json:" |4:   Name        string 'json: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:""
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: "" |3:   Name        string 'json:"" |4:   Name        string 'json:" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:"n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:"na
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2: na |3:   Name        string 'json:"na |4:   Name        string 'json:"n |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:"nam
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2: am |3:   Name        string 'json:"nam |4:   Name        string 'json:"na |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:"name
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: me |3:   Name        string 'json:"name |4:   Name        string 'json:"nam |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:"name"'
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2:   Name        string 'json:"name"' |3:   Name        string 'json:"name"' |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:"name"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 33
󰘫  |1: delta |2: "' |3:   Name        string 'json:"name" |4:   Name        string 'json:"name"' |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:"name" 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: "  |3:   Name        string 'json:"name"  |4:   Name        string 'json:"name" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:"name" @
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 35
󰘫  |1: delta |2:  @ |3:   Name        string 'json:"name" @ |4:   Name        string 'json:"name"  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:"name" 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2:  @ |3:   Name        string 'json:"name"  |4:   Name        string 'json:"name" @ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:"name"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 33
󰘫  |1: delta |2: "  |3:   Name        string 'json:"name" |4:   Name        string 'json:"name"  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:"name"<
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: "< |3:   Name        string 'json:"name"< |4:   Name        string 'json:"name" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:"name"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 33
󰘫  |1: delta |2: "< |3:   Name        string 'json:"name" |4:   Name        string 'json:"name"< |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 'json:"name"`
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: "` |3:   Name        string 'json:"name"` |4:   Name        string 'json:"name" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:  'json:"name"` |3:   Name        string  |4:   Name        string 'json:"name"` |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:   Name        string  |3:   Name        string  |4:   Name        string  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:    |3:   Name        string   |4:   Name        string  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string  <
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2:  < |3:   Name        string  < |4:   Name        string   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  < |3:   Name        string   |4:   Name        string  < |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string   
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2:    |3:   Name        string    |4:   Name        string   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string   <
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2:  < |3:   Name        string   < |4:   Name        string    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string   
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2:  < |3:   Name        string    |4:   Name        string   < |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:    |3:   Name        string   |4:   Name        string    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string   
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2:    |3:   Name        string    |4:   Name        string   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:    |3:   Name        string   |4:   Name        string    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string  `
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2:  ` |3:   Name        string  ` |4:   Name        string   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Name        string 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:   ` |3:   Name        string  |4:   Name        string  ` |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Description string
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: 	Description string |3: 	Description string |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Description string 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: g  |3: 	Description string  |4: 	Description string |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Description string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:    |3: 	Description string   |4: 	Description string  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Description string  <
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  < |3: 	Description string  < |4: 	Description string   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Description string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:  < |3: 	Description string   |4: 	Description string  < |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Description string  `
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  ` |3: 	Description string  ` |4: 	Description string   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Description string  `j
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: `j |3: 	Description string  `j |4: 	Description string  ` |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Description string  `js
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: js |3: 	Description string  `js |4: 	Description string  `j |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Description string  `jso
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: so |3: 	Description string  `jso |4: 	Description string  `js |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Description string  `json
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: on |3: 	Description string  `json |4: 	Description string  `jso |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Description string  `json;
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: n; |3: 	Description string  `json; |4: 	Description string  `json |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Description string  `json
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: n; |3: 	Description string  `json |4: 	Description string  `json; |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description string  `json:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: on: |3:   Description string  `json: |4: 	Description string  `json |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description string  `json:"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: :" |3:   Description string  `json:" |4:   Description string  `json: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description string  `json:""
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2: "" |3:   Description string  `json:"" |4:   Description string  `json:" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description string  `json:"d
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description string  `json:"de
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2: de |3:   Description string  `json:"de |4:   Description string  `json:"d |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description string  `json:"des
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: es |3:   Description string  `json:"des |4:   Description string  `json:"de |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description string  `json:"desc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 33
󰘫  |1: delta |2: sc |3:   Description string  `json:"desc |4:   Description string  `json:"des |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description string  `json:"descr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: cr |3:   Description string  `json:"descr |4:   Description string  `json:"desc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description string  `json:"descri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 35
󰘫  |1: delta |2: ri |3:   Description string  `json:"descri |4:   Description string  `json:"descr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description string  `json:"descrit
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 36
󰘫  |1: delta |2: it |3:   Description string  `json:"descrit |4:   Description string  `json:"descri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description string  `json:"descri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 35
󰘫  |1: delta |2: it |3:   Description string  `json:"descri |4:   Description string  `json:"descrit |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description string  `json:"descrip
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 36
󰘫  |1: delta |2: ip |3:   Description string  `json:"descrip |4:   Description string  `json:"descri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description string  `json:"descript
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 37
󰘫  |1: delta |2: pt |3:   Description string  `json:"descript |4:   Description string  `json:"descrip |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Description string  `json:"description
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 40
󰘫  |1: delta |2: tion |3:   Description string  `json:"description |4:   Description string  `json:"descript |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Price       float32
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: 	Price       float32 |3: 	Price       float32 |4:  |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Price       float32
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: 	Price       float32 |3: 	Price       float32 |4: 	Price       float32 |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Price       float32 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: 2  |3: 	Price       float32  |4: 	Price       float32 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Price       float32 `
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  ` |3: 	Price       float32 ` |4: 	Price       float32  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Price       float32 `j
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: `j |3: 	Price       float32 `j |4: 	Price       float32 ` |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Price       float32 `js
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: js |3: 	Price       float32 `js |4: 	Price       float32 `j |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Price       float32 `jso
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: so |3: 	Price       float32 `jso |4: 	Price       float32 `js |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	Price       float32 `json
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: on |3: 	Price       float32 `json |4: 	Price       float32 `jso |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price       float32 `json:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: on: |3:   Price       float32 `json: |4: 	Price       float32 `json |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price       float32 `json: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: :  |3:   Price       float32 `json:  |4:   Price       float32 `json: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price       float32 `json: "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2:  " |3:   Price       float32 `json: " |4:   Price       float32 `json:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price       float32 `json: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2:  " |3:   Price       float32 `json:  |4:   Price       float32 `json: " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price       float32 `json:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: :  |3:   Price       float32 `json: |4:   Price       float32 `json:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price       float32 `json:"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: :" |3:   Price       float32 `json:" |4:   Price       float32 `json: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price       float32 `json:""
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2: "" |3:   Price       float32 `json:"" |4:   Price       float32 `json:" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price       float32 `json:"p
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price       float32 `json:"pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2: pr |3:   Price       float32 `json:"pr |4:   Price       float32 `json:"p |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price       float32 `json:"pri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: ri |3:   Price       float32 `json:"pri |4:   Price       float32 `json:"pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price       float32 `json:"pric
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 33
󰘫  |1: delta |2: ic |3:   Price       float32 `json:"pric |4:   Price       float32 `json:"pri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   Price       float32 `json:"price
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: ce |3:   Price       float32 `json:"price |4:   Price       float32 `json:"pric |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: 	SKU         string |3: 	SKU         string |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: g  |3: 	SKU         string  |4: 	SKU         string |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:    |3: 	SKU         string   |4: 	SKU         string  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string  <
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  < |3: 	SKU         string  < |4: 	SKU         string   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:  < |3: 	SKU         string   |4: 	SKU         string  < |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string   
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:    |3: 	SKU         string    |4: 	SKU         string   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string   <
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2:  < |3: 	SKU         string   < |4: 	SKU         string    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string   
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  < |3: 	SKU         string    |4: 	SKU         string   < |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:    |3: 	SKU         string   |4: 	SKU         string    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string   
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:    |3: 	SKU         string    |4: 	SKU         string   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string   <
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2:  < |3: 	SKU         string   < |4: 	SKU         string    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string   
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  < |3: 	SKU         string    |4: 	SKU         string   < |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:    |3: 	SKU         string   |4: 	SKU         string    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string   
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:    |3: 	SKU         string    |4: 	SKU         string   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string   <
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2:  < |3: 	SKU         string   < |4: 	SKU         string    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string   
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  < |3: 	SKU         string    |4: 	SKU         string   < |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:    |3: 	SKU         string   |4: 	SKU         string    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2:    |3: 	SKU         string  |4: 	SKU         string   |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: 	SKU         string  |3: 	SKU         string  |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:    |3: 	SKU         string   |4: 	SKU         string  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2:    |3: 	SKU         string  |4: 	SKU         string   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string `
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:  ` |3: 	SKU         string ` |4: 	SKU         string  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string `j
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: `j |3: 	SKU         string `j |4: 	SKU         string ` |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string `js
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: js |3: 	SKU         string `js |4: 	SKU         string `j |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string `jso
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: so |3: 	SKU         string `jso |4: 	SKU         string `js |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string `json
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: on |3: 	SKU         string `json |4: 	SKU         string `jso |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   SKU         string `json:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: on: |3:   SKU         string `json: |4: 	SKU         string `json |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   SKU         string `json:s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: :s |3:   SKU         string `json:s |4:   SKU         string `json: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   SKU         string `json:sk
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: sk |3:   SKU         string `json:sk |4:   SKU         string `json:s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   SKU         string `json:sku
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2: ku |3:   SKU         string `json:sku |4:   SKU         string `json:sk |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: 	CreatedOn   string |3: 	CreatedOn   string |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: g  |3: 	CreatedOn   string  |4: 	CreatedOn   string |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:    |3: 	CreatedOn   string   |4: 	CreatedOn   string  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string  <
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  < |3: 	CreatedOn   string  < |4: 	CreatedOn   string   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:  < |3: 	CreatedOn   string   |4: 	CreatedOn   string  < |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2:    |3: 	CreatedOn   string  |4: 	CreatedOn   string   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:    |3: 	CreatedOn   string   |4: 	CreatedOn   string  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string  i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  i |3: 	CreatedOn   string  i |4: 	CreatedOn   string   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string  
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:  i |3: 	CreatedOn   string   |4: 	CreatedOn   string  i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2:    |3: 	CreatedOn   string  |4: 	CreatedOn   string   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string `
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:  ` |3: 	CreatedOn   string ` |4: 	CreatedOn   string  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string `j
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: `j |3: 	CreatedOn   string `j |4: 	CreatedOn   string ` |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string `js
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: js |3: 	CreatedOn   string `js |4: 	CreatedOn   string `j |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string `jso
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: so |3: 	CreatedOn   string `jso |4: 	CreatedOn   string `js |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string `json
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: on |3: 	CreatedOn   string `json |4: 	CreatedOn   string `jso |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   CreatedOn   string `json:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: on: |3:   CreatedOn   string `json: |4: 	CreatedOn   string `json |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   CreatedOn   string `json:-
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: :- |3:   CreatedOn   string `json:- |4:   CreatedOn   string `json: |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	DeletedOn   string  `
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: 	DeletedOn   string  ` |3: 	DeletedOn   string  ` |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string  `json:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: 	SKU         string  `json: |3: 	SKU         string  `json: |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string  `json:"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: :" |3: 	SKU         string  `json:" |4: 	SKU         string  `json: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	SKU         string  `json:"sku"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: "sku" |3: 	SKU         string  `json:"sku" |4: 	SKU         string  `json:" |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string  `json:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: 	CreatedOn   string  `json: |3: 	CreatedOn   string  `json: |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string  `json:"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: :" |3: 	CreatedOn   string  `json:" |4: 	CreatedOn   string  `json: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	CreatedOn   string  `json:"-"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2: "-" |3: 	CreatedOn   string  `json:"-" |4: 	CreatedOn   string  `json:" |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	UpdatedOn   string  `json:-
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: 	UpdatedOn   string  `json:- |3: 	UpdatedOn   string  `json:- |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	UpdatedOn   string  `json:-"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: -" |3: 	UpdatedOn   string  `json:-" |4: 	UpdatedOn   string  `json:- |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	UpdatedOn   string  `json:"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: -" |3: 	UpdatedOn   string  `json:" |4: 	UpdatedOn   string  `json:-" |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	DeletedOn   string  `json:-
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: 	DeletedOn   string  `json:- |3: 	DeletedOn   string  `json:- |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	DeletedOn   string  `json:-"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: -" |3: 	DeletedOn   string  `json:-" |4: 	DeletedOn   string  `json:- |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	DeletedOn   string  `json:"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: -" |3: 	DeletedOn   string  `json:" |4: 	DeletedOn   string  `json:-" |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	DeletedOn   string  `json:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: 	DeletedOn   string  `json: |3: 	DeletedOn   string  `json: |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
