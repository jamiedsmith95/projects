󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: p
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: p |3: p |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pa
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: pa |3: pa |4: p |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pac
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: ac |3: pac |4: pa |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pack
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ck |3: pack |4: pac |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: packa
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: ka |3: packa |4: pack |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: packag
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ag |3: packag |4: packa |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ge |3: package |4: packag |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: e  |3: package  |4: package |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package m
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2:  m |3: package m |4: package  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package ma
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: ma |3: package ma |4: package m |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package mai
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ai |3: package mai |4: package ma |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package main
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: in |3: package main |4: package mai |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2: package main |3:  |4: package main |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: f |3: f |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: fu |3: fu |4: f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: un |3: fun |4: fu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: nc |3: func |4: fun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: c  |3: func  |4: func |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func m
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  m |3: func m |4: func  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func ma
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ma |3: func ma |4: func m |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func mai
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ai |3: func mai |4: func ma |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func main
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: in |3: func main |4: func mai |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func main(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 10
󰘫  |1: delta |2: n( |3: func main( |4: func main |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func main() 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ()  |3: func main()  |4: func main( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func main() {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2:  { |3: func main() { |4: func main()  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: unc main() { |3:    |4: func main() { |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: i |3: i |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: im
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: im |3: im |4: i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: imp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: mp |3: imp |4: im |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: impo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: po |3: impo |4: imp |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: impor
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: or |3: impor |4: impo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: rt |3: import |4: impor |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: t  |3: import  |4: import |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2:  " |3: import " |4: import  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: "n |3: import "n |4: import " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "ne
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: ne |3: import "ne |4: import "n |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "net
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: et |3: import "net |4: import "ne |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "net/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: t/ |3: import "net/ |4: import "net |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "net/h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: /h |3: import "net/h |4: import "net/ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "net/ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: ht |3: import "net/ht |4: import "net/h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "net/htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: tt |3: import "net/htt |4: import "net/ht |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "net/http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: tp |3: import "net/http |4: import "net/htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2: import "net/http |3:  |4: import "net/http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  h |3:   h |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ht |3:   ht |4:   h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: tt |3:   htt |4:   ht |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: tp |3:   http |4:   htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: p. |3:   http. |4:   http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.L
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: .L |3:   http.L |4:   http. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Li
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: Li |3:   http.Li |4:   http.L |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Lis
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: is |3:   http.Lis |4:   http.Li |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.List
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: st |3:   http.List |4:   http.Lis |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Liste
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: te |3:   http.Liste |4:   http.List |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Listen
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: en |3:   http.Listen |4:   http.Liste |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAnd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: nAnd |3:   http.ListenAnd |4:   http.Listen |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndS
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: dS |3:   http.ListenAndS |4:   http.ListenAnd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndSe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: Se |3:   http.ListenAndSe |4:   http.ListenAndS |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndSer
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: er |3:   http.ListenAndSer |4:   http.ListenAndSe |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: rv |3:   http.ListenAndServ |4:   http.ListenAndSer |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: ve |3:   http.ListenAndServe |4:   http.ListenAndServ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: e( |3:   http.ListenAndServe( |4:   http.ListenAndServe |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 6
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.ListenAndServe(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.ListenAndServe(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "addr string"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "addr string"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 7, 22 }
 |5: 5 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 6 |3: 5 |4: { "           addr string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: (" |3:   http.ListenAndServe(" |4:   http.ListenAndServe( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: ": |3:   http.ListenAndServe(": |4:   http.ListenAndServe(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: :9 |3:   http.ListenAndServe(":9 |4:   http.ListenAndServe(": |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":90
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: 90 |3:   http.ListenAndServe(":90 |4:   http.ListenAndServe(":9 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":909
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: 09 |3:   http.ListenAndServe(":909 |4:   http.ListenAndServe(":90 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9096
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: 96 |3:   http.ListenAndServe(":9096 |4:   http.ListenAndServe(":909 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":909
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: 96 |3:   http.ListenAndServe(":909 |4:   http.ListenAndServe(":9096 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: 90 |3:   http.ListenAndServe(":9090 |4:   http.ListenAndServe(":909 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: 0", |3:   http.ListenAndServe(":9090", |4:   http.ListenAndServe(":9090 |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 6
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 7, 30 }
 |5: 5 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 6 |3: 5 |4: { "                   handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: ,  |3:   http.ListenAndServe(":9090",  |4:   http.ListenAndServe(":9090", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 6
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 7, 31 }
 |5: 5 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 6 |3: 5 |4: { "                    handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2:  n |3:   http.ListenAndServe(":9090", n |4:   http.ListenAndServe(":9090",  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", ni
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: ni |3:   http.ListenAndServe(":9090", ni |4:   http.ListenAndServe(":9090", n |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 6
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 6
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 7, 33 }
 |5: 5 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 6 |3: 5 |4: { "                      handler http.Handler", "Comment" }

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 7, 33 }
 |5: 5 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 6 |3: 5 |4: { "                      handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", nil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: il |3:   http.ListenAndServe(":9090", nil |4:   http.ListenAndServe(":9090", ni |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 6
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 7, 34 }
 |5: 5 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 6 |3: 5 |4: { "                       handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  http.ListenAndServe(":9090", nil |3:    |4:   http.ListenAndServe(":9090", nil |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  h |3:   h |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ht |3:   ht |4:   h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: tt |3:   htt |4:   ht |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: tp |3:   http |4:   htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: p. |3:   http. |4:   http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: .H |3:   http.H |4:   http. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Hand
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: Hand |3:   http.Hand |4:   http.H |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Handl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: dl |3:   http.Handl |4:   http.Hand |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.Handle
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: le |3:   http.Handle |4:   http.Handl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleF
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: eF |3:   http.HandleF |4:   http.Handle |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: Fu |3:   http.HandleFu |4:   http.HandleF |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: un |3:   http.HandleFun |4:   http.HandleFu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: nc |3:   http.HandleFunc |4:   http.HandleFun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: c( |3:   http.HandleFunc( |4:   http.HandleFunc |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 6
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.HandleFunc(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.HandleFunc(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "pattern string"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "pattern string"
}

󰘫  |1: virtual text only : |2: func main() { |3:   http.ListenAndServe(":9090", nil) |4: { 7, 18 }
 |5: 5 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 6 |3: 5 |4: { "       pattern string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: (" |3:   http.HandleFunc(" |4:   http.HandleFunc( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: "/ |3:   http.HandleFunc("/ |4:   http.HandleFunc(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: /", |3:   http.HandleFunc("/", |4:   http.HandleFunc("/ |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 6
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:   http.ListenAndServe(":9090", nil) |4: { 7, 22 }
 |5: 5 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 6 |3: 5 |4: { "           handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: ,  |3:   http.HandleFunc("/",  |4:   http.HandleFunc("/", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 6
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:   http.ListenAndServe(":9090", nil) |4: { 7, 23 }
 |5: 5 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 6 |3: 5 |4: { "            handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2:   http.HandleFunc("/",  |3:   http.HandleFunc("/",  |4:   http.HandleFunc("/",  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 6
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:   http.ListenAndServe(":9090", nil) |4: { 7, 23 }
 |5: 5 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 6 |3: 5 |4: { "            handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2:  f |3:   http.HandleFunc("/", f |4:   http.HandleFunc("/",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 6
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:   http.ListenAndServe(":9090", nil) |4: { 7, 24 }
 |5: 5 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 6 |3: 5 |4: { "             handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: fu |3:   http.HandleFunc("/", fu |4:   http.HandleFunc("/", f |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 6
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:   http.ListenAndServe(":9090", nil) |4: { 7, 25 }
 |5: 5 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 6 |3: 5 |4: { "              handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: un |3:   http.HandleFunc("/", fun |4:   http.HandleFunc("/", fu |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 6
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:   http.ListenAndServe(":9090", nil) |4: { 7, 26 }
 |5: 5 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 6 |3: 5 |4: { "               handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: nc |3:   http.HandleFunc("/", func |4:   http.HandleFunc("/", fun |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 6
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:   http.ListenAndServe(":9090", nil) |4: { 7, 27 }
 |5: 5 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 6 |3: 5 |4: { "                handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: c( |3:   http.HandleFunc("/", func( |4:   http.HandleFunc("/", func |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2:   http.HandleFunc("/", func( |3:   http.HandleFunc("/", func( |4:   http.HandleFunc("/", func( |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: (i |3:   http.HandleFunc("/", func(i |4:   http.HandleFunc("/", func( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: (i |3:   http.HandleFunc("/", func( |4:   http.HandleFunc("/", func(i |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: (h |3:   http.HandleFunc("/", func(h |4:   http.HandleFunc("/", func( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: ht |3:   http.HandleFunc("/", func(ht |4:   http.HandleFunc("/", func(h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: tt |3:   http.HandleFunc("/", func(htt |4:   http.HandleFunc("/", func(ht |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: tp |3:   http.HandleFunc("/", func(http |4:   http.HandleFunc("/", func(htt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: p. |3:   http.HandleFunc("/", func(http. |4:   http.HandleFunc("/", func(http |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: .R |3:   http.HandleFunc("/", func(http.R |4:   http.HandleFunc("/", func(http. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: Re |3:   http.HandleFunc("/", func(http.Re |4:   http.HandleFunc("/", func(http.R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.Res
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: es |3:   http.HandleFunc("/", func(http.Res |4:   http.HandleFunc("/", func(http.Re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.Resp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: sp |3:   http.HandleFunc("/", func(http.Resp |4:   http.HandleFunc("/", func(http.Res |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.Respo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: po |3:   http.HandleFunc("/", func(http.Respo |4:   http.HandleFunc("/", func(http.Resp |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.Respon
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: on |3:   http.HandleFunc("/", func(http.Respon |4:   http.HandleFunc("/", func(http.Respo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.Respons
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: ns |3:   http.HandleFunc("/", func(http.Respons |4:   http.HandleFunc("/", func(http.Respon |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.Response
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: se |3:   http.HandleFunc("/", func(http.Response |4:   http.HandleFunc("/", func(http.Respons |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseW
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: eW |3:   http.HandleFunc("/", func(http.ResponseW |4:   http.HandleFunc("/", func(http.Response |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: Wr |3:   http.HandleFunc("/", func(http.ResponseWr |4:   http.HandleFunc("/", func(http.ResponseW |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: ri |3:   http.HandleFunc("/", func(http.ResponseWri |4:   http.HandleFunc("/", func(http.ResponseWr |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWrit
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: it |3:   http.HandleFunc("/", func(http.ResponseWrit |4:   http.HandleFunc("/", func(http.ResponseWri |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWrite
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: te |3:   http.HandleFunc("/", func(http.ResponseWrite |4:   http.HandleFunc("/", func(http.ResponseWrit |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: er |3:   http.HandleFunc("/", func(http.ResponseWriter |4:   http.HandleFunc("/", func(http.ResponseWrite |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: r, |3:   http.HandleFunc("/", func(http.ResponseWriter, |4:   http.HandleFunc("/", func(http.ResponseWriter |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: ,  |3:   http.HandleFunc("/", func(http.ResponseWriter,  |4:   http.HandleFunc("/", func(http.ResponseWriter, |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2:  * |3:   http.HandleFunc("/", func(http.ResponseWriter, * |4:   http.HandleFunc("/", func(http.ResponseWriter,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: *h |3:   http.HandleFunc("/", func(http.ResponseWriter, *h |4:   http.HandleFunc("/", func(http.ResponseWriter, * |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: ht |3:   http.HandleFunc("/", func(http.ResponseWriter, *ht |4:   http.HandleFunc("/", func(http.ResponseWriter, *h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: tt |3:   http.HandleFunc("/", func(http.ResponseWriter, *htt |4:   http.HandleFunc("/", func(http.ResponseWriter, *ht |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: tp |3:   http.HandleFunc("/", func(http.ResponseWriter, *http |4:   http.HandleFunc("/", func(http.ResponseWriter, *htt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: p. |3:   http.HandleFunc("/", func(http.ResponseWriter, *http. |4:   http.HandleFunc("/", func(http.ResponseWriter, *http |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *http.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: .R |3:   http.HandleFunc("/", func(http.ResponseWriter, *http.R |4:   http.HandleFunc("/", func(http.ResponseWriter, *http. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *http.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: Re |3:   http.HandleFunc("/", func(http.ResponseWriter, *http.Re |4:   http.HandleFunc("/", func(http.ResponseWriter, *http.R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *http.Requ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: equ |3:   http.HandleFunc("/", func(http.ResponseWriter, *http.Requ |4:   http.HandleFunc("/", func(http.ResponseWriter, *http.Re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *http.Reque
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: ue |3:   http.HandleFunc("/", func(http.ResponseWriter, *http.Reque |4:   http.HandleFunc("/", func(http.ResponseWriter, *http.Requ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *http.Reques
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: es |3:   http.HandleFunc("/", func(http.ResponseWriter, *http.Reques |4:   http.HandleFunc("/", func(http.ResponseWriter, *http.Reque |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: st |3:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request |4:   http.HandleFunc("/", func(http.ResponseWriter, *http.Reques |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request)) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 65
󰘫  |1: delta |2: t))  |3:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request))  |4:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request)) {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 66
󰘫  |1: delta |2:  { |3:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request)) { |4:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request))  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ttp.HandleFunc("/", func(http.ResponseWriter, *http.Request)) { |3:      |4:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request)) { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:     |3:    |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:    |3:  |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request)) {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 66
󰘫  |1: delta |2:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request)) { |3:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request)) { |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request)) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 65
󰘫  |1: delta |2:  { |3:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request))  |4:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request)) { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 64
󰘫  |1: delta |2: )  |3:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request)  |4:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request))  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request) {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 65
󰘫  |1: delta |2:  { |3:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request) { |4:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request)  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ttp.HandleFunc("/", func(http.ResponseWriter, *http.Request) { |3:      |4:   http.HandleFunc("/", func(http.ResponseWriter, *http.Request) { |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:      |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  l |3:     l |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: lo |3:     lo |4:     l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: og |3:     log |4:     lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: g. |3:     log. |4:     log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Print
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: .Print |3:     log.Print |4:     log. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: tl |3:     log.Printl |4:     log.Print |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: ln |3:     log.Println |4:     log.Printl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: n( |3:     log.Println( |4:     log.Println |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: (" |3:     log.Println(" |4:     log.Println( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: "H |3:     log.Println("H |4:     log.Println(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("He
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: He |3:     log.Println("He |4:     log.Println("H |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("Hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: el |3:     log.Println("Hel |4:     log.Println("He |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("Hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ll |3:     log.Println("Hell |4:     log.Println("Hel |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("Hello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: lo |3:     log.Println("Hello |4:     log.Println("Hell |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("Hello 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: o  |3:     log.Println("Hello  |4:     log.Println("Hello |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("Hello W
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2:  W |3:     log.Println("Hello W |4:     log.Println("Hello  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("Hello Wo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: Wo |3:     log.Println("Hello Wo |4:     log.Println("Hello W |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("Hello Wor
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: or |3:     log.Println("Hello Wor |4:     log.Println("Hello Wo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("Hello Worl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: rl |3:     log.Println("Hello Worl |4:     log.Println("Hello Wor |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("Hello World
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ld |3:     log.Println("Hello World |4:     log.Println("Hello Worl |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:  
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2:   |3:   |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: i |3: i |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: im
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: im |3: im |4: i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: imp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: mp |3: imp |4: im |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: impo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: po |3: impo |4: imp |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: impor
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: or |3: impor |4: impo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: rt |3: import |4: impor |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: t  |3: import  |4: import |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2:  " |3: import " |4: import  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: "l |3: import "l |4: import " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: lo |3: import "lo |4: import "l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: og |3: import "log |4: import "lo |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: import "lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: import "lo |3: import "lo |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   })
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ort "lo |3:   }) |4: import "lo |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   /
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  / |3:   / |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   //
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: // |3:   // |4:   / |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: /  |3:   //  |4:   // |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  g |3:   // g |4:   //  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // gr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: gr |3:   // gr |4:   // g |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // gre
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: re |3:   // gre |4:   // gr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // gree
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ee |3:   // gree |4:   // gre |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greed
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: ed |3:   // greed |4:   // gree |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greed 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: d  |3:   // greed  |4:   // greed |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greed
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: d  |3:   // greed |4:   // greed  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: dy |3:   // greedy |4:   // greed |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: y  |3:   // greedy  |4:   // greedy |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy m
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2:  m |3:   // greedy m |4:   // greedy  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy ma
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: ma |3:   // greedy ma |4:   // greedy m |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy mat
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: at |3:   // greedy mat |4:   // greedy ma |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: tc |3:   // greedy matc |4:   // greedy mat |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy match
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: ch |3:   // greedy match |4:   // greedy matc |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: hing |3:   // greedy matching |4:   // greedy match |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: g  |3:   // greedy matching  |4:   // greedy matching |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: g  |3:   // greedy matching |4:   // greedy matching  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: g  |3:   // greedy matching  |4:   // greedy matching |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching a
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  a |3:   // greedy matching a |4:   // greedy matching  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching an
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: an |3:   // greedy matching an |4:   // greedy matching a |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching any
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: ny |3:   // greedy matching any |4:   // greedy matching an |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anyt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: yt |3:   // greedy matching anyt |4:   // greedy matching any |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anyth
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: th |3:   // greedy matching anyth |4:   // greedy matching anyt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: hing |3:   // greedy matching anything |4:   // greedy matching anyth |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2: g  |3:   // greedy matching anything  |4:   // greedy matching anything |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything o
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2:  o |3:   // greedy matching anything o |4:   // greedy matching anything  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything othe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: othe |3:   // greedy matching anything othe |4:   // greedy matching anything o |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything othee
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 35
󰘫  |1: delta |2: ee |3:   // greedy matching anything othee |4:   // greedy matching anything othe |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything otheer
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 36
󰘫  |1: delta |2: er |3:   // greedy matching anything otheer |4:   // greedy matching anything othee |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything otheer 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 37
󰘫  |1: delta |2: r  |3:   // greedy matching anything otheer  |4:   // greedy matching anything otheer |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything otheer
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 36
󰘫  |1: delta |2: r  |3:   // greedy matching anything otheer |4:   // greedy matching anything otheer  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything othee
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 35
󰘫  |1: delta |2: er |3:   // greedy matching anything othee |4:   // greedy matching anything otheer |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything othe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: ee |3:   // greedy matching anything othe |4:   // greedy matching anything othee |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything oth
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 33
󰘫  |1: delta |2: he |3:   // greedy matching anything oth |4:   // greedy matching anything othe |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything othr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: hr |3:   // greedy matching anything othr |4:   // greedy matching anything oth |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything oth
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 33
󰘫  |1: delta |2: hr |3:   // greedy matching anything oth |4:   // greedy matching anything othr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything othe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: he |3:   // greedy matching anything othe |4:   // greedy matching anything oth |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 35
󰘫  |1: delta |2: er |3:   // greedy matching anything other |4:   // greedy matching anything othe |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 36
󰘫  |1: delta |2: r  |3:   // greedy matching anything other  |4:   // greedy matching anything other |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other that
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 40
󰘫  |1: delta |2:  that |3:   // greedy matching anything other that |4:   // greedy matching anything other  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other tha
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 39
󰘫  |1: delta |2: at |3:   // greedy matching anything other tha |4:   // greedy matching anything other that |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 40
󰘫  |1: delta |2: an |3:   // greedy matching anything other than |4:   // greedy matching anything other tha |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 41
󰘫  |1: delta |2: n  |3:   // greedy matching anything other than  |4:   // greedy matching anything other than |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 42
󰘫  |1: delta |2:  r |3:   // greedy matching anything other than r |4:   // greedy matching anything other than  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 43
󰘫  |1: delta |2: re |3:   // greedy matching anything other than re |4:   // greedy matching anything other than r |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 45
󰘫  |1: delta |2: equ |3:   // greedy matching anything other than requ |4:   // greedy matching anything other than re |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than reque
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 46
󰘫  |1: delta |2: ue |3:   // greedy matching anything other than reque |4:   // greedy matching anything other than requ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than reques
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 47
󰘫  |1: delta |2: es |3:   // greedy matching anything other than reques |4:   // greedy matching anything other than reque |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than request
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 48
󰘫  |1: delta |2: st |3:   // greedy matching anything other than request |4:   // greedy matching anything other than reques |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requeste
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 49
󰘫  |1: delta |2: te |3:   // greedy matching anything other than requeste |4:   // greedy matching anything other than request |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 50
󰘫  |1: delta |2: ed |3:   // greedy matching anything other than requested |4:   // greedy matching anything other than requeste |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 51
󰘫  |1: delta |2: d  |3:   // greedy matching anything other than requested  |4:   // greedy matching anything other than requested |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested with
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 55
󰘫  |1: delta |2:  with |3:   // greedy matching anything other than requested with |4:   // greedy matching anything other than requested  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested wit
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 54
󰘫  |1: delta |2: th |3:   // greedy matching anything other than requested wit |4:   // greedy matching anything other than requested with |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested wi
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 53
󰘫  |1: delta |2: it |3:   // greedy matching anything other than requested wi |4:   // greedy matching anything other than requested wit |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested wil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 54
󰘫  |1: delta |2: il |3:   // greedy matching anything other than requested wil |4:   // greedy matching anything other than requested wi |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 55
󰘫  |1: delta |2: ll |3:   // greedy matching anything other than requested will |4:   // greedy matching anything other than requested wil |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 56
󰘫  |1: delta |2: l  |3:   // greedy matching anything other than requested will  |4:   // greedy matching anything other than requested will |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 57
󰘫  |1: delta |2:  r |3:   // greedy matching anything other than requested will r |4:   // greedy matching anything other than requested will  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 58
󰘫  |1: delta |2: re |3:   // greedy matching anything other than requested will re |4:   // greedy matching anything other than requested will r |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will ret
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 59
󰘫  |1: delta |2: et |3:   // greedy matching anything other than requested will ret |4:   // greedy matching anything other than requested will re |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will retu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 60
󰘫  |1: delta |2: tu |3:   // greedy matching anything other than requested will retu |4:   // greedy matching anything other than requested will ret |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will retua
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 61
󰘫  |1: delta |2: ua |3:   // greedy matching anything other than requested will retua |4:   // greedy matching anything other than requested will retu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will retu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 60
󰘫  |1: delta |2: ua |3:   // greedy matching anything other than requested will retu |4:   // greedy matching anything other than requested will retua |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will retur
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 61
󰘫  |1: delta |2: ur |3:   // greedy matching anything other than requested will retur |4:   // greedy matching anything other than requested will retu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will return
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 62
󰘫  |1: delta |2: rn |3:   // greedy matching anything other than requested will return |4:   // greedy matching anything other than requested will retur |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will return 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 63
󰘫  |1: delta |2: n  |3:   // greedy matching anything other than requested will return  |4:   // greedy matching anything other than requested will return |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will return the
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 66
󰘫  |1: delta |2:  the |3:   // greedy matching anything other than requested will return the |4:   // greedy matching anything other than requested will return  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will return the 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 67
󰘫  |1: delta |2: e  |3:   // greedy matching anything other than requested will return the  |4:   // greedy matching anything other than requested will return the |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will return the "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 68
󰘫  |1: delta |2:  " |3:   // greedy matching anything other than requested will return the " |4:   // greedy matching anything other than requested will return the  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will return the "/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 69
󰘫  |1: delta |2: "/ |3:   // greedy matching anything other than requested will return the "/ |4:   // greedy matching anything other than requested will return the " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will return the "/" 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 71
󰘫  |1: delta |2: /"  |3:   // greedy matching anything other than requested will return the "/"  |4:   // greedy matching anything other than requested will return the "/ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will return the "/" function
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 79
󰘫  |1: delta |2:  function |3:   // greedy matching anything other than requested will return the "/" function |4:   // greedy matching anything other than requested will return the "/"  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will return the "/" function.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 80
󰘫  |1: delta |2: n. |3:   // greedy matching anything other than requested will return the "/" function. |4:   // greedy matching anything other than requested will return the "/" function |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy matching anything other than requested will return the "/" function
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 79
󰘫  |1: delta |2:   // greedy matching anything other than requested will return the "/" function |3:   // greedy matching anything other than requested will return the "/" function |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2:   http.HandleFunc("/ |3:   http.HandleFunc("/ |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/good
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: /good |3:   http.HandleFunc("/good |4:   http.HandleFunc("/ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/goodb
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: db |3:   http.HandleFunc("/goodb |4:   http.HandleFunc("/good |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/goodby
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: by |3:   http.HandleFunc("/goodby |4:   http.HandleFunc("/goodb |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/goodbye
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: ye |3:   http.HandleFunc("/goodbye |4:   http.HandleFunc("/goodby |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("Hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2:     log.Println("Hell |3:     log.Println("Hell |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("Hella
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: la |3:     log.Println("Hella |4:     log.Println("Hell |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("Hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: la |3:     log.Println("Hell |4:     log.Println("Hella |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("Hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ll |3:     log.Println("Hel |4:     log.Println("Hell |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("He
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: el |3:     log.Println("He |4:     log.Println("Hel |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: He |3:     log.Println("H |4:     log.Println("He |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: "H |3:     log.Println(" |4:     log.Println("H |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: "g |3:     log.Println("g |4:     log.Println(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("go
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: go |3:     log.Println("go |4:     log.Println("g |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("good
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ood |3:     log.Println("good |4:     log.Println("go |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("goodb
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: db |3:     log.Println("goodb |4:     log.Println("good |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("goodby
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: by |3:     log.Println("goodby |4:     log.Println("goodb |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("goodbye
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ye |3:     log.Println("goodbye |4:     log.Println("goodby |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("goodbye World"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2:     log.Println("goodbye World" |3:     log.Println("goodbye World" |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   })
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  log.Println("goodbye World" |3:   }) |4:     log.Println("goodbye World" |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:      |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2:   http.HandleFunc("/", func(http.ResponseWriter,  |3:   http.HandleFunc("/", func(http.ResponseWriter,  |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(http.ResponseWriter, r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2:  r |3:   http.HandleFunc("/", func(http.ResponseWriter, r |4:   http.HandleFunc("/", func(http.ResponseWriter,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  r |3:     r |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ri |3:     ri |4:     r |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: ri |3:     r |4:     ri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     r.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: r. |3:     r. |4:     r |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     r.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:     r. |3:     r. |4:     r. |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: r. |3:     r |4:     r. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  r |3:      |4:     r |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  i |3:     i |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: io |3:     io |4:     i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     iou
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ou |3:     iou |4:     io |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     iout
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ut |3:     iout |4:     iou |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     iouti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ti |3:     iouti |4:     iout |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: il |3:     ioutil |4:     iouti |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: l. |3:     ioutil. |4:     ioutil |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: .R |3:     ioutil.R |4:     ioutil. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: Re |3:     ioutil.Re |4:     ioutil.R |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil.Rea
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: ea |3:     ioutil.Rea |4:     ioutil.Re |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil.Read
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: ad |3:     ioutil.Read |4:     ioutil.Rea |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil.ReadAll
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: dAll |3:     ioutil.ReadAll |4:     ioutil.Read |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil.ReadAll(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: l( |3:     ioutil.ReadAll( |4:     ioutil.ReadAll |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: virtual text only : |2:     log.Println("Hello World") |3:  |4: { 13, 19 }
 |5: 13 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 12 |3: 13 |4: { "                     r io.Reader", "Comment" }

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil.ReadAll(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2:     ioutil.ReadAll( |3:     ioutil.ReadAll( |4:     ioutil.ReadAll( |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: virtual text only : |2:     log.Println("Hello World") |3:  |4: { 13, 19 }
 |5: 13 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 12 |3: 13 |4: { "                     r io.Reader", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil.ReadAll(r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: (r |3:     ioutil.ReadAll(r |4:     ioutil.ReadAll( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: virtual text only : |2:     log.Println("Hello World") |3:  |4: { 13, 20 }
 |5: 12
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 12 |3: 12 |4: { "  r io.Reader", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil.ReadAll(r.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: r. |3:     ioutil.ReadAll(r. |4:     ioutil.ReadAll(r |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: virtual text only : |2:     log.Println("Hello World") |3:  |4: { 13, 21 }
 |5: 12
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 12 |3: 12 |4: { "  r io.Reader", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil.ReadAll(r.B
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: .B |3:     ioutil.ReadAll(r.B |4:     ioutil.ReadAll(r. |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: virtual text only : |2:     log.Println("Hello World") |3:  |4: { 13, 22 }
 |5: 12
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 12 |3: 12 |4: { "  r io.Reader", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil.ReadAll(r.Bo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: Bo |3:     ioutil.ReadAll(r.Bo |4:     ioutil.ReadAll(r.B |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: virtual text only : |2:     log.Println("Hello World") |3:  |4: { 13, 23 }
 |5: 12
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 12 |3: 12 |4: { "  r io.Reader", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil.ReadAll(r.Bod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: od |3:     ioutil.ReadAll(r.Bod |4:     ioutil.ReadAll(r.Bo |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: virtual text only : |2:     log.Println("Hello World") |3:  |4: { 13, 24 }
 |5: 12
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 12 |3: 12 |4: { "  r io.Reader", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil.ReadAll(r.Body
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: dy |3:     ioutil.ReadAll(r.Body |4:     ioutil.ReadAll(r.Bod |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: virtual text only : |2:     log.Println("Hello World") |3:  |4: { 13, 25 }
 |5: 12
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 12 |3: 12 |4: { "  r io.Reader", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil.ReadAll(r.Bod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2:     ioutil.ReadAll(r.Bod |3:     ioutil.ReadAll(r.Bod |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  line_to_cursor = "    ioutil.ReadAll(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioutil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:     ioutil |3:     ioutil |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     iouti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: il |3:     iouti |4:     ioutil |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     iout
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ti |3:     iout |4:     iouti |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     iou
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ut |3:     iou |4:     iout |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ou |3:     io |4:     iou |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:     i |3:     i |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  d |3:     d |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: d, |3:     d, |4:     d |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ,  |3:     d,  |4:     d, |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  _ |3:     d, _ |4:     d,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: _  |3:     d, _  |4:     d, _ |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 6,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara:
󰘫  |1: no next param
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ =
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  = |3:     d, _ = |4:     d, _  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ = 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: =  |3:     d, _ =  |4:     d, _ = |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ =
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: =  |3:     d, _ = |4:     d, _ =  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  = |3:     d, _  |4:     d, _ = |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 6,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara:
󰘫  |1: no next param
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ ?
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  ? |3:     d, _ ? |4:     d, _  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 6,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara:
󰘫  |1: no next param
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  ? |3:     d, _  |4:     d, _ ? |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 6,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara:
󰘫  |1: no next param
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  : |3:     d, _ : |4:     d, _  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: := |3:     d, _ := |4:     d, _ : |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: =  |3:     d, _ :=  |4:     d, _ := |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  l |3:     l |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: lo |3:     lo |4:     l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: og |3:     log |4:     lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log>
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: g> |3:     log> |4:     log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: g> |3:     log |4:     log> |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: g. |3:     log. |4:     log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Print
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: .Print |3:     log.Print |4:     log. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: tf |3:     log.Printf |4:     log.Print |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: f( |3:     log.Printf( |4:     log.Printf |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Printf(format string, v ...any) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 15 }
 |5: 14 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 14 |4: { "                 format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: (" |3:     log.Printf(" |4:     log.Printf( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("D
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: "D |3:     log.Printf("D |4:     log.Printf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Da
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: Da |3:     log.Printf("Da |4:     log.Printf("D |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Dat
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: at |3:     log.Printf("Dat |4:     log.Printf("Da |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Data
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: ta |3:     log.Printf("Data |4:     log.Printf("Dat |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Data 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: a  |3:     log.Printf("Data  |4:     log.Printf("Data |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Data %
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2:  % |3:     log.Printf("Data % |4:     log.Printf("Data  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Data %s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: %s |3:     log.Printf("Data %s |4:     log.Printf("Data % |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Data %s",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: s", |3:     log.Printf("Data %s", |4:     log.Printf("Data %s |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    log.Printf("Data %s",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, v ...any)
󰘫  |1: nextpara: |2: {
  label = "v ...any"
}

󰘫  |1: func |2: Printf(format string, v ...any) |3: {
  label = "v ...any"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 25 }
 |5: 14 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 14 |4: { "                           v ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Data %s", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: ,  |3:     log.Printf("Data %s",  |4:     log.Printf("Data %s", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    log.Printf("Data %s",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, v ...any)
󰘫  |1: nextpara: |2: {
  label = "v ...any"
}

󰘫  |1: func |2: Printf(format string, v ...any) |3: {
  label = "v ...any"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 26 }
 |5: 14 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 14 |4: { "                            v ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Data %s", d
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2:  d |3:     log.Printf("Data %s", d |4:     log.Printf("Data %s",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    log.Printf("Data %s",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, v ...any)
󰘫  |1: nextpara: |2: {
  label = "v ...any"
}

󰘫  |1: func |2: Printf(format string, v ...any) |3: {
  label = "v ...any"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 27 }
 |5: 13
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 13 |4: { "  v ...any", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Data %s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2:     log.Printf("Data %s |3:     log.Printf("Data %s |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Data %s\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: s\ |3:     log.Printf("Data %s\ |4:     log.Printf("Data %s |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Data %s\n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: \n |3:     log.Printf("Data %s\n |4:     log.Printf("Data %s\ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Data %s\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2:     log.Printf("Data %s\ |3:     log.Printf("Data %s\ |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("Hello W
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2:     log.Println("Hello W |3:     log.Println("Hello W |4:     log.Printf("Data %s\ |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:     d, _ |3:     d, _ |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  _ |3:     d,  |4:     d, _ |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 6,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara:
󰘫  |1: no next param
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, e
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  e |3:     d, e |4:     d,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: er |3:     d, er |4:     d, e |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: rr |3:     d, err |4:     d, er |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:     d, er |3:     d, er |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  l |3:     l |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: lo |3:     lo |4:     l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: og |3:     log |4:     lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: g. |3:     log. |4:     log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Print
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: .Print |3:     log.Print |4:     log. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: tf |3:     log.Printf |4:     log.Print |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: f( |3:     log.Printf( |4:     log.Printf |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 14
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Printf(format string, v ...any) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     log.Printf("Data %s\n", d) |3:  |4: { 15, 15 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 14 |3: 15 |4: { "                 format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf(R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: (R |3:     log.Printf(R |4:     log.Printf( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 14
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Printf(format string, v ...any) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     log.Printf("Data %s\n", d) |3:  |4: { 15, 16 }
 |5: 14
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 14 |3: 14 |4: { "  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: (R |3:     log.Printf( |4:     log.Printf(R |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 14
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Printf(format string, v ...any) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     log.Printf("Data %s\n", d) |3:  |4: { 15, 15 }
 |5: 15 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 14 |3: 15 |4: { "                 format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf(e
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: (e |3:     log.Printf(e |4:     log.Printf( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 14
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Printf(format string, v ...any) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     log.Printf("Data %s\n", d) |3:  |4: { 15, 16 }
 |5: 14
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 14 |3: 14 |4: { "  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf(er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: er |3:     log.Printf(er |4:     log.Printf(e |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 14
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Printf(format string, v ...any) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     log.Printf("Data %s\n", d) |3:  |4: { 15, 17 }
 |5: 14
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 14 |3: 14 |4: { "  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf(err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: rr |3:     log.Printf(err |4:     log.Printf(er |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 14
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Printf(format string, v ...any) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     log.Printf("Data %s\n", d) |3:  |4: { 15, 18 }
 |5: 14
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 14 |3: 14 |4: { "  format string", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf(er
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2:     log.Printf(er |3:     log.Printf(er |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 14
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "    log.Printf(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  line_to_cursor = "    log.Printf(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Printf(format string, v ...any) |3: {
  label = "format string"
}

󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   // greedy match
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2:   // greedy match |3:   // greedy match |4:     log.Printf(er |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2:   http.HandleFunc("/", func( |3:   http.HandleFunc("/", func( |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: (r |3:   http.HandleFunc("/", func(r |4:   http.HandleFunc("/", func( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(rw
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: rw |3:   http.HandleFunc("/", func(rw |4:   http.HandleFunc("/", func(r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(rw 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2: w  |3:   http.HandleFunc("/", func(rw  |4:   http.HandleFunc("/", func(rw |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", func(rw
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 28
󰘫  |1: delta |2:   http.HandleFunc("/", func(rw |3:   http.HandleFunc("/", func(rw |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, err := io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:     d, err := io |3:     d, err := io |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, err := iou
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ou |3:     d, err := iou |4:     d, err := io |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, err := iout
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ut |3:     d, err := iout |4:     d, err := iou |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, err := iouti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ti |3:     d, err := iouti |4:     d, err := iout |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, err := ioutil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: il |3:     d, err := ioutil |4:     d, err := iouti |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, err := iouti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:     d, err := iouti |3:     d, err := iouti |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, err
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:     d, err |3:     d, err |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: niI
󰘫  |1: mode:  niI  |2: niI
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:     d,  |3:     d,  |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 6,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara:
󰘫  |1: no next param
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  _ |3:     d, _ |4:     d,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:     d,  |3:     d,  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Data
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2:     log.Printf("Data |3:     log.Printf("Data |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Dat
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: ta |3:     log.Printf("Dat |4:     log.Printf("Data |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Da
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: at |3:     log.Printf("Da |4:     log.Printf("Dat |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("D
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: Da |3:     log.Printf("D |4:     log.Printf("Da |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: "D |3:     log.Printf(" |4:     log.Printf("D |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: "H |3:     log.Printf("H |4:     log.Printf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("He
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: He |3:     log.Printf("He |4:     log.Printf("H |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: el |3:     log.Printf("Hel |4:     log.Printf("He |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: ll |3:     log.Printf("Hell |4:     log.Printf("Hel |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Hello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: lo |3:     log.Printf("Hello |4:     log.Printf("Hell |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2:     log.Printf("Hell |3:     log.Printf("Hell |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Hello 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: lo  |3:     log.Printf("Hello  |4:     log.Printf("Hell |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: llo  |3:     log.Printf("Hel |4:     log.Printf("Hello  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2:     log.Printf("Hel |3:     log.Printf("Hel |4:     log.Printf("Hel |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:     d, _ := ioutil. |3:     d, _ := ioutil. |4:     log.Printf("Hel |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/goodbye", func(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2:   http.HandleFunc("/goodbye", func( |3:   http.HandleFunc("/goodbye", func( |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/goodbye", func(r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: (r |3:   http.HandleFunc("/goodbye", func(r |4:   http.HandleFunc("/goodbye", func( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/goodbye", func(rw
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: rw |3:   http.HandleFunc("/goodbye", func(rw |4:   http.HandleFunc("/goodbye", func(r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/goodbye", func(rw 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: w  |3:   http.HandleFunc("/goodbye", func(rw  |4:   http.HandleFunc("/goodbye", func(rw |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/goodbye", func(rw http.ResponseWriter, r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 58
󰘫  |1: delta |2:  http.ResponseWriter, r |3:   http.HandleFunc("/goodbye", func(rw http.ResponseWriter, r |4:   http.HandleFunc("/goodbye", func(rw  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  d |3:     d |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: d, |3:     d, |4:     d |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 6,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara:
󰘫  |1: no next param
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ,  |3:     d,  |4:     d, |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 6,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara:
󰘫  |1: no next param
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  _ |3:     d, _ |4:     d,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: _  |3:     d, _  |4:     d, _ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  : |3:     d, _ : |4:     d, _  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: := |3:     d, _ := |4:     d, _ : |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: =  |3:     d, _ :=  |4:     d, _ := |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  i |3:     d, _ := i |4:     d, _ :=  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: io |3:     d, _ := io |4:     d, _ := i |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iou
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ou |3:     d, _ := iou |4:     d, _ := io |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iout
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ut |3:     d, _ := iout |4:     d, _ := iou |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iouti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ti |3:     d, _ := iouti |4:     d, _ := iout |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: il |3:     d, _ := ioutil |4:     d, _ := iouti |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: l. |3:     d, _ := ioutil. |4:     d, _ := ioutil |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: .R |3:     d, _ := ioutil.R |4:     d, _ := ioutil. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: Re |3:     d, _ := ioutil.Re |4:     d, _ := ioutil.R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil.Rea
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ea |3:     d, _ := ioutil.Rea |4:     d, _ := ioutil.Re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil.Read
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ad |3:     d, _ := ioutil.Read |4:     d, _ := ioutil.Rea |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil.ReadAll(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: dAll( |3:     d, _ := ioutil.ReadAll( |4:     d, _ := ioutil.Read |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 27,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d, _ := ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d, _ := ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: virtual text only : |2:     log.Println("goodbye World") |3:   })  |4: { 19, 27 }
 |5: 19 |6:   }) 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 19 |4: { "                        r io.Reader", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil.ReadAll(r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: (r |3:     d, _ := ioutil.ReadAll(r |4:     d, _ := ioutil.ReadAll( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 27,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d, _ := ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d, _ := ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: virtual text only : |2:     log.Println("goodbye World") |3:   })  |4: { 19, 28 }
 |5: 18
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 18 |4: { "  r io.Reader", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil.ReadAll(r.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: r. |3:     d, _ := ioutil.ReadAll(r. |4:     d, _ := ioutil.ReadAll(r |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 27,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d, _ := ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d, _ := ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: virtual text only : |2:     log.Println("goodbye World") |3:   })  |4: { 19, 29 }
 |5: 18
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 18 |4: { "  r io.Reader", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil.ReadAll(r.B
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: .B |3:     d, _ := ioutil.ReadAll(r.B |4:     d, _ := ioutil.ReadAll(r. |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 27,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d, _ := ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d, _ := ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: virtual text only : |2:     log.Println("goodbye World") |3:   })  |4: { 19, 30 }
 |5: 18
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 18 |4: { "  r io.Reader", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil.ReadAll(r.Bo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: Bo |3:     d, _ := ioutil.ReadAll(r.Bo |4:     d, _ := ioutil.ReadAll(r.B |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 27,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d, _ := ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d, _ := ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: virtual text only : |2:     log.Println("goodbye World") |3:   })  |4: { 19, 31 }
 |5: 18
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 18 |4: { "  r io.Reader", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil.ReadAll(r.Bod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: od |3:     d, _ := ioutil.ReadAll(r.Bod |4:     d, _ := ioutil.ReadAll(r.Bo |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 27,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d, _ := ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d, _ := ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: virtual text only : |2:     log.Println("goodbye World") |3:   })  |4: { 19, 32 }
 |5: 18
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 18 |4: { "  r io.Reader", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil.ReadAll(r.Body
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: dy |3:     d, _ := ioutil.ReadAll(r.Body |4:     d, _ := ioutil.ReadAll(r.Bod |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 27,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d, _ := ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.\n\nDeprecated: As of Go 1.16, this function simply calls [io.ReadAll](https://pkg.go.dev/io#ReadAll)."
      },
      label = "ReadAll(r io.Reader) ([]byte, error)",
      parameters = { {
          label = "r io.Reader"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    d, _ := ioutil.ReadAll(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "r io.Reader"
}

󰘫  |1: func |2: ReadAll(r io.Reader) ([]byte, error) |3: {
  label = "r io.Reader"
}

󰘫  |1: virtual text only : |2:     log.Println("goodbye World") |3:   })  |4: { 19, 33 }
 |5: 17 |6:     log.Println("goodbye World")
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 17 |4: { "  r io.Reader", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  l |3:     l |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: lo |3:     lo |4:     l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: og |3:     log |4:     lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: g. |3:     log. |4:     log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Print
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: .Print |3:     log.Print |4:     log. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: tf |3:     log.Printf |4:     log.Print |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: f( |3:     log.Printf( |4:     log.Printf |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 19
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    log.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Printf(format string, v ...any) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := ioutil.ReadAll(r.Body) |3:   })  |4: { 20, 15 }
 |5: 20 |6:   }) 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 19 |3: 20 |4: { "            format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: (" |3:     log.Printf(" |4:     log.Printf( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("G
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: "G |3:     log.Printf("G |4:     log.Printf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: "G |3:     log.Printf(" |4:     log.Printf("G |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Good
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: "Good |3:     log.Printf("Good |4:     log.Printf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Goodb
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: db |3:     log.Printf("Goodb |4:     log.Printf("Good |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Goodby
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: by |3:     log.Printf("Goodby |4:     log.Printf("Goodb |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Goodbye
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: ye |3:     log.Printf("Goodbye |4:     log.Printf("Goodby |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Goodbye 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: e  |3:     log.Printf("Goodbye  |4:     log.Printf("Goodbye |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Goodbye %
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2:  % |3:     log.Printf("Goodbye % |4:     log.Printf("Goodbye  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Goodbye %s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: %s |3:     log.Printf("Goodbye %s |4:     log.Printf("Goodbye % |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Goodbye %s\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: s\ |3:     log.Printf("Goodbye %s\ |4:     log.Printf("Goodbye %s |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Goodbye %s\n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: \n |3:     log.Printf("Goodbye %s\n |4:     log.Printf("Goodbye %s\ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Goodbye %s\n",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: n", |3:     log.Printf("Goodbye %s\n", |4:     log.Printf("Goodbye %s\n |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 19
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    log.Printf("Goodbye %s\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, v ...any)
󰘫  |1: nextpara: |2: {
  label = "v ...any"
}

󰘫  |1: func |2: Printf(format string, v ...any) |3: {
  label = "v ...any"
}

󰘫  |1: virtual text only : |2:     d, _ := ioutil.ReadAll(r.Body) |3:   })  |4: { 20, 30 }
 |5: 20 |6:   }) 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 19 |3: 20 |4: { "                           v ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Goodbye %s\n", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: ,  |3:     log.Printf("Goodbye %s\n",  |4:     log.Printf("Goodbye %s\n", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 19
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    log.Printf("Goodbye %s\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, v ...any)
󰘫  |1: nextpara: |2: {
  label = "v ...any"
}

󰘫  |1: func |2: Printf(format string, v ...any) |3: {
  label = "v ...any"
}

󰘫  |1: virtual text only : |2:     d, _ := ioutil.ReadAll(r.Body) |3:   })  |4: { 20, 31 }
 |5: 20 |6:   }) 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 19 |3: 20 |4: { "                            v ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("Goodbye %s\n", d
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2:  d |3:     log.Printf("Goodbye %s\n", d |4:     log.Printf("Goodbye %s\n",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 19
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf."
      },
      label = "Printf(format string, v ...any)",
      parameters = { {
          label = "format string"
        }, {
          label = "v ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    log.Printf("Goodbye %s\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Printf(format string, v ...any)
󰘫  |1: nextpara: |2: {
  label = "v ...any"
}

󰘫  |1: func |2: Printf(format string, v ...any) |3: {
  label = "v ...any"
}

󰘫  |1: virtual text only : |2:     d, _ := ioutil.ReadAll(r.Body) |3:   })  |4: { 20, 32 }
 |5: 19
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 19 |3: 19 |4: { "  v ...any", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:      
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:       |3:       |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   })
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:   }) |3:   }) |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:     d, _ := ioutil |3:     d, _ := ioutil |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iouti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: il |3:     d, _ := iouti |4:     d, _ := ioutil |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iout
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ti |3:     d, _ := iout |4:     d, _ := iouti |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iou
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ut |3:     d, _ := iou |4:     d, _ := iout |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ou |3:     d, _ := io |4:     d, _ := iou |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:     d, _ := ioutil |3:     d, _ := ioutil |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iouti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: il |3:     d, _ := iouti |4:     d, _ := ioutil |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iout
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ti |3:     d, _ := iout |4:     d, _ := iouti |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iou
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ut |3:     d, _ := iou |4:     d, _ := iout |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ou |3:     d, _ := io |4:     d, _ := iou |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/ioutil"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: 	"io/ioutil" |3: 	"io/ioutil" |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/iouti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: il" |3: 	"io/iouti |4: 	"io/ioutil" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/iout
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ti |3: 	"io/iout |4: 	"io/iouti |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/iou
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ut |3: 	"io/iou |4: 	"io/iout |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ou |3: 	"io/io |4: 	"io/iou |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: io |3: 	"io/i |4: 	"io/io |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: /i |3: 	"io/ |4: 	"io/i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: o/ |3: 	"io |4: 	"io/ |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: c
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: c
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: 	"i |3: 	"i |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2:     log |3:     log |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: og |3:     lo |4:     log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: lo |3:     l |4:     lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  l |3:      |4:     l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  f |3:     f |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: fm |3:     fm |4:     f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: mt |3:     fmt |4:     fm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2:     log |3:     log |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: og |3:     lo |4:     log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: lo |3:     l |4:     lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  l |3:      |4:     l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  f |3:     f |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: fm |3:     fm |4:     f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: mt |3:     fmt |4:     fm |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:     fm |3:     fm |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3: 
󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  f |3:     f |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: fm |3:     fm |4:     f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: mt |3:     fmt |4:     fm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: t. |3:     fmt. |4:     fmt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: .f |3:     fmt.f |4:     fmt. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: Fprintf( |3:     fmt.Fprintf( |4:     fmt.f |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "w io.Writer"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "w io.Writer"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 16 }
 |5: 14 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 14 |4: { "                  w io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: (i |3:     fmt.Fprintf(i |4:     fmt.Fprintf( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "w io.Writer"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "w io.Writer"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 17 }
 |5: 13
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 13 |4: { "  w io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: (i |3:     fmt.Fprintf( |4:     fmt.Fprintf(i |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "w io.Writer"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "w io.Writer"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 16 }
 |5: 14 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 14 |4: { "                  w io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: (r |3:     fmt.Fprintf(r |4:     fmt.Fprintf( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "w io.Writer"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "w io.Writer"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 17 }
 |5: 13
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 13 |4: { "  w io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: rw |3:     fmt.Fprintf(rw |4:     fmt.Fprintf(r |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "w io.Writer"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "w io.Writer"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 18 }
 |5: 13
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 13 |4: { "  w io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: w, |3:     fmt.Fprintf(rw, |4:     fmt.Fprintf(rw |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 19 }
 |5: 14 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 14 |4: { "                     format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: ,  |3:     fmt.Fprintf(rw,  |4:     fmt.Fprintf(rw, |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 20 }
 |5: 14 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 14 |4: { "                      format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2:  R |3:     fmt.Fprintf(rw, R |4:     fmt.Fprintf(rw,  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 21 }
 |5: 13
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 13 |4: { "  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2:  R |3:     fmt.Fprintf(rw,  |4:     fmt.Fprintf(rw, R |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 20 }
 |5: 14 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 14 |4: { "                      format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2:  " |3:     fmt.Fprintf(rw, " |4:     fmt.Fprintf(rw,  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 21 }
 |5: 14 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 14 |4: { "                       format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: "H |3:     fmt.Fprintf(rw, "H |4:     fmt.Fprintf(rw, " |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 22 }
 |5: 14 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 14 |4: { "                        format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "He
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: He |3:     fmt.Fprintf(rw, "He |4:     fmt.Fprintf(rw, "H |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 23 }
 |5: 13
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 13 |4: { "  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: el |3:     fmt.Fprintf(rw, "Hel |4:     fmt.Fprintf(rw, "He |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 24 }
 |5: 13
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 13 |4: { "  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: ll |3:     fmt.Fprintf(rw, "Hell |4:     fmt.Fprintf(rw, "Hel |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 25 }
 |5: 13
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 13 |4: { "  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: lo |3:     fmt.Fprintf(rw, "Hello |4:     fmt.Fprintf(rw, "Hell |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 26 }
 |5: 13
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 13 |4: { "  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: o  |3:     fmt.Fprintf(rw, "Hello  |4:     fmt.Fprintf(rw, "Hello |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 27 }
 |5: 14 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 14 |4: { "                             format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello %
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2:  % |3:     fmt.Fprintf(rw, "Hello % |4:     fmt.Fprintf(rw, "Hello  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 28 }
 |5: 14 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 14 |4: { "                              format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello %s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: %s |3:     fmt.Fprintf(rw, "Hello %s |4:     fmt.Fprintf(rw, "Hello % |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 29 }
 |5: 14 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 14 |4: { "                               format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello %s\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: s\ |3:     fmt.Fprintf(rw, "Hello %s\ |4:     fmt.Fprintf(rw, "Hello %s |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 30 }
 |5: 14 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 14 |4: { "                                format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello %s\n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: \n |3:     fmt.Fprintf(rw, "Hello %s\n |4:     fmt.Fprintf(rw, "Hello %s\ |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 31 }
 |5: 12 |6:     d, _ := io.ReadAll(r.Body)
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 12 |4: { "  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello %s\n",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 33
󰘫  |1: delta |2: n", |3:     fmt.Fprintf(rw, "Hello %s\n", |4:     fmt.Fprintf(rw, "Hello %s\n |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 33,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    fmt.Fprintf(rw, "Hello %s\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 33 }
 |5: 12 |6:     d, _ := io.ReadAll(r.Body)
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 12 |4: { "     a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello %s\n", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 33
󰘫  |1: delta |2: ,  |3:     fmt.Fprintf(rw, "Hello %s\n",  |4:     fmt.Fprintf(rw, "Hello %s\n", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 33,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    fmt.Fprintf(rw, "Hello %s\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 34 }
 |5: 12 |6:     d, _ := io.ReadAll(r.Body)
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 12 |4: { "      a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello %s\n", d
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 33
󰘫  |1: delta |2:  d |3:     fmt.Fprintf(rw, "Hello %s\n", d |4:     fmt.Fprintf(rw, "Hello %s\n",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 33,
      line = 13
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    fmt.Fprintf(rw, "Hello %s\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:  |4: { 14, 35 }
 |5: 12 |6:     d, _ := io.ReadAll(r.Body)
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 13 |3: 12 |4: { "       a ...any", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  f |3:     f |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: fm |3:     fm |4:     f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fms
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ms |3:     fms |4:     fm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ms |3:     fm |4:     fms |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: mt |3:     fmt |4:     fm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: t. |3:     fmt. |4:     fmt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: .f |3:     fmt.f |4:     fmt. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: Fprintf |3:     fmt.Fprintf |4:     fmt.f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.FormatString
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: String |3:     fmt.FormatString |4:     fmt.Fprintf |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Formatter
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: ring |3:     fmt.Formatter |4:     fmt.FormatString |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprint
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: tter |3:     fmt.Fprint |4:     fmt.Formatter |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintln
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: tln |3:     fmt.Fprintln |4:     fmt.Fprint |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fscan
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: ntln |3:     fmt.Fscan |4:     fmt.Fprintln |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fscanf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: nf |3:     fmt.Fscanf |4:     fmt.Fscan |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fscanln
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: ln |3:     fmt.Fscanln |4:     fmt.Fscanf |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: Fscanln |3:     fmt.f |4:     fmt.Fscanln |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: Fprintf |3:     fmt.Fprintf |4:     fmt.f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: f( |3:     fmt.Fprintf( |4:     fmt.Fprintf |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "w io.Writer"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "w io.Writer"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 16 }
 |5: 21 |6:      
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 21 |4: { "             w io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: (r |3:     fmt.Fprintf(r |4:     fmt.Fprintf( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "w io.Writer"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "w io.Writer"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 17 }
 |5: 20
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 20 |4: { "  w io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: rw |3:     fmt.Fprintf(rw |4:     fmt.Fprintf(r |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "w io.Writer"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "w io.Writer"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 18 }
 |5: 20
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 20 |4: { "  w io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: w, |3:     fmt.Fprintf(rw, |4:     fmt.Fprintf(rw |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 19 }
 |5: 21 |6:      
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 21 |4: { "                format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: ,  |3:     fmt.Fprintf(rw,  |4:     fmt.Fprintf(rw, |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 20 }
 |5: 21 |6:      
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 21 |4: { "                 format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2:  " |3:     fmt.Fprintf(rw, " |4:     fmt.Fprintf(rw,  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 21 }
 |5: 21 |6:      
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 21 |4: { "                  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: "H |3:     fmt.Fprintf(rw, "H |4:     fmt.Fprintf(rw, " |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 22 }
 |5: 21 |6:      
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 21 |4: { "                   format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "He
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: He |3:     fmt.Fprintf(rw, "He |4:     fmt.Fprintf(rw, "H |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 23 }
 |5: 20
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 20 |4: { "  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: el |3:     fmt.Fprintf(rw, "Hel |4:     fmt.Fprintf(rw, "He |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 24 }
 |5: 20
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 20 |4: { "  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: ll |3:     fmt.Fprintf(rw, "Hell |4:     fmt.Fprintf(rw, "Hel |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 25 }
 |5: 20
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 20 |4: { "  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: lo |3:     fmt.Fprintf(rw, "Hello |4:     fmt.Fprintf(rw, "Hell |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 26 }
 |5: 20
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 20 |4: { "  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: o  |3:     fmt.Fprintf(rw, "Hello  |4:     fmt.Fprintf(rw, "Hello |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 27 }
 |5: 21 |6:      
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 21 |4: { "                        format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello %
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2:  % |3:     fmt.Fprintf(rw, "Hello % |4:     fmt.Fprintf(rw, "Hello  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 28 }
 |5: 21 |6:      
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 21 |4: { "                         format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello %s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: %s |3:     fmt.Fprintf(rw, "Hello %s |4:     fmt.Fprintf(rw, "Hello % |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 29 }
 |5: 21 |6:      
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 21 |4: { "                          format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello %s\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: s\ |3:     fmt.Fprintf(rw, "Hello %s\ |4:     fmt.Fprintf(rw, "Hello %s |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 30 }
 |5: 21 |6:      
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 21 |4: { "                           format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello %s\n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2: \n |3:     fmt.Fprintf(rw, "Hello %s\n |4:     fmt.Fprintf(rw, "Hello %s\ |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(rw,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 31 }
 |5: 19 |6:     d, _ := io.ReadAll(r.Body)
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 19 |4: { "  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello %s\n",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 33
󰘫  |1: delta |2: n", |3:     fmt.Fprintf(rw, "Hello %s\n", |4:     fmt.Fprintf(rw, "Hello %s\n |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 33,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    fmt.Fprintf(rw, "Hello %s\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 33 }
 |5: 19 |6:     d, _ := io.ReadAll(r.Body)
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 19 |4: { "     a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello %s\n", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 33
󰘫  |1: delta |2: ,  |3:     fmt.Fprintf(rw, "Hello %s\n",  |4:     fmt.Fprintf(rw, "Hello %s\n", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 33,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    fmt.Fprintf(rw, "Hello %s\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 34 }
 |5: 19 |6:     d, _ := io.ReadAll(r.Body)
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 19 |4: { "      a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello %s\n", d
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 33
󰘫  |1: delta |2:  d |3:     fmt.Fprintf(rw, "Hello %s\n", d |4:     fmt.Fprintf(rw, "Hello %s\n",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 33,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '    fmt.Fprintf(rw, "Hello %s\\n",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:     d, _ := io.ReadAll(r.Body) |3:       |4: { 21, 35 }
 |5: 19 |6:     d, _ := io.ReadAll(r.Body)
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 20 |3: 19 |4: { "       a ...any", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(rw, "Hello %s\n", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 33
󰘫  |1: delta |2:     fmt.Fprintf(rw, "Hello %s\n",  |3:     fmt.Fprintf(rw, "Hello %s\n",  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 33,
      line = 20
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = '    fmt.Fprintf(rw, "Hello %s\\n",',
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: Fprintf(w io.Writer, format string, a ...any) (n int, err error)
󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: 	"io |3: 	"io |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: o/ |3: 	"io/ |4: 	"io |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/u
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: /u |3: 	"io/u |4: 	"io/ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/ut
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ut |3: 	"io/ut |4: 	"io/u |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/uti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ti |3: 	"io/uti |4: 	"io/ut |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/util
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: il |3: 	"io/util |4: 	"io/uti |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: util |3: 	"io/i |4: 	"io/util |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: io |3: 	"io/io |4: 	"io/i |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:     d, _ := io |3:     d, _ := io |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iou
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ou |3:     d, _ := iou |4:     d, _ := io |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iout
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ut |3:     d, _ := iout |4:     d, _ := iou |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iouti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ti |3:     d, _ := iouti |4:     d, _ := iout |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: il |3:     d, _ := ioutil |4:     d, _ := iouti |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: l  |3:     d, _ := ioutil  |4:     d, _ := ioutil |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: l  |3:     d, _ := ioutil |4:     d, _ := ioutil  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:     d, _ := io |3:     d, _ := io |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iou
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ou |3:     d, _ := iou |4:     d, _ := io |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iout
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ut |3:     d, _ := iout |4:     d, _ := iou |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iouti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ti |3:     d, _ := iouti |4:     d, _ := iout |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := ioutil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: il |3:     d, _ := ioutil |4:     d, _ := iouti |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     d, _ := iouti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:     d, _ := iouti |3:     d, _ := iouti |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  f |3:     f |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: fm |3:     fm |4:     f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: mt |3:     fmt |4:     fm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: t. |3:     fmt. |4:     fmt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.print
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: .print |3:     fmt.print |4:     fmt. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.prin
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: nt |3:     fmt.prin |4:     fmt.print |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.pri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: in |3:     fmt.pri |4:     fmt.prin |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: ri |3:     fmt.pr |4:     fmt.pri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.p
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: pr |3:     fmt.p |4:     fmt.pr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: .p |3:     fmt. |4:     fmt.p |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: .Fprintf( |3:     fmt.Fprintf( |4:     fmt. |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "w io.Writer"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "w io.Writer"
}

󰘫  |1: virtual text only : |2:   http.HandleFunc("/", func(rw http.ResponseWriter, r*http.Request) { |3:     d, _ := ioutil.ReadAll(r.Body) |4: { 13, 16 }
 |5: 12
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 12 |3: 12 |4: { "  w io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: (" |3:     fmt.Fprintf(" |4:     fmt.Fprintf( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf("h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: "h |3:     fmt.Fprintf("h |4:     fmt.Fprintf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf("he
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: he |3:     fmt.Fprintf("he |4:     fmt.Fprintf("h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf("hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: el |3:     fmt.Fprintf("hel |4:     fmt.Fprintf("he |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf("hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ll |3:     fmt.Fprintf("hell |4:     fmt.Fprintf("hel |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf("hello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: lo |3:     fmt.Fprintf("hello |4:     fmt.Fprintf("hell |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf("hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: lo |3:     fmt.Fprintf("hell |4:     fmt.Fprintf("hello |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf("hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ll |3:     fmt.Fprintf("hel |4:     fmt.Fprintf("hell |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf("he
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: el |3:     fmt.Fprintf("he |4:     fmt.Fprintf("hel |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf("hei
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ei |3:     fmt.Fprintf("hei |4:     fmt.Fprintf("he |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf("he
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ei |3:     fmt.Fprintf("he |4:     fmt.Fprintf("hei |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf("h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: he |3:     fmt.Fprintf("h |4:     fmt.Fprintf("he |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: "h |3:     fmt.Fprintf(" |4:     fmt.Fprintf("h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: (" |3:     fmt.Fprintf( |4:     fmt.Fprintf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      label = "Fprintf(w io.Writer, format string, a ...any) (n int, err error)",
      parameters = { {
          label = "w io.Writer"
        }, {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Fprintf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "w io.Writer"
}

󰘫  |1: func |2: Fprintf(w io.Writer, format string, a ...any) (n int, err error) |3: {
  label = "w io.Writer"
}

󰘫  |1: virtual text only : |2:   http.HandleFunc("/", func(rw http.ResponseWriter, r*http.Request) { |3:     d, _ := ioutil.ReadAll(r.Body) |4: { 13, 16 }
 |5: 12
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 12 |3: 12 |4: { "  w io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprintf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: f( |3:     fmt.Fprintf |4:     fmt.Fprintf( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprint
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: tf |3:     fmt.Fprint |4:     fmt.Fprintf |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fprin
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: nt |3:     fmt.Fprin |4:     fmt.Fprint |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fpri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: in |3:     fmt.Fpri |4:     fmt.Fprin |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fpr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ri |3:     fmt.Fpr |4:     fmt.Fpri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Fp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: pr |3:     fmt.Fp |4:     fmt.Fpr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.F
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: Fp |3:     fmt.F |4:     fmt.Fp |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: .F |3:     fmt. |4:     fmt.F |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.print
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: .print |3:     fmt.print |4:     fmt. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: tf( |3:     fmt.Printf( |4:     fmt.print |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      label = "Printf(format string, a ...any) (n int, err error)",
      parameters = { {
          label = "format string"
        }, {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Printf(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "format string"
}

󰘫  |1: func |2: Printf(format string, a ...any) (n int, err error) |3: {
  label = "format string"
}

󰘫  |1: virtual text only : |2:   http.HandleFunc("/", func(rw http.ResponseWriter, r*http.Request) { |3:     d, _ := ioutil.ReadAll(r.Body) |4: { 13, 15 }
 |5: 12
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 12 |3: 12 |4: { "  format string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: (" |3:     fmt.Printf(" |4:     fmt.Printf( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("Had
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: "Had |3:     fmt.Printf("Had |4:     fmt.Printf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("Ha
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: ad |3:     fmt.Printf("Ha |4:     fmt.Printf("Had |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: Ha |3:     fmt.Printf("H |4:     fmt.Printf("Ha |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: "H |3:     fmt.Printf(" |4:     fmt.Printf("H |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("This
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: "This |3:     fmt.Printf("This |4:     fmt.Printf(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("This 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: s  |3:     fmt.Printf("This  |4:     fmt.Printf("This |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("This w
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2:  w |3:     fmt.Printf("This w |4:     fmt.Printf("This  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("This wo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: wo |3:     fmt.Printf("This wo |4:     fmt.Printf("This w |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("This wor
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: or |3:     fmt.Printf("This wor |4:     fmt.Printf("This wo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("This work
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: rk |3:     fmt.Printf("This work |4:     fmt.Printf("This wor |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("This works
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: ks |3:     fmt.Printf("This works |4:     fmt.Printf("This work |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("This works
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2:     fmt.Printf("This works |3:     fmt.Printf("This works |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("This works\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: s\ |3:     fmt.Printf("This works\ |4:     fmt.Printf("This works |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("This works\ 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: \  |3:     fmt.Printf("This works\  |4:     fmt.Printf("This works\ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("This works\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: \  |3:     fmt.Printf("This works\ |4:     fmt.Printf("This works\  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("This works\n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: \n |3:     fmt.Printf("This works\n |4:     fmt.Printf("This works\ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Printf("This works\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2:     fmt.Printf("This works\ |3:     fmt.Printf("This works\ |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2:     fmt. |3:     fmt. |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: mt. |3:     fm |4:     fmt. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: fm |3:     f |4:     fm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  f |3:      |4:     f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  i |3:     i |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: io |3:     io |4:     i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ioi
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: oi |3:     ioi |4:     io |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: oi |3:     io |4:     ioi |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: io |3:     i |4:     io |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  i |3:      |4:     i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Printf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:     Printf |3:     Printf |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Print
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: tf |3:     Print |4:     Printf |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Printl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: tl |3:     Printl |4:     Print |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Println
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ln |3:     Println |4:     Printl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: intln |3:     log.Println |4:     Println |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("This works\n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2:     log.Println("This works\n |3:     log.Println("This works\n |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("This works\
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: \n |3:     log.Println("This works\ |4:     log.Println("This works\n |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("This works
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: s\ |3:     log.Println("This works |4:     log.Println("This works\ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println("This work
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2:     log.Println("This work |3:     log.Println("This work |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3: 
󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/goodbye", func(rw 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2:   http.HandleFunc("/goodbye", func(rw  |3:   http.HandleFunc("/goodbye", func(rw  |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/goodbye", func(rw
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: w  |3:   http.HandleFunc("/goodbye", func(rw |4:   http.HandleFunc("/goodbye", func(rw  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/goodbye", func(r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: rw |3:   http.HandleFunc("/goodbye", func(r |4:   http.HandleFunc("/goodbye", func(rw |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/goodbye", func(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: (r |3:   http.HandleFunc("/goodbye", func( |4:   http.HandleFunc("/goodbye", func(r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/goodbye", func(http.ResponseWriter, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 55
󰘫  |1: delta |2: (http.ResponseWriter,  |3:   http.HandleFunc("/goodbye", func(http.ResponseWriter,  |4:   http.HandleFunc("/goodbye", func( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  f |3:   f |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: fm |3:   fm |4:   f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: mt |3:   fmt |4:   fm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: t. |3:   fmt. |4:   fmt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Println(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: .Println( |3:   fmt.Println( |4:   fmt. |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 14,
      line = 10
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered."
      },
      label = "Println(a ...any) (n int, err error)",
      parameters = { {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  fmt.Println(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered."
      },
      label = "Println(a ...any) (n int, err error)",
      parameters = { {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  fmt.Println(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Println(a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2: func main() { |3:   // greedy matching anything other than requested will return the "/" function. |4: { 11, 14 }
 |5: 9 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 10 |3: 9 |4: { "  a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Println("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: (" |3:   fmt.Println(" |4:   fmt.Println( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Println("p
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: "p |3:   fmt.Println("p |4:   fmt.Println(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Println("pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: pr |3:   fmt.Println("pr |4:   fmt.Println("p |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Println("pro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: ro |3:   fmt.Println("pro |4:   fmt.Println("pr |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Println("prog
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: og |3:   fmt.Println("prog |4:   fmt.Println("pro |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Println("progr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: gr |3:   fmt.Println("progr |4:   fmt.Println("prog |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Println("progra
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: ra |3:   fmt.Println("progra |4:   fmt.Println("progr |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Println("program
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: am |3:   fmt.Println("program |4:   fmt.Println("progra |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Println("program 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: m  |3:   fmt.Println("program  |4:   fmt.Println("program |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Println("program r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2:  r |3:   fmt.Println("program r |4:   fmt.Println("program  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Println("program ru
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: ru |3:   fmt.Println("program ru |4:   fmt.Println("program r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Println("program run
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: un |3:   fmt.Println("program run |4:   fmt.Println("program ru |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Println("program runs
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: ns |3:   fmt.Println("program runs |4:   fmt.Println("program run |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   fmt.Println("program run
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2:   fmt.Println("program run |3:   fmt.Println("program run |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Println
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2:     log.Println |3:     log.Println |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: ln |3:     log.Printl |4:     log.Println |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Print
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: tl |3:     log.Print |4:     log.Printl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: tf |3:     log.Printf |4:     log.Print |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     log.Printf("This
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2:     log.Printf("This |3:     log.Printf("This |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3: 
󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:      |3:      |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  f |3:     f |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: fm |3:     fm |4:     f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: mt |3:     fmt |4:     fm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: t. |3:     fmt. |4:     fmt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.print
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: .print |3:     fmt.print |4:     fmt. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Println(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: tln( |3:     fmt.Println( |4:     fmt.print |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered."
      },
      label = "Println(a ...any) (n int, err error)",
      parameters = { {
          label = "a ...any"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Println(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered."
      },
      label = "Println(a ...any) (n int, err error)",
      parameters = { {
          label = "a ...any"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "    fmt.Println(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "a ...any"
}

󰘫  |1: func |2: Println(a ...any) (n int, err error) |3: {
  label = "a ...any"
}

󰘫  |1: virtual text only : |2:     fmt.Fprintf(rw, "Hello %s\n", d) |3:  |4: { 17, 16 }
 |5: 17 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 17 |4: { "                  a ...any", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Println("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: (" |3:     fmt.Println(" |4:     fmt.Println( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Println("r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: "r |3:     fmt.Println("r |4:     fmt.Println(" |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Println("re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: re |3:     fmt.Println("re |4:     fmt.Println("r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Println("rea
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ea |3:     fmt.Println("rea |4:     fmt.Println("re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Println("reac
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ac |3:     fmt.Println("reac |4:     fmt.Println("rea |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Println("reach
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ch |3:     fmt.Println("reach |4:     fmt.Println("reac |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Println("reache
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: he |3:     fmt.Println("reache |4:     fmt.Println("reach |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Println("reached
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ed |3:     fmt.Println("reached |4:     fmt.Println("reache |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Println("reached 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: d  |3:     fmt.Println("reached  |4:     fmt.Println("reached |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Println("reached h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2:  h |3:     fmt.Println("reached h |4:     fmt.Println("reached  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Println("reached he
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: he |3:     fmt.Println("reached he |4:     fmt.Println("reached h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Println("reached her
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: er |3:     fmt.Println("reached her |4:     fmt.Println("reached he |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Println("reached here
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: re |3:     fmt.Println("reached here |4:     fmt.Println("reached her |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     fmt.Println("reached her
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2:     fmt.Println("reached her |3:     fmt.Println("reached her |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
