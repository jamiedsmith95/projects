󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: f |3: f |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: fu |3: fu |4: f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: un |3: fun |4: fu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: nc |3: func |4: fun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: c  |3: func  |4: func |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func m
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  m |3: func m |4: func  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func ma
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ma |3: func ma |4: func m |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func mai
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ai |3: func mai |4: func ma |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func main
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: in |3: func main |4: func mai |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func main(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 10
󰘫  |1: delta |2: n( |3: func main( |4: func main |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func main( 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 10
󰘫  |1: delta |2: (  |3: func main(  |4: func main( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func main(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 10
󰘫  |1: delta |2: (  |3: func main( |4: func main(  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func main() 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ()  |3: func main()  |4: func main( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func main() {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2:  { |3: func main() { |4: func main()  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: unc main() { |3:    |4: func main() { |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  h |3:   h |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ht |3:   ht |4:   h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: tt |3:   htt |4:   ht |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: tp |3:   http |4:   htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: p. |3:   http. |4:   http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.L
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: .L |3:   http.L |4:   http. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: ListenAndServe( |3:   http.ListenAndServe( |4:   http.L |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.ListenAndServe(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.ListenAndServe(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "addr string"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "addr string"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 12, 22 }
 |5: 10 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                        addr string", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2:   http.ListenAndServe( |3:   http.ListenAndServe( |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.ListenAndServe(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.ListenAndServe(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "addr string"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "addr string"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 12, 22 }
 |5: 10 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                        addr string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: (" |3:   http.ListenAndServe(" |4:   http.ListenAndServe( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: ": |3:   http.ListenAndServe(": |4:   http.ListenAndServe(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: :9 |3:   http.ListenAndServe(":9 |4:   http.ListenAndServe(": |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":90
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: 90 |3:   http.ListenAndServe(":90 |4:   http.ListenAndServe(":9 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":909
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: 09 |3:   http.ListenAndServe(":909 |4:   http.ListenAndServe(":90 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: 90 |3:   http.ListenAndServe(":9090 |4:   http.ListenAndServe(":909 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":909
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: 90 |3:   http.ListenAndServe(":909 |4:   http.ListenAndServe(":9090 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: 90 |3:   http.ListenAndServe(":9090 |4:   http.ListenAndServe(":909 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: 0", |3:   http.ListenAndServe(":9090", |4:   http.ListenAndServe(":9090 |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 12, 30 }
 |5: 10 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: ,  |3:   http.ListenAndServe(":9090",  |4:   http.ListenAndServe(":9090", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 12, 31 }
 |5: 10 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                 handler http.Handler", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2:   http.ListenAndServe(":9090",  |3:   http.ListenAndServe(":9090",  |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 12, 31 }
 |5: 10 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                 handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2:  n |3:   http.ListenAndServe(":9090", n |4:   http.ListenAndServe(":9090",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 12, 32 }
 |5: 10 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                  handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", ni
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: ni |3:   http.ListenAndServe(":9090", ni |4:   http.ListenAndServe(":9090", n |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 12, 33 }
 |5: 10 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                   handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", nil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: il |3:   http.ListenAndServe(":9090", nil |4:   http.ListenAndServe(":9090", ni |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 12, 34 }
 |5: 10 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                    handler http.Handler", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  h |3:   h |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ht |3:   ht |4:   h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: tt |3:   htt |4:   ht |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: tp |3:   http |4:   htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: p. |3:   http. |4:   http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: .H |3:   http.H |4:   http. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: HandleFunc( |3:   http.HandleFunc( |4:   http.H |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 10
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.HandleFunc(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.HandleFunc(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "pattern string"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "pattern string"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 11, 18 }
 |5: 9 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 10 |3: 9 |4: { "       pattern string", "Comment" }

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2:   http.HandleFunc( |3:   http.HandleFunc( |4:   http.HandleFunc( |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 10
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "  http.HandleFunc(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |3: {
  border = "rounded",
  line_to_cursor = "  http.HandleFunc(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "pattern string"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "pattern string"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 11, 18 }
 |5: 9 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 10 |3: 9 |4: { "       pattern string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc(/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: (/ |3:   http.HandleFunc(/ |4:   http.HandleFunc( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 10
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.HandleFunc(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.HandleFunc(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "pattern string"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "pattern string"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 11, 19 }
 |5: 9 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 10 |3: 9 |4: { "        pattern string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: (/ |3:   http.HandleFunc( |4:   http.HandleFunc(/ |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 18,
      line = 10
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.HandleFunc(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.HandleFunc(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "pattern string"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "pattern string"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 11, 18 }
 |5: 9 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 10 |3: 9 |4: { "       pattern string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: (" |3:   http.HandleFunc(" |4:   http.HandleFunc( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: "/ |3:   http.HandleFunc("/ |4:   http.HandleFunc(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/" 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: /"  |3:   http.HandleFunc("/"  |4:   http.HandleFunc("/ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/" +
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2:  + |3:   http.HandleFunc("/" + |4:   http.HandleFunc("/"  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/" + 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: +  |3:   http.HandleFunc("/" +  |4:   http.HandleFunc("/" + |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/" + 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2:   http.HandleFunc("/" +  |3:   http.HandleFunc("/" +  |4:   http.HandleFunc("/" +  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/" +
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: +  |3:   http.HandleFunc("/" + |4:   http.HandleFunc("/" +  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/" 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2:  + |3:   http.HandleFunc("/"  |4:   http.HandleFunc("/" + |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: "  |3:   http.HandleFunc("/" |4:   http.HandleFunc("/"  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2:   http.HandleFunc("/" |3:   http.HandleFunc("/" |4:   http.HandleFunc("/" |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/" 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: "  |3:   http.HandleFunc("/"  |4:   http.HandleFunc("/" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: "  |3:   http.HandleFunc("/" |4:   http.HandleFunc("/"  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: ", |3:   http.HandleFunc("/", |4:   http.HandleFunc("/" |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 10
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 11, 22 }
 |5: 9 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 10 |3: 9 |4: { "           handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: ,  |3:   http.HandleFunc("/",  |4:   http.HandleFunc("/", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 10
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 11, 23 }
 |5: 9 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 10 |3: 9 |4: { "            handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", m
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2:  m |3:   http.HandleFunc("/", m |4:   http.HandleFunc("/",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 10
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 11, 24 }
 |5: 9 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 10 |3: 9 |4: { "             handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", my
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: my |3:   http.HandleFunc("/", my |4:   http.HandleFunc("/", m |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 10
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 11, 25 }
 |5: 9 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 10 |3: 9 |4: { "              handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", myf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: yf |3:   http.HandleFunc("/", myf |4:   http.HandleFunc("/", my |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 10
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 11, 26 }
 |5: 9 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 10 |3: 9 |4: { "               handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", myfu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: fu |3:   http.HandleFunc("/", myfu |4:   http.HandleFunc("/", myf |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 10
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 11, 27 }
 |5: 9 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 10 |3: 9 |4: { "                handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", myfun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: un |3:   http.HandleFunc("/", myfun |4:   http.HandleFunc("/", myfu |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 10
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 11, 28 }
 |5: 9 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 10 |3: 9 |4: { "                 handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", myfund
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: nd |3:   http.HandleFunc("/", myfund |4:   http.HandleFunc("/", myfun |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 10
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 11, 29 }
 |5: 9 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 10 |3: 9 |4: { "                  handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", myfun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: nd |3:   http.HandleFunc("/", myfun |4:   http.HandleFunc("/", myfund |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 10
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 11, 28 }
 |5: 9 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 10 |3: 9 |4: { "                 handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", myfunc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: nc |3:   http.HandleFunc("/", myfunc |4:   http.HandleFunc("/", myfun |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 10
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 11, 29 }
 |5: 9 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 10 |3: 9 |4: { "                  handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", myfunc(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: c( |3:   http.HandleFunc("/", myfunc( |4:   http.HandleFunc("/", myfunc |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:  
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2:   |3:   |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:   |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:    |3:  |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: i |3: i |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: i 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: i  |3: i  |4: i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: i  |3: i |4: i  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2: i |3:  |4: i |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: f |3: f |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: fu |3: fu |4: f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: un |3: fun |4: fu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: nc |3: func |4: fun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: funce
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: ce |3: funce |4: func |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ce |3: func |4: funce |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: c  |3: func  |4: func |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func m
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  m |3: func m |4: func  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func my
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: my |3: func my |4: func m |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myf
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: yf |3: func myf |4: func my |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: fu |3: func myfu |4: func myf |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: un |3: func myfun |4: func myfu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: nc |3: func myfunc |4: func myfun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: c( |3: func myfunc( |4: func myfunc |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc() 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: ()  |3: func myfunc()  |4: func myfunc( |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc() [
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2:  [ |3: func myfunc() [ |4: func myfunc()  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc() 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2:  [ |3: func myfunc()  |4: func myfunc() [ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc() {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2:  { |3: func myfunc() { |4: func myfunc()  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: unc myfunc() { |3:    |4: func myfunc() { |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc()
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: func myfunc() |3: func myfunc() |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc()i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: )i |3: func myfunc()i |4: func myfunc() |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc()
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: )i |3: func myfunc() |4: func myfunc()i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc() 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: )  |3: func myfunc()  |4: func myfunc() |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc() n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2:  n |3: func myfunc() n |4: func myfunc()  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc() 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2:  n |3: func myfunc()  |4: func myfunc() n |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc()
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: )  |3: func myfunc() |4: func myfunc()  |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: func myfunc( |3: func myfunc( |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: (r |3: func myfunc(r |4: func myfunc( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: rw |3: func myfunc(rw |4: func myfunc(r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: w, |3: func myfunc(rw, |4: func myfunc(rw |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: w, |3: func myfunc(rw |4: func myfunc(rw, |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: rw |3: func myfunc(r |4: func myfunc(rw |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: (r |3: func myfunc( |4: func myfunc(r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: (r |3: func myfunc(r |4: func myfunc( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: rw |3: func myfunc(rw |4: func myfunc(r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: w  |3: func myfunc(rw  |4: func myfunc(rw |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2:  h |3: func myfunc(rw h |4: func myfunc(rw  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: ht |3: func myfunc(rw ht |4: func myfunc(rw h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: tt |3: func myfunc(rw htt |4: func myfunc(rw ht |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: tp |3: func myfunc(rw http |4: func myfunc(rw htt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: p. |3: func myfunc(rw http. |4: func myfunc(rw http |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: .R |3: func myfunc(rw http.R |4: func myfunc(rw http. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: Re |3: func myfunc(rw http.Re |4: func myfunc(rw http.R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.Res
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: es |3: func myfunc(rw http.Res |4: func myfunc(rw http.Re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: sponseWriter |3: func myfunc(rw http.ResponseWriter |4: func myfunc(rw http.Res |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: r, |3: func myfunc(rw http.ResponseWriter, |4: func myfunc(rw http.ResponseWriter |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: ,  |3: func myfunc(rw http.ResponseWriter,  |4: func myfunc(rw http.ResponseWriter, |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2:  r |3: func myfunc(rw http.ResponseWriter, r |4: func myfunc(rw http.ResponseWriter,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r*
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: r* |3: func myfunc(rw http.ResponseWriter, r* |4: func myfunc(rw http.ResponseWriter, r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r*h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: *h |3: func myfunc(rw http.ResponseWriter, r*h |4: func myfunc(rw http.ResponseWriter, r* |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r*
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: *h |3: func myfunc(rw http.ResponseWriter, r* |4: func myfunc(rw http.ResponseWriter, r*h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: r* |3: func myfunc(rw http.ResponseWriter, r |4: func myfunc(rw http.ResponseWriter, r* |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: r  |3: func myfunc(rw http.ResponseWriter, r  |4: func myfunc(rw http.ResponseWriter, r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2:  h |3: func myfunc(rw http.ResponseWriter, r h |4: func myfunc(rw http.ResponseWriter, r  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2:  h |3: func myfunc(rw http.ResponseWriter, r  |4: func myfunc(rw http.ResponseWriter, r h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2:  * |3: func myfunc(rw http.ResponseWriter, r * |4: func myfunc(rw http.ResponseWriter, r  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r *h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: *h |3: func myfunc(rw http.ResponseWriter, r *h |4: func myfunc(rw http.ResponseWriter, r * |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r *ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: ht |3: func myfunc(rw http.ResponseWriter, r *ht |4: func myfunc(rw http.ResponseWriter, r *h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r *htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: tt |3: func myfunc(rw http.ResponseWriter, r *htt |4: func myfunc(rw http.ResponseWriter, r *ht |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r *http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: tp |3: func myfunc(rw http.ResponseWriter, r *http |4: func myfunc(rw http.ResponseWriter, r *htt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r *http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: p. |3: func myfunc(rw http.ResponseWriter, r *http. |4: func myfunc(rw http.ResponseWriter, r *http |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r *http.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: .R |3: func myfunc(rw http.ResponseWriter, r *http.R |4: func myfunc(rw http.ResponseWriter, r *http. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r *http.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: Re |3: func myfunc(rw http.ResponseWriter, r *http.Re |4: func myfunc(rw http.ResponseWriter, r *http.R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r *http.Requ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: equ |3: func myfunc(rw http.ResponseWriter, r *http.Requ |4: func myfunc(rw http.ResponseWriter, r *http.Re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r *http.Reque
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: ue |3: func myfunc(rw http.ResponseWriter, r *http.Reque |4: func myfunc(rw http.ResponseWriter, r *http.Requ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r *http.Reques
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: es |3: func myfunc(rw http.ResponseWriter, r *http.Reques |4: func myfunc(rw http.ResponseWriter, r *http.Reque |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func myfunc(rw http.ResponseWriter, r *http.Request
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 35
󰘫  |1: delta |2: st |3: func myfunc(rw http.ResponseWriter, r *http.Request |4: func myfunc(rw http.ResponseWriter, r *http.Reques |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: }
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: } |3: } |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2: } |3:  |4: } |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	})
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: 	}) |3: 	}) |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	}
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: }) |3: 	} |4: 	}) |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", myfunc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2:   http.HandleFunc("/", myfunc |3:   http.HandleFunc("/", myfunc |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 24, 29 }
 |5: 22 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                  handler func(http.ResponseWriter, *http.Request)", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", myfunc(r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: c(r |3:   http.HandleFunc("/", myfunc(r |4:   http.HandleFunc("/", myfunc |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = ""
      },
      label = "myfunc(rw http.ResponseWriter, r *http.Request)",
      parameters = { {
          label = "rw http.ResponseWriter"
        }, {
          label = "r *http.Request"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/", myfunc(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = ""
      },
      label = "myfunc(rw http.ResponseWriter, r *http.Request)",
      parameters = { {
          label = "rw http.ResponseWriter"
        }, {
          label = "r *http.Request"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/", myfunc(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "rw http.ResponseWriter"
}

󰘫  |1: func |2: myfunc(rw http.ResponseWriter, r *http.Request) |3: {
  label = "rw http.ResponseWriter"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 24, 31 }
 |5: 22 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                    rw http.ResponseWriter", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", myfunc(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: (r |3:   http.HandleFunc("/", myfunc( |4:   http.HandleFunc("/", myfunc(r |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = ""
      },
      label = "myfunc(rw http.ResponseWriter, r *http.Request)",
      parameters = { {
          label = "rw http.ResponseWriter"
        }, {
          label = "r *http.Request"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/", myfunc(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = ""
      },
      label = "myfunc(rw http.ResponseWriter, r *http.Request)",
      parameters = { {
          label = "rw http.ResponseWriter"
        }, {
          label = "r *http.Request"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.HandleFunc("/", myfunc(',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "rw http.ResponseWriter"
}

󰘫  |1: func |2: myfunc(rw http.ResponseWriter, r *http.Request) |3: {
  label = "rw http.ResponseWriter"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 24, 30 }
 |5: 22 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                   rw http.ResponseWriter", "Comment" }

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.HandleFunc("/", myfunc(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2:   http.HandleFunc("/", myfunc( |3:   http.HandleFunc("/", myfunc( |4:   http.HandleFunc("/", myfunc( |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 23
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = ""
      },
      label = "myfunc(rw http.ResponseWriter, r *http.Request)",
      parameters = { {
          label = "rw http.ResponseWriter"
        }, {
          label = "r *http.Request"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = '  http.HandleFunc("/", myfunc(',
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = ""
      },
      label = "myfunc(rw http.ResponseWriter, r *http.Request)",
      parameters = { {
          label = "rw http.ResponseWriter"
        }, {
          label = "r *http.Request"
        } }
    } }
}
 |3: {
  border = "rounded",
  line_to_cursor = '  http.HandleFunc("/", myfunc(',
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "rw http.ResponseWriter"
}

󰘫  |1: func |2: myfunc(rw http.ResponseWriter, r *http.Request) |3: {
  label = "rw http.ResponseWriter"
}

󰘫  |1: virtual text only : |2: func main() { |3:  |4: { 24, 30 }
 |5: 22 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 23 |3: 22 |4: { "                   rw http.ResponseWriter", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	}
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: 	} |3: 	} |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 2,
      line = 19
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
      },
      label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler func(http.ResponseWriter, *http.Request)"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "\t}",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
󰘫  |1: nextpara: |2: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: func |2: HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) |3: {
  label = "handler func(http.ResponseWriter, *http.Request)"
}

󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2: 	} |3:  |4: 	} |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  signature_result = {
    activeParameter = 1,
    cfgActiveSignature = 0,
    signatures = { {
        documentation = {
          kind = "markdown",
          value = "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched."
        },
        label = "HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))",
        parameters = { {
            label = "pattern string"
          }, {
            label = "handler func(http.ResponseWriter, *http.Request)"
          } }
      } }
  },
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: p
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: p |3: p |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pa
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: pa |3: pa |4: p |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pac
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: ac |3: pac |4: pa |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: pack
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ck |3: pack |4: pac |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: packa
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: ka |3: packa |4: pack |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: packag
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ag |3: packag |4: packa |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ge |3: package |4: packag |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package handlers
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: e handlers |3: package handlers |4: package |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: package handler
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: package handler |3: package handler |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: t |3: t |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: ty
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: ty |3: ty |4: t |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: typ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: yp |3: typ |4: ty |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: pe |3: type |4: typ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: e  |3: type  |4: type |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  H |3: type H |4: type  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type He
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: He |3: type He |4: type H |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: el |3: type Hel |4: type He |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ll |3: type Hell |4: type Hel |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Hello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: lo |3: type Hello |4: type Hell |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Hello 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: o  |3: type Hello  |4: type Hello |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Hello s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2:  s |3: type Hello s |4: type Hello  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Hello st
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: st |3: type Hello st |4: type Hello s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Hello str
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: tr |3: type Hello str |4: type Hello st |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Hello stru
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: ru |3: type Hello stru |4: type Hello str |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Hello struc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: uc |3: type Hello struc |4: type Hello stru |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Hello struct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: ct |3: type Hello struct |4: type Hello struc |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Hello struct
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: type Hello struct |3: type Hello struct |4: type Hello struct |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Hello struct 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: t  |3: type Hello struct  |4: type Hello struct |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: type Hello struct {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2:  { |3: type Hello struct { |4: type Hello struct  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: ype Hello struct { |3:    |4: type Hello struct { |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: no active client
󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: f |3: f |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: fu |3: fu |4: f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: un |3: fun |4: fu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: nc |3: func |4: fun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: c  |3: func  |4: func |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2:  ( |3: func ( |4: func  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: (h |3: func (h |4: func ( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: h* |3: func (h* |4: func (h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: *H |3: func (h*H |4: func (h* |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*He
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: He |3: func (h*He |4: func (h*H |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: el |3: func (h*Hel |4: func (h*He |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: ll |3: func (h*Hell |4: func (h*Hel |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 6
󰘫  |1: delta |2: lo |3: func (h*Hello |4: func (h*Hell |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: o)  |3: func (h*Hello)  |4: func (h*Hello |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2:  S |3: func (h*Hello) S |4: func (h*Hello)  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) Se
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: Se |3: func (h*Hello) Se |4: func (h*Hello) S |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) Ser
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: er |3: func (h*Hello) Ser |4: func (h*Hello) Se |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) Serv
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: rv |3: func (h*Hello) Serv |4: func (h*Hello) Ser |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) Serve
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: ve |3: func (h*Hello) Serve |4: func (h*Hello) Serv |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeH
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: eH |3: func (h*Hello) ServeH |4: func (h*Hello) Serve |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHP
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: HP |3: func (h*Hello) ServeHP |4: func (h*Hello) ServeH |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHPP
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: PP |3: func (h*Hello) ServeHPP |4: func (h*Hello) ServeHP |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHPPT
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: PT |3: func (h*Hello) ServeHPPT |4: func (h*Hello) ServeHPP |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHPP
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: PT |3: func (h*Hello) ServeHPP |4: func (h*Hello) ServeHPPT |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHP
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: PP |3: func (h*Hello) ServeHP |4: func (h*Hello) ServeHPP |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeH
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: HP |3: func (h*Hello) ServeH |4: func (h*Hello) ServeHP |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHT
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: HT |3: func (h*Hello) ServeHT |4: func (h*Hello) ServeH |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTT
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: TT |3: func (h*Hello) ServeHTT |4: func (h*Hello) ServeHT |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: TP |3: func (h*Hello) ServeHTTP |4: func (h*Hello) ServeHTT |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: P  |3: func (h*Hello) ServeHTTP  |4: func (h*Hello) ServeHTTP |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: P  |3: func (h*Hello) ServeHTTP |4: func (h*Hello) ServeHTTP  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: P( |3: func (h*Hello) ServeHTTP( |4: func (h*Hello) ServeHTTP |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: (r |3: func (h*Hello) ServeHTTP(r |4: func (h*Hello) ServeHTTP( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: rw |3: func (h*Hello) ServeHTTP(rw |4: func (h*Hello) ServeHTTP(r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: w  |3: func (h*Hello) ServeHTTP(rw  |4: func (h*Hello) ServeHTTP(rw |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2:  H |3: func (h*Hello) ServeHTTP(rw H |4: func (h*Hello) ServeHTTP(rw  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: Ht |3: func (h*Hello) ServeHTTP(rw Ht |4: func (h*Hello) ServeHTTP(rw H |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: tt |3: func (h*Hello) ServeHTTP(rw Htt |4: func (h*Hello) ServeHTTP(rw Ht |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: tp |3: func (h*Hello) ServeHTTP(rw Http |4: func (h*Hello) ServeHTTP(rw Htt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: p. |3: func (h*Hello) ServeHTTP(rw Http. |4: func (h*Hello) ServeHTTP(rw Http |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: .R |3: func (h*Hello) ServeHTTP(rw Http.R |4: func (h*Hello) ServeHTTP(rw Http. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: Re |3: func (h*Hello) ServeHTTP(rw Http.Re |4: func (h*Hello) ServeHTTP(rw Http.R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.Res
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: es |3: func (h*Hello) ServeHTTP(rw Http.Res |4: func (h*Hello) ServeHTTP(rw Http.Re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.Resp
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: sp |3: func (h*Hello) ServeHTTP(rw Http.Resp |4: func (h*Hello) ServeHTTP(rw Http.Res |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.Respo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: po |3: func (h*Hello) ServeHTTP(rw Http.Respo |4: func (h*Hello) ServeHTTP(rw Http.Resp |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.Respon
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: on |3: func (h*Hello) ServeHTTP(rw Http.Respon |4: func (h*Hello) ServeHTTP(rw Http.Respo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.Respons
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: ns |3: func (h*Hello) ServeHTTP(rw Http.Respons |4: func (h*Hello) ServeHTTP(rw Http.Respon |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.Response
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: se |3: func (h*Hello) ServeHTTP(rw Http.Response |4: func (h*Hello) ServeHTTP(rw Http.Respons |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseW
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: eW |3: func (h*Hello) ServeHTTP(rw Http.ResponseW |4: func (h*Hello) ServeHTTP(rw Http.Response |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: Wr |3: func (h*Hello) ServeHTTP(rw Http.ResponseWr |4: func (h*Hello) ServeHTTP(rw Http.ResponseW |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: ri |3: func (h*Hello) ServeHTTP(rw Http.ResponseWri |4: func (h*Hello) ServeHTTP(rw Http.ResponseWr |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWrit
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: it |3: func (h*Hello) ServeHTTP(rw Http.ResponseWrit |4: func (h*Hello) ServeHTTP(rw Http.ResponseWri |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWrite
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: te |3: func (h*Hello) ServeHTTP(rw Http.ResponseWrite |4: func (h*Hello) ServeHTTP(rw Http.ResponseWrit |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: er |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter |4: func (h*Hello) ServeHTTP(rw Http.ResponseWrite |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: r, |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: ,  |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter,  |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2:  r |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter,  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: r  |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r  |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2:  * |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r * |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: *h |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *h |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r * |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: ht |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *ht |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *h |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: tt |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *htt |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *ht |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: tp |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *htt |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: p. |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http. |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: .R |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.R |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: Re |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Re |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.R |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Requ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: equ |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Requ |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Re |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Reque
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: ue |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Reque |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Requ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Reques
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: es |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Reques |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Reque |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: st |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Reques |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 66
󰘫  |1: delta |2: t)  |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request)  |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request) {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 67
󰘫  |1: delta |2:  { |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request) { |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request)  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: unc (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request) { |3:    |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request) { |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: 	 |3: 	 |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  l |3:   l |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: lo |3:   lo |4:   l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: og |3:   log |4:   lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   log 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: g  |3:   log  |4:   log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: g  |3:   log |4:   log  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   logi
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: gi |3:   logi |4:   log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: gi |3:   log |4:   logi |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: og |3:   lo |4:   log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: lo |3:   l |4:   lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: l  |3:   l  |4:   l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  * |3:   l * |4:   l  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: *l |3:   l *l |4:   l * |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: lo |3:   l *lo |4:   l *l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: og |3:   l *log |4:   l *lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: g. |3:   l *log. |4:   l *log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.L
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: .L |3:   l *log.L |4:   l *log. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: Lo |3:   l *log.Lo |4:   l *log.L |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: og |3:   l *log.Log |4:   l *log.Lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Logg
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: gg |3:   l *log.Logg |4:   l *log.Log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Logge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: ge |3:   l *log.Logge |4:   l *log.Logg |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Logger
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: er |3:   l *log.Logger |4:   l *log.Logge |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Logger
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Logger
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Reques
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: st |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Reques |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.NewRequest
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: quest |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.NewRequest |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Reques |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 48
󰘫  |1: delta |2: uest |3: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.Request |4: func (h*Hello) ServeHTTP(rw Http.ResponseWriter, r *http.NewRequest |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l *log.Logge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2:   l *log.Logge |3:   l *log.Logge |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:    
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:    |3:     |4:    |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: 	 |3: 	 |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 		d, err := ioutil.ReadAll(r.Body)
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: 		d, err := ioutil.ReadAll(r.Body) |3: 		d, err := ioutil.ReadAll(r.Body) |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 		d, err := ioutil.ReadAll(r.Body
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 27
󰘫  |1: delta |2: y) |3: 		d, err := ioutil.ReadAll(r.Body |4: 		d, err := ioutil.ReadAll(r.Body) |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 		d, err := ioutil.ReadAll(r.Body)
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: y) |3: 		d, err := ioutil.ReadAll(r.Body) |4: 		d, err := ioutil.ReadAll(r.Body |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 		d, err := iouti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: il.ReadAll(r.Body) |3: 		d, err := iouti |4: 		d, err := ioutil.ReadAll(r.Body) |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 		d, err := ioutil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: delta |2: il |3: 		d, err := ioutil |4: 		d, err := iouti |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 		d, err := ioutil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 4
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/ioutil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: 	"io/ioutil |3: 	"io/ioutil |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/iouti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: il |3: 	"io/iouti |4: 	"io/ioutil |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/iout
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: ti |3: 	"io/iout |4: 	"io/iouti |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/iou
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ut |3: 	"io/iou |4: 	"io/iout |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ou |3: 	"io/io |4: 	"io/iou |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: io |3: 	"io/i |4: 	"io/io |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: /i |3: 	"io/ |4: 	"io/i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: o/ |3: 	"io |4: 	"io/ |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: 	"io |3: 	"io |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"io
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: io |3: 	"i |4: 	"io |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: "i |3: 	" |4: 	"i |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 		fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: 		fmt |3: 		fmt |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 		fm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: mt |3: 		fm |4: 		fmt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 		fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: mt |3: 		fmt |4: 		fm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 		fmt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 			
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: 			 |3: 			 |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: f
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2: f |3: f |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: fu |3: fu |4: f |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: fun
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2: un |3: fun |4: fu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: nc |3: func |4: fun |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: c  |3: func  |4: func |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func N
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  N |3: func N |4: func  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func Ne
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: Ne |3: func Ne |4: func N |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func New
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ew |3: func New |4: func Ne |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewE
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: wE |3: func NewE |4: func New |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func New
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: wE |3: func New |4: func NewE |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewH
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: wH |3: func NewH |4: func New |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHe
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: He |3: func NewHe |4: func NewH |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: el |3: func NewHel |4: func NewHe |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ll |3: func NewHell |4: func NewHel |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: lo |3: func NewHello |4: func NewHell |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: o( |3: func NewHello( |4: func NewHello |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: (l |3: func NewHello(l |4: func NewHello( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: l  |3: func NewHello(l  |4: func NewHello(l |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2:  * |3: func NewHello(l * |4: func NewHello(l  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: *l |3: func NewHello(l *l |4: func NewHello(l * |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *li
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: li |3: func NewHello(l *li |4: func NewHello(l *l |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: li |3: func NewHello(l *l |4: func NewHello(l *li |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: lo |3: func NewHello(l *lo |4: func NewHello(l *l |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: og |3: func NewHello(l *log |4: func NewHello(l *lo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: g. |3: func NewHello(l *log. |4: func NewHello(l *log |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.L
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: .L |3: func NewHello(l *log.L |4: func NewHello(l *log. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: Lo |3: func NewHello(l *log.Lo |4: func NewHello(l *log.L |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: og |3: func NewHello(l *log.Log |4: func NewHello(l *log.Lo |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Logg
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: gg |3: func NewHello(l *log.Logg |4: func NewHello(l *log.Log |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Loggz
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: gz |3: func NewHello(l *log.Loggz |4: func NewHello(l *log.Logg |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Loggzi
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: zi |3: func NewHello(l *log.Loggzi |4: func NewHello(l *log.Loggz |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Loggz
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: zi |3: func NewHello(l *log.Loggz |4: func NewHello(l *log.Loggzi |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Logg
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: gz |3: func NewHello(l *log.Logg |4: func NewHello(l *log.Loggz |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Logge
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: ge |3: func NewHello(l *log.Logge |4: func NewHello(l *log.Logg |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Logger
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 14
󰘫  |1: delta |2: er |3: func NewHello(l *log.Logger |4: func NewHello(l *log.Logge |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Logger) 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: r)  |3: func NewHello(l *log.Logger)  |4: func NewHello(l *log.Logger |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Logger) *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2:  * |3: func NewHello(l *log.Logger) * |4: func NewHello(l *log.Logger)  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Logger) *H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2: *H |3: func NewHello(l *log.Logger) *H |4: func NewHello(l *log.Logger) * |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Logger) *He
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: He |3: func NewHello(l *log.Logger) *He |4: func NewHello(l *log.Logger) *H |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Logger) *Hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 33
󰘫  |1: delta |2: el |3: func NewHello(l *log.Logger) *Hel |4: func NewHello(l *log.Logger) *He |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Logger) *Hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 34
󰘫  |1: delta |2: ll |3: func NewHello(l *log.Logger) *Hell |4: func NewHello(l *log.Logger) *Hel |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Logger) *Hello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 35
󰘫  |1: delta |2: lo |3: func NewHello(l *log.Logger) *Hello |4: func NewHello(l *log.Logger) *Hell |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Logger) *Hello 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 36
󰘫  |1: delta |2: o  |3: func NewHello(l *log.Logger) *Hello  |4: func NewHello(l *log.Logger) *Hello |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func NewHello(l *log.Logger) *Hello {
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 37
󰘫  |1: delta |2:  { |3: func NewHello(l *log.Logger) *Hello { |4: func NewHello(l *log.Logger) *Hello  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2: unc NewHello(l *log.Logger) *Hello { |3:    |4: func NewHello(l *log.Logger) *Hello { |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   r
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  r |3:   r |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: re |3:   re |4:   r |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ret
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: et |3:   ret |4:   re |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   retu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: tu |3:   retu |4:   ret |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   retur
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ur |3:   retur |4:   retu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: rn |3:   return |4:   retur |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: n  |3:   return  |4:   return |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:  & |3:   return & |4:   return  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: &H |3:   return &H |4:   return & |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &He
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: He |3:   return &He |4:   return &H |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Hel
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: el |3:   return &Hel |4:   return &He |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Hell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: ll |3:   return &Hell |4:   return &Hel |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Hello
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: lo |3:   return &Hello |4:   return &Hell |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Hello{
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: o{ |3:   return &Hello{ |4:   return &Hello |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Hello{
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2:   return &Hello{ |3:   return &Hello{ |4:   return &Hello{ |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Hello{l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: {l |3:   return &Hello{l |4:   return &Hello{ |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Hello{
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2:   return &Hello{ |3:   return &Hello{ |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2:   return &Hello{ |3: 	 |4:   return &Hello{ |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   return &Hello{
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2:   return &Hello{ |3:   return &Hello{ |4: 	 |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:   return &Hello{ |3:  |4:   return &Hello{ |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h *Hello) ServeHTTP(rw H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 26
󰘫  |1: delta |2: func (h *Hello) ServeHTTP(rw H |3: func (h *Hello) ServeHTTP(rw H |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h *Hello) ServeHTTP(rw 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 26
󰘫  |1: delta |2:  H |3: func (h *Hello) ServeHTTP(rw  |4: func (h *Hello) ServeHTTP(rw H |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: func (h *Hello) ServeHTTP(rw h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 26
󰘫  |1: delta |2:  h |3: func (h *Hello) ServeHTTP(rw h |4: func (h *Hello) ServeHTTP(rw  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: }
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2:    |3: } |4:    |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  h |3:   h |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: ht |3:   ht |4:   h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: tt |3:   htt |4:   ht |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: tp |3:   http |4:   htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: p. |3:   http. |4:   http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.L
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: .L |3:   http.L |4:   http. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: ListenAndServe( |3:   http.ListenAndServe( |4:   http.L |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 22,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.ListenAndServe(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  http.ListenAndServe(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "addr string"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "addr string"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 12, 22 }
 |5: 10 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                        addr string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: (" |3:   http.ListenAndServe(" |4:   http.ListenAndServe( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: ": |3:   http.ListenAndServe(": |4:   http.ListenAndServe(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: :9 |3:   http.ListenAndServe(":9 |4:   http.ListenAndServe(": |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":90
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: 90 |3:   http.ListenAndServe(":90 |4:   http.ListenAndServe(":9 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":909
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: 09 |3:   http.ListenAndServe(":909 |4:   http.ListenAndServe(":90 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2: 90 |3:   http.ListenAndServe(":9090 |4:   http.ListenAndServe(":909 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: 0", |3:   http.ListenAndServe(":9090", |4:   http.ListenAndServe(":9090 |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 12, 30 }
 |5: 10 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: ,  |3:   http.ListenAndServe(":9090",  |4:   http.ListenAndServe(":9090", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 12, 31 }
 |5: 10 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                 handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2:  n |3:   http.ListenAndServe(":9090", n |4:   http.ListenAndServe(":9090",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 12, 32 }
 |5: 10 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                  handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", ni
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: ni |3:   http.ListenAndServe(":9090", ni |4:   http.ListenAndServe(":9090", n |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 12, 33 }
 |5: 10 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                   handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", nil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: il |3:   http.ListenAndServe(":9090", nil |4:   http.ListenAndServe(":9090", ni |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 12, 34 }
 |5: 10 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                    handler http.Handler", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  h |3:   h |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: hh |3:   hh |4:   h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: h  |3:   hh  |4:   hh |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  : |3:   hh : |4:   hh  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: := |3:   hh := |4:   hh : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: =  |3:   hh :=  |4:   hh := |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2:  h |3:   hh := h |4:   hh :=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := hand
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: hand |3:   hh := hand |4:   hh := h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := handl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: dl |3:   hh := handl |4:   hh := hand |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := handle
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: le |3:   hh := handle |4:   hh := handl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := handler
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: er |3:   hh := handler |4:   hh := handle |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := handlers
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: rs |3:   hh := handlers |4:   hh := handler |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := handlers.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: s. |3:   hh := handlers. |4:   hh := handlers |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := handlers.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2:   hh := handlers. |3:   hh := handlers. |4:   hh := handlers. |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := handlers.NewHello(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 26
󰘫  |1: delta |2: .NewHello( |3:   hh := handlers.NewHello( |4:   hh := handlers. |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  l |3:   l |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: l  |3:   l  |4:   l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  : |3:   l : |4:   l  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: := |3:   l := |4:   l : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: =  |3:   l :=  |4:   l := |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2:  l |3:   l := l |4:   l :=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: lo |3:   l := lo |4:   l := l |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: og |3:   l := log |4:   l := lo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: g. |3:   l := log. |4:   l := log |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.N
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: .N |3:   l := log.N |4:   l := log. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.Ne
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: Ne |3:   l := log.Ne |4:   l := log.N |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: ew |3:   l := log.New |4:   l := log.Ne |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: w( |3:   l := log.New( |4:   l := log.New |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 15 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "    out io.Writer", "Comment" }

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2:   l := log.New( |3:   l := log.New( |4:   l := log.New( |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "  l := log.New(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  line_to_cursor = "  l := log.New(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 15 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "    out io.Writer", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2:   l := log.New |3:   l := log.New |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 14,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "  l := log.New",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  line_to_cursor = "  l := log.New",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2:   l := log.New( |3:   l := log.New( |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 15 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "    out io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(o
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: (o |3:   l := log.New(o |4:   l := log.New( |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 16 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "     out io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: os |3:   l := log.New(os |4:   l := log.New(o |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 17 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "      out io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: s. |3:   l := log.New(os. |4:   l := log.New(os |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 18 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "       out io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: .S |3:   l := log.New(os.S |4:   l := log.New(os. |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 19 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "        out io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.St
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: St |3:   l := log.New(os.St |4:   l := log.New(os.S |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 20 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "         out io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Std
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: td |3:   l := log.New(os.Std |4:   l := log.New(os.St |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 21 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "          out io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: do |3:   l := log.New(os.Stdo |4:   l := log.New(os.Std |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 22 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "           out io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdou
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: ou |3:   l := log.New(os.Stdou |4:   l := log.New(os.Stdo |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 23 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "            out io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: ut |3:   l := log.New(os.Stdout |4:   l := log.New(os.Stdou |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 24 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "             out io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: t, |3:   l := log.New(os.Stdout, |4:   l := log.New(os.Stdout |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(os.Stdout,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "prefix string"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "prefix string"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 25 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "              prefix string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: ,  |3:   l := log.New(os.Stdout,  |4:   l := log.New(os.Stdout, |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(os.Stdout,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "prefix string"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "prefix string"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 26 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "               prefix string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2:  " |3:   l := log.New(os.Stdout, " |4:   l := log.New(os.Stdout,  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(os.Stdout,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "prefix string"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "prefix string"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 27 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                prefix string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "p
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: "p |3:   l := log.New(os.Stdout, "p |4:   l := log.New(os.Stdout, " |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(os.Stdout,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "prefix string"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "prefix string"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 28 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                 prefix string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "pr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: pr |3:   l := log.New(os.Stdout, "pr |4:   l := log.New(os.Stdout, "p |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "pro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: ro |3:   l := log.New(os.Stdout, "pro |4:   l := log.New(os.Stdout, "pr |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(os.Stdout,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "prefix string"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "prefix string"
}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(os.Stdout,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "prefix string"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "prefix string"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 30 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                   prefix string", "Comment" }

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 30 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                   prefix string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "prod
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: od |3:   l := log.New(os.Stdout, "prod |4:   l := log.New(os.Stdout, "pro |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(os.Stdout,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "prefix string"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "prefix string"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 31 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                    prefix string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "produ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: du |3:   l := log.New(os.Stdout, "produ |4:   l := log.New(os.Stdout, "prod |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(os.Stdout,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "prefix string"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "prefix string"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 32 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                     prefix string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "produc
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: uc |3:   l := log.New(os.Stdout, "produc |4:   l := log.New(os.Stdout, "produ |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(os.Stdout,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "prefix string"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "prefix string"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 33 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                      prefix string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: ct |3:   l := log.New(os.Stdout, "product |4:   l := log.New(os.Stdout, "produc |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(os.Stdout,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "prefix string"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "prefix string"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 34 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                       prefix string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: t- |3:   l := log.New(os.Stdout, "product- |4:   l := log.New(os.Stdout, "product |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(os.Stdout,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "prefix string"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "prefix string"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 35 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                        prefix string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-a
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: -a |3:   l := log.New(os.Stdout, "product-a |4:   l := log.New(os.Stdout, "product- |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(os.Stdout,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "prefix string"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "prefix string"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 36 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                         prefix string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-ap
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: ap |3:   l := log.New(os.Stdout, "product-ap |4:   l := log.New(os.Stdout, "product-a |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(os.Stdout,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "prefix string"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "prefix string"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 37 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                          prefix string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: pi |3:   l := log.New(os.Stdout, "product-api |4:   l := log.New(os.Stdout, "product-ap |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 25,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(os.Stdout,",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "prefix string"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "prefix string"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 38 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                           prefix string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: i", |3:   l := log.New(os.Stdout, "product-api", |4:   l := log.New(os.Stdout, "product-api |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 40 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                             flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: ,  |3:   l := log.New(os.Stdout, "product-api",  |4:   l := log.New(os.Stdout, "product-api", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 41 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                              flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2:  l |3:   l := log.New(os.Stdout, "product-api", l |4:   l := log.New(os.Stdout, "product-api",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 42 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                               flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", lo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: lo |3:   l := log.New(os.Stdout, "product-api", lo |4:   l := log.New(os.Stdout, "product-api", l |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 43 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: og |3:   l := log.New(os.Stdout, "product-api", log |4:   l := log.New(os.Stdout, "product-api", lo |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 44 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                 flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", log.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: g. |3:   l := log.New(os.Stdout, "product-api", log. |4:   l := log.New(os.Stdout, "product-api", log |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 45 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                  flag int", "Comment" }

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", log.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2:   l := log.New(os.Stdout, "product-api", log. |3:   l := log.New(os.Stdout, "product-api", log. |4:   l := log.New(os.Stdout, "product-api", log. |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 45 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                  flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", log.L
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: .L |3:   l := log.New(os.Stdout, "product-api", log.L |4:   l := log.New(os.Stdout, "product-api", log. |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 46 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                   flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", log.Ls
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: Ls |3:   l := log.New(os.Stdout, "product-api", log.Ls |4:   l := log.New(os.Stdout, "product-api", log.L |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 47 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                    flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", log.Lst
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: st |3:   l := log.New(os.Stdout, "product-api", log.Lst |4:   l := log.New(os.Stdout, "product-api", log.Ls |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 48 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                     flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", log.Lstr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: tr |3:   l := log.New(os.Stdout, "product-api", log.Lstr |4:   l := log.New(os.Stdout, "product-api", log.Lst |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 49 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                      flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", log.LstrF
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: rF |3:   l := log.New(os.Stdout, "product-api", log.LstrF |4:   l := log.New(os.Stdout, "product-api", log.Lstr |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 50 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                       flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", log.Lstr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: rF |3:   l := log.New(os.Stdout, "product-api", log.Lstr |4:   l := log.New(os.Stdout, "product-api", log.LstrF |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 49 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                      flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", log.Lst
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: tr |3:   l := log.New(os.Stdout, "product-api", log.Lst |4:   l := log.New(os.Stdout, "product-api", log.Lstr |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 48 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                     flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", log.Lstd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: td |3:   l := log.New(os.Stdout, "product-api", log.Lstd |4:   l := log.New(os.Stdout, "product-api", log.Lst |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 49 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                      flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", log.LstdFlags
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: dFlags |3:   l := log.New(os.Stdout, "product-api", log.LstdFlags |4:   l := log.New(os.Stdout, "product-api", log.Lstd |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 54 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                           flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", log.LstdFlags 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: s  |3:   l := log.New(os.Stdout, "product-api", log.LstdFlags  |4:   l := log.New(os.Stdout, "product-api", log.LstdFlags |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 55 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                            flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout, "product-api", log.LstdFlags
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 40
󰘫  |1: delta |2: s  |3:   l := log.New(os.Stdout, "product-api", log.LstdFlags |4:   l := log.New(os.Stdout, "product-api", log.LstdFlags  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 40,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 2,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  l := log.New(os.Stdout, "product-api",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 2 |3: New(out io.Writer, prefix string, flag int) *log.Logger
󰘫  |1: nextpara: |2: {
  label = "flag int"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "flag int"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 54 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "                                           flag int", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(o
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: os.Stdout, "product-api", log.LstdFlags |3:   l := log.New(o |4:   l := log.New(os.Stdout, "product-api", log.LstdFlags |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 16 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "     out io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: os |3:   l := log.New(os |4:   l := log.New(o |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 11
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  l := log.New(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: virtual text only : |2: func main() { |3:   hh := handlers.NewHello() |4: { 12, 17 }
 |5: 10 |6: func main() {
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 11 |3: 10 |4: { "      out io.Writer", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := handlers.NewHello(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 26
󰘫  |1: delta |2:   hh := handlers.NewHello( |3:   hh := handlers.NewHello( |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := handlers.NewHello(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 26
󰘫  |1: delta |2:   hh := handlers.NewHello( |3:   hh := handlers.NewHello( |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := handlers.NewHello(l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 26
󰘫  |1: delta |2: (l |3:   hh := handlers.NewHello(l |4:   hh := handlers.NewHello( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := handlers.NewHello(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 26
󰘫  |1: delta |2:   hh := handlers.NewHello( |3:   hh := handlers.NewHello( |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:    |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  s |3:   s |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: sm |3:   sm |4:   s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: m  |3:   sm  |4:   sm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  : |3:   sm : |4:   sm  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm :?
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: :? |3:   sm :? |4:   sm : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: :? |3:   sm : |4:   sm :? |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: := |3:   sm := |4:   sm : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: =  |3:   sm :=  |4:   sm := |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2:  h |3:   sm := h |4:   sm :=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: ht |3:   sm := ht |4:   sm := h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: tt |3:   sm := htt |4:   sm := ht |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: tp |3:   sm := http |4:   sm := htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: p. |3:   sm := http. |4:   sm := http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: p. |3:   sm := http |4:   sm := http. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: tp |3:   sm := htt |4:   sm := http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := htt.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: t. |3:   sm := htt. |4:   sm := htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: t. |3:   sm := htt |4:   sm := htt. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := httt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: tt |3:   sm := httt |4:   sm := htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: tt |3:   sm := htt |4:   sm := httt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: tp |3:   sm := http |4:   sm := htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: p. |3:   sm := http. |4:   sm := http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := http.N
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: .N |3:   sm := http.N |4:   sm := http. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := http.Ne
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: Ne |3:   sm := http.Ne |4:   sm := http.N |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := http.New
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: ew |3:   sm := http.New |4:   sm := http.Ne |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := http.NewS
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: wS |3:   sm := http.NewS |4:   sm := http.New |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm := http.NewServeMux()
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: ServeMux() |3:   sm := http.NewServeMux() |4:   sm := http.NewS |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  sm := http.NewServeMux() |3:    |4:   sm := http.NewServeMux() |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  s |3:   s |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: sm |3:   sm |4:   s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: m. |3:   sm. |4:   sm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: .H |3:   sm.H |4:   sm. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: Handle( |3:   sm.Handle( |4:   sm.H |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 12,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics."
      },
      label = "Handle(pattern string, handler http.Handler)",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  sm.Handle(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics."
      },
      label = "Handle(pattern string, handler http.Handler)",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  sm.Handle(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "pattern string"
}

󰘫  |1: func |2: Handle(pattern string, handler http.Handler) |3: {
  label = "pattern string"
}

󰘫  |1: virtual text only : |2:   sm := http.NewServeMux() |3:  |4: { 17, 12 }
 |5: 17 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 17 |4: { "              pattern string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: (" |3:   sm.Handle(" |4:   sm.Handle( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: "/ |3:   sm.Handle("/ |4:   sm.Handle(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: /", |3:   sm.Handle("/", |4:   sm.Handle("/ |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics."
      },
      label = "Handle(pattern string, handler http.Handler)",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  sm.Handle("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Handle(pattern string, handler http.Handler)
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: Handle(pattern string, handler http.Handler) |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:   sm := http.NewServeMux() |3:  |4: { 17, 16 }
 |5: 17 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 17 |4: { "                  handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ,  |3:   sm.Handle("/",  |4:   sm.Handle("/", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics."
      },
      label = "Handle(pattern string, handler http.Handler)",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  sm.Handle("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Handle(pattern string, handler http.Handler)
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: Handle(pattern string, handler http.Handler) |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:   sm := http.NewServeMux() |3:  |4: { 17, 17 }
 |5: 17 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 17 |4: { "                   handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/", h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2:  h |3:   sm.Handle("/", h |4:   sm.Handle("/",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics."
      },
      label = "Handle(pattern string, handler http.Handler)",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  sm.Handle("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Handle(pattern string, handler http.Handler)
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: Handle(pattern string, handler http.Handler) |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:   sm := http.NewServeMux() |3:  |4: { 17, 18 }
 |5: 16
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 16 |4: { "  handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/", hh
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: hh |3:   sm.Handle("/", hh |4:   sm.Handle("/", h |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 16
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics."
      },
      label = "Handle(pattern string, handler http.Handler)",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  sm.Handle("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Handle(pattern string, handler http.Handler)
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: Handle(pattern string, handler http.Handler) |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:   sm := http.NewServeMux() |3:  |4: { 17, 19 }
 |5: 16
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 16 |3: 16 |4: { "  handler http.Handler", "Comment" }

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/", hh)
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: h) |3:   sm.Handle("/", hh) |4:   sm.Handle("/", hh |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", nil
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2:   http.ListenAndServe(":9090", nil |3:   http.ListenAndServe(":9090", nil |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 19, 34 }
 |5: 17 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 17 |4: { "                                    handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", ni
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: il |3:   http.ListenAndServe(":9090", ni |4:   http.ListenAndServe(":9090", nil |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 19, 33 }
 |5: 17 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 17 |4: { "                                   handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", n
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: ni |3:   http.ListenAndServe(":9090", n |4:   http.ListenAndServe(":9090", ni |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 19, 32 }
 |5: 17 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 17 |4: { "                                  handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2:  n |3:   http.ListenAndServe(":9090",  |4:   http.ListenAndServe(":9090", n |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 19, 31 }
 |5: 17 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 17 |4: { "                                 handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2:  s |3:   http.ListenAndServe(":9090", s |4:   http.ListenAndServe(":9090",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 19, 32 }
 |5: 17 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 17 |4: { "                                  handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", sm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: sm |3:   http.ListenAndServe(":9090", sm |4:   http.ListenAndServe(":9090", s |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 19, 33 }
 |5: 17 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 17 |4: { "                                   handler http.Handler", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090", s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2:   http.ListenAndServe(":9090", s |3:   http.ListenAndServe(":9090", s |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error."
      },
      label = "ListenAndServe(addr string, handler http.Handler) error",
      parameters = { {
          label = "addr string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = '  http.ListenAndServe(":9090",',
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: ListenAndServe(addr string, handler http.Handler) error
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: ListenAndServe(addr string, handler http.Handler) error |3: {
  label = "handler http.Handler"
}

󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 1
󰘫  |1: delta |2:   http.ListenAndServe(":9090", s |3: 	 |4:   http.ListenAndServe(":9090", s |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := handlers
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2:   hh := handlers |3:   hh := handlers |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := handler
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: rs |3:   hh := handler |4:   hh := handlers |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := handlers
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: rs |3:   hh := handlers |4:   hh := handler |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "command-line-arguments/home/jsmith49/projects/go/microservice
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 72
󰘫  |1: delta |2: 	handlers "command-line-arguments/home/jsmith49/projects/go/microservice |3: 	handlers "command-line-arguments/home/jsmith49/projects/go/microservice |4:  |5: {}

󰘫  |1: mode:    |2: niI
󰘫  |1: mode:  niI  |2: niI
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: 	handlers  |3: 	handlers  |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2:  " |3: 	handlers " |4: 	handlers  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: 	handlers  |3: 	handlers  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: 	handlers " |3: 	handlers " |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers " 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: "  |3: 	handlers "  |4: 	handlers " |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: 	"log |3: 	"log |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: 	handlers " |3: 	handlers " |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "m
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: "m |3: 	handlers "m |4: 	handlers " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "mi
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: mi |3: 	handlers "mi |4: 	handlers "m |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "mic
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: ic |3: 	handlers "mic |4: 	handlers "mi |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "micr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: cr |3: 	handlers "micr |4: 	handlers "mic |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "micro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: ro |3: 	handlers "micro |4: 	handlers "micr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "micros
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: os |3: 	handlers "micros |4: 	handlers "micro |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microse
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: se |3: 	handlers "microse |4: 	handlers "micros |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microser
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: er |3: 	handlers "microser |4: 	handlers "microse |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microserg
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: rg |3: 	handlers "microserg |4: 	handlers "microser |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microser
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: rg |3: 	handlers "microser |4: 	handlers "microserg |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microserv
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: rv |3: 	handlers "microserv |4: 	handlers "microser |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microservi
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: vi |3: 	handlers "microservi |4: 	handlers "microserv |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microservic
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: ic |3: 	handlers "microservic |4: 	handlers "microservi |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microservice
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: ce |3: 	handlers "microservice |4: 	handlers "microservic |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microservices
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: es |3: 	handlers "microservices |4: 	handlers "microservice |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microservice
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: es |3: 	handlers "microservice |4: 	handlers "microservices |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microservice/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: e/ |3: 	handlers "microservice/ |4: 	handlers "microservice |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microservice/h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: /h |3: 	handlers "microservice/h |4: 	handlers "microservice/ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microservice/hand
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: hand |3: 	handlers "microservice/hand |4: 	handlers "microservice/h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microservice/handl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: dl |3: 	handlers "microservice/handl |4: 	handlers "microservice/hand |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microservice/handlers
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: lers |3: 	handlers "microservice/handlers |4: 	handlers "microservice/handl |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microservice/handlers
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: 	handlers "microservice/handlers |3: 	handlers "microservice/handlers |4: 	handlers "microservice/handlers |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microservice/handler
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2: 	handlers "microservice/handler |3: 	handlers "microservice/handler |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: hover not supported
󰘫  |1: lsp cap:  |2: false |3: false
󰘫  |1: skip: signature capabilities not enabled
󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: no active client
󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microservic
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: 	handlers "microservic |3: 	handlers "microservic |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "microservice
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: 	handlers "microservice |3: 	handlers "microservice |4:  |5: {}

󰘫  |1: mode:    |2: niI
󰘫  |1: mode:  niI  |2: niI
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: 	handlers  |3: 	handlers  |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2:  " |3: 	handlers " |4: 	handlers  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers ".
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ". |3: 	handlers ". |4: 	handlers " |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: 	handlers " |3: 	handlers " |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := hand
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: nd |3:   hh := hand |4: 	handlers " |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "./
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: 	handlers "./ |3: 	handlers "./ |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers ".
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ./ |3: 	handlers ". |4: 	handlers "./ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ". |3: 	handlers " |4: 	handlers ". |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "m
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: "m |3: 	handlers "m |4: 	handlers " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: my |3: 	handlers "my |4: 	handlers "m |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: y. |3: 	handlers "my. |4: 	handlers "my |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my.o
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: .o |3: 	handlers "my.o |4: 	handlers "my. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my.or
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: or |3: 	handlers "my.or |4: 	handlers "my.o |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my.org
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: rg |3: 	handlers "my.org |4: 	handlers "my.or |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my.org/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: g/ |3: 	handlers "my.org/ |4: 	handlers "my.org |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my.org/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: 	handlers "my.org/ |3: 	handlers "my.org/ |4: 	handlers "my.org/ |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my.org
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: 	handlers "my.org |3: 	handlers "my.org |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"net/http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2:  "my.org |3: 	"net/http |4: 	handlers "my.org |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: no active client
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: no active client
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: changed
󰘫  |1: no active client
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: no active client
󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: no active client
󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my.org/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: 	handlers "my.org/ |3: 	handlers "my.org/ |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my.org/m
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: /m |3: 	handlers "my.org/m |4: 	handlers "my.org/ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my.org/mi
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: mi |3: 	handlers "my.org/mi |4: 	handlers "my.org/m |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my.org/mic
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: ic |3: 	handlers "my.org/mic |4: 	handlers "my.org/mi |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my.org/micr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: cr |3: 	handlers "my.org/micr |4: 	handlers "my.org/mic |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my.org/micro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: ro |3: 	handlers "my.org/micro |4: 	handlers "my.org/micr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my.org/micro/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: o/ |3: 	handlers "my.org/micro/ |4: 	handlers "my.org/micro |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	handlers "my.org/micro
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: 	handlers "my.org/micro |3: 	handlers "my.org/micro |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 	"log
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: dlers "my.org/micro |3: 	"log |4: 	handlers "my.org/micro |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   l := log.New(os.Stdout
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 15
󰘫  |1: delta |2: := log.New(os.Stdout |3:   l := log.New(os.Stdout |4: 	"log |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 15,
      line = 12
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "  l := log.New(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties."
      },
      label = "New(out io.Writer, prefix string, flag int) *log.Logger",
      parameters = { {
          label = "out io.Writer"
        }, {
          label = "prefix string"
        }, {
          label = "flag int"
        } }
    } }
}
 |3: {
  border = "rounded",
  line_to_cursor = "  l := log.New(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "out io.Writer"
}

󰘫  |1: func |2: New(out io.Writer, prefix string, flag int) *log.Logger |3: {
  label = "out io.Writer"
}

󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   hh := handlers.NewHell
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2:   hh := handlers.NewHell |3:   hh := handlers.NewHell |4:   l := log.New(os.Stdout |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:   hh := handlers.NewHell |3:  |4:   hh := handlers.NewHell |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  always_trigger = false,
  bind = true,
  bufnr = 0,
  check_completion_visible = true,
  close_timeout = 4000,
  cursorhold_update = true,
  debug = true,
  doc_lines = 5,
  extra_trigger_chars = {},
  fix_pos = true,
  floating_window = false,
  floating_window_above_cur_line = true,
  floating_window_off_x = 1,
  floating_window_off_y = <function 1>,
  handler_opts = {
    border = "rounded"
  },
  hi_parameter = "MoreMsg",
  hint_enable = true,
  hint_inline = <function 2>,
  hint_prefix = "  ",
  hint_scheme = "Comment",
  log_path = "debug_log_file_path",
  mainwin = 0,
  max_height = 50,
  max_width = 200,
  padding = "",
  shadow_blend = 36,
  shadow_guibg = "Black",
  timer_interval = 50,
  use_lspsaga = false,
  verbose = false,
  wrap = true,
  zindex = 200
}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3: 
󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  g |3:   g |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: gh |3:   gh |4:   g |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: h  |3:   gh  |4:   gh |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  : |3:   gh : |4:   gh  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: := |3:   gh := |4:   gh : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: =  |3:   gh :=  |4:   gh := |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2:  h |3:   gh := h |4:   gh :=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := hand
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: hand |3:   gh := hand |4:   gh := h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: dl |3:   gh := handl |4:   gh := hand |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handle
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: le |3:   gh := handle |4:   gh := handl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handler
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: er |3:   gh := handler |4:   gh := handle |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handlers
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: rs |3:   gh := handlers |4:   gh := handler |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handlers.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: s. |3:   gh := handlers. |4:   gh := handlers |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handlers.Good
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: .Good |3:   gh := handlers.Good |4:   gh := handlers. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handlers.Goodb
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: db |3:   gh := handlers.Goodb |4:   gh := handlers.Good |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handlers.Goodby
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: by |3:   gh := handlers.Goodby |4:   gh := handlers.Goodb |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handlers.Goodbye
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: ye |3:   gh := handlers.Goodbye |4:   gh := handlers.Goodby |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handlers.Goodbye(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: e( |3:   gh := handlers.Goodbye( |4:   gh := handlers.Goodbye |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handlers.Goodbye(l
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2: (l |3:   gh := handlers.Goodbye(l |4:   gh := handlers.Goodbye( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handlers.Goodbye(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 25
󰘫  |1: delta |2:   gh := handlers.Goodbye( |3:   gh := handlers.Goodbye( |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  s |3:   s |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: sm |3:   sm |4:   s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: m. |3:   sm. |4:   sm |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: .H |3:   sm.H |4:   sm. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Hand
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: Hand |3:   sm.Hand |4:   sm.H |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: dl |3:   sm.Handl |4:   sm.Hand |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: le |3:   sm.Handle |4:   sm.Handl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: e( |3:   sm.Handle( |4:   sm.Handle |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 12,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics."
      },
      label = "Handle(pattern string, handler http.Handler)",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  sm.Handle(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics."
      },
      label = "Handle(pattern string, handler http.Handler)",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  sm.Handle(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "pattern string"
}

󰘫  |1: func |2: Handle(pattern string, handler http.Handler) |3: {
  label = "pattern string"
}

󰘫  |1: virtual text only : |2:   sm.Handle("/", hh) |3:  |4: { 19, 12 }
 |5: 19 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 19 |4: { "              pattern string", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: (" |3:   sm.Handle(" |4:   sm.Handle( |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2:   sm.Handle(" |3:   sm.Handle(" |4:   sm.Handle(" |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: "/ |3:   sm.Handle("/ |4:   sm.Handle(" |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: /", |3:   sm.Handle("/", |4:   sm.Handle("/ |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics."
      },
      label = "Handle(pattern string, handler http.Handler)",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  sm.Handle("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Handle(pattern string, handler http.Handler)
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: Handle(pattern string, handler http.Handler) |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:   sm.Handle("/", hh) |3:  |4: { 19, 16 }
 |5: 19 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 19 |4: { "                  handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/", 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: ,  |3:   sm.Handle("/",  |4:   sm.Handle("/", |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics."
      },
      label = "Handle(pattern string, handler http.Handler)",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  sm.Handle("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Handle(pattern string, handler http.Handler)
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: Handle(pattern string, handler http.Handler) |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:   sm.Handle("/", hh) |3:  |4: { 19, 17 }
 |5: 19 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 19 |4: { "                   handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/", g
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2:  g |3:   sm.Handle("/", g |4:   sm.Handle("/",  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics."
      },
      label = "Handle(pattern string, handler http.Handler)",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  sm.Handle("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Handle(pattern string, handler http.Handler)
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: Handle(pattern string, handler http.Handler) |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:   sm.Handle("/", hh) |3:  |4: { 19, 18 }
 |5: 18
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 18 |4: { "  handler http.Handler", "Comment" }

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/", gh
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: gh |3:   sm.Handle("/", gh |4:   sm.Handle("/", g |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 16,
      line = 18
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  activeParameter = 1,
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics."
      },
      label = "Handle(pattern string, handler http.Handler)",
      parameters = { {
          label = "pattern string"
        }, {
          label = "handler http.Handler"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = '  sm.Handle("/",',
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar |2: 1 |3: Handle(pattern string, handler http.Handler)
󰘫  |1: nextpara: |2: {
  label = "handler http.Handler"
}

󰘫  |1: func |2: Handle(pattern string, handler http.Handler) |3: {
  label = "handler http.Handler"
}

󰘫  |1: virtual text only : |2:   sm.Handle("/", hh) |3:  |4: { 19, 19 }
 |5: 18
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 18 |3: 18 |4: { "  handler http.Handler", "Comment" }

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2:   sm.Handle("/ |3:   sm.Handle("/ |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/good
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: /good |3:   sm.Handle("/good |4:   sm.Handle("/ |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/goodb
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: db |3:   sm.Handle("/goodb |4:   sm.Handle("/good |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/goodby
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: by |3:   sm.Handle("/goodby |4:   sm.Handle("/goodb |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   sm.Handle("/goodbye
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 12
󰘫  |1: delta |2: ye |3:   sm.Handle("/goodbye |4:   sm.Handle("/goodby |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	[string ":lua"]:1: in main chunk
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:  |3:  |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handlers.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2:   gh := handlers. |3:   gh := handlers. |4:  |5: {}

󰘫  |1: completedone  |2: i |3: enable signature ?
󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handlers.N
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: .N |3:   gh := handlers.N |4:   gh := handlers. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handlers.Ne
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: Ne |3:   gh := handlers.Ne |4:   gh := handlers.N |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handlers.New
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: ew |3:   gh := handlers.New |4:   gh := handlers.Ne |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   gh := handlers.Ne
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2:   gh := handlers.Ne |3:   gh := handlers.Ne |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2: 
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 0
󰘫  |1: delta |2:   gh := handlers.Ne |3:  |4:   gh := handlers.Ne |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  s |3:   s |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: s  |3:   s  |4:   s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  : |3:   s : |4:   s  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s :?
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: :? |3:   s :? |4:   s : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: :? |3:   s : |4:   s :? |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  : |3:   s  |4:   s : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s ;
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  ; |3:   s ; |4:   s  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  ; |3:   s  |4:   s ; |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s :
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  : |3:   s : |4:   s  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s :=
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: := |3:   s := |4:   s : |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s := 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: =  |3:   s :=  |4:   s := |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s := &
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2:  & |3:   s := & |4:   s :=  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s := &h
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: &h |3:   s := &h |4:   s := & |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s := &ht
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: ht |3:   s := &ht |4:   s := &h |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s := &htt
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: tt |3:   s := &htt |4:   s := &ht |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s := &http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: tp |3:   s := &http |4:   s := &htt |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s := &http.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: p. |3:   s := &http. |4:   s := &http |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s := &http.S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: .S |3:   s := &http.S |4:   s := &http. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s := &http.Se
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: Se |3:   s := &http.Se |4:   s := &http.S |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s := &http.Ser
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: er |3:   s := &http.Ser |4:   s := &http.Se |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s := &http.Serv
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: rv |3:   s := &http.Serv |4:   s := &http.Ser |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s := &http.Serve
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: ve |3:   s := &http.Serve |4:   s := &http.Serv |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s := &http.Server
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: er |3:   s := &http.Server |4:   s := &http.Serve |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s := &http.Server{
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: r{ |3:   s := &http.Server{ |4:   s := &http.Server |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:  s := &http.Server{ |3:    |4:   s := &http.Server{ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  s |3:   s |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: s. |3:   s. |4:   s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: .t |3:   s.t |4:   s. |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:   s.t |3:   s.t |4:   s.t |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:   s.t |3:   s.t |4:   s.t |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.WriteTimeout
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: WriteTimeout |3:   s.WriteTimeout |4:   s.t |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.WriteTimeou
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: ut |3:   s.WriteTimeou |4:   s.WriteTimeout |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: .WriteTimeou |3:   s. |4:   s.WriteTimeou |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.WriteTimeout.Microseconds()
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2: .WriteTimeout.Microseconds() |3:   s.WriteTimeout.Microseconds() |4:   s. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.WriteTimeout.Microseconds()5
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: )5 |3:   s.WriteTimeout.Microseconds()5 |4:   s.WriteTimeout.Microseconds() |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.WriteTimeout.Microseconds()
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2: )5 |3:   s.WriteTimeout.Microseconds() |4:   s.WriteTimeout.Microseconds()5 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.WriteTimeout.Microseconds(5
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.WriteTimeout.Microseconds(5
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2:   s.WriteTimeout.Microseconds(5 |3:   s.WriteTimeout.Microseconds(5 |4:  |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Microseconds returns the duration as an integer microsecond count."
      },
      label = "Microseconds() int64"
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  s.WriteTimeout.Microseconds(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: no sig
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.WriteTimeout.Microseconds(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 30
󰘫  |1: delta |2: (5 |3:   s.WriteTimeout.Microseconds( |4:   s.WriteTimeout.Microseconds(5 |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 30,
      line = 22
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Microseconds returns the duration as an integer microsecond count."
      },
      label = "Microseconds() int64"
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  s.WriteTimeout.Microseconds(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: no sig
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http.ListenAndServe(":9090"
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 22
󰘫  |1: delta |2:   http.ListenAndServe(":9090" |3:   http.ListenAndServe(":9090" |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  s |3:   s |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: s. |3:   s. |4:   s |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:   s. |3:   s. |4:   s. |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:   s. |3:   s. |4:   s. |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.i
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: .i |3:   s.i |4:   s. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.id
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: id |3:   s.id |4:   s.i |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.idl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: dl |3:   s.idl |4:   s.id |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.idle
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: le |3:   s.idle |4:   s.idl |5: {}

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.idle
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2:   s.idle |3:   s.idle |4:   s.idle |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s := &http.Server{
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2:   s := &http.Server{ |3:   s := &http.Server{ |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  := &http.Server{ |3:      |4:   s := &http.Server{ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     A
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  A |3:     A |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Ad
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: Ad |3:     Ad |4:     A |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Add
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: dd |3:     Add |4:     Ad |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Addr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: dr |3:     Addr |4:     Add |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Addr:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: r: |3:     Addr: |4:     Addr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Addr: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: :  |3:     Addr:  |4:     Addr: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Addr: "
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2:  " |3:     Addr: " |4:     Addr:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Addr: ":
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: ": |3:     Addr: ": |4:     Addr: " |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Addr: ":9
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: :9 |3:     Addr: ":9 |4:     Addr: ": |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Addr: ":90
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: 90 |3:     Addr: ":90 |4:     Addr: ":9 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Addr: ":909
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: 09 |3:     Addr: ":909 |4:     Addr: ":90 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Addr: ":9090
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: 90 |3:     Addr: ":9090 |4:     Addr: ":909 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Addr: ":9090",
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 18
󰘫  |1: delta |2: 0", |3:     Addr: ":9090", |4:     Addr: ":9090 |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  Addr: ":9090", |3:      |4:     Addr: ":9090", |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     %^
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:  %^ |3:     %^ |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     %^1
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ^1 |3:     %^1 |4:     %^ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     %^15
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: 15 |3:     %^15 |4:     %^1 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     %^1543
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: 543 |3:     %^1543 |4:     %^15 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     %^154
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: 43 |3:     %^154 |4:     %^1543 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     %^15
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: 54 |3:     %^15 |4:     %^154 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     %^1
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: 15 |3:     %^1 |4:     %^15 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     %^
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: ^1 |3:     %^ |4:     %^1 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     %
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: %^ |3:     % |4:     %^ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  % |3:      |4:     % |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     H
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  H |3:     H |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Hand
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: Hand |3:     Hand |4:     H |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Handl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: dl |3:     Handl |4:     Hand |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Handle
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: le |3:     Handle |4:     Handl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Handler
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: er |3:     Handler |4:     Handle |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Handler:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: r: |3:     Handler: |4:     Handler |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Handler: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: :  |3:     Handler:  |4:     Handler: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Handler: s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2:  s |3:     Handler: s |4:     Handler:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Handler: sm
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: sm |3:     Handler: sm |4:     Handler: s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Handler: sm,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 16
󰘫  |1: delta |2: m, |3:     Handler: sm, |4:     Handler: sm |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  Handler: sm, |3:      |4:     Handler: sm, |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     I
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  I |3:     I |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Id
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: Id |3:     Id |4:     I |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Idl
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: dl |3:     Idl |4:     Id |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Idle
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: le |3:     Idle |4:     Idl |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     IdleTimeout: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: eTimeout:  |3:     IdleTimeout:  |4:     Idle |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     IdleTimeout: 1
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2:  1 |3:     IdleTimeout: 1 |4:     IdleTimeout:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     IdleTimeout: 12
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: 12 |3:     IdleTimeout: 12 |4:     IdleTimeout: 1 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     IdleTimeout: 120
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: 20 |3:     IdleTimeout: 120 |4:     IdleTimeout: 12 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     IdleTimeout: 120*
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: 0* |3:     IdleTimeout: 120* |4:     IdleTimeout: 120 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     IdleTimeout: 120*t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: *t |3:     IdleTimeout: 120*t |4:     IdleTimeout: 120* |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     IdleTimeout: 120*ti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: ti |3:     IdleTimeout: 120*ti |4:     IdleTimeout: 120*t |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     IdleTimeout: 120*tim
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: im |3:     IdleTimeout: 120*tim |4:     IdleTimeout: 120*ti |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     IdleTimeout: 120*time
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: me |3:     IdleTimeout: 120*time |4:     IdleTimeout: 120*tim |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     IdleTimeout: 120*time.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: e. |3:     IdleTimeout: 120*time. |4:     IdleTimeout: 120*time |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     IdleTimeout: 120*time.s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: .s |3:     IdleTimeout: 120*time.s |4:     IdleTimeout: 120*time. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     IdleTimeout: 120*time.se
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: se |3:     IdleTimeout: 120*time.se |4:     IdleTimeout: 120*time.s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     IdleTimeout: 120*time.Second
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: econd |3:     IdleTimeout: 120*time.Second |4:     IdleTimeout: 120*time.se |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  IdleTimeout: 120*time.Second |3:      |4:     IdleTimeout: 120*time.Second |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     R
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  R |3:     R |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Re
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: Re |3:     Re |4:     R |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Rea
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ea |3:     Rea |4:     Re |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Read
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ad |3:     Read |4:     Rea |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: dTimeout:  |3:     ReadTimeout:  |4:     Read |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2:  1 |3:     ReadTimeout: 1 |4:     ReadTimeout:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2: 1  |3:     ReadTimeout: 1  |4:     ReadTimeout: 1 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 O
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2:  O |3:     ReadTimeout: 1 O |4:     ReadTimeout: 1  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 O 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: O  |3:     ReadTimeout: 1 O  |4:     ReadTimeout: 1 O |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 O
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: O  |3:     ReadTimeout: 1 O |4:     ReadTimeout: 1 O  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2:  O |3:     ReadTimeout: 1  |4:     ReadTimeout: 1 O |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 *
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2:  * |3:     ReadTimeout: 1 * |4:     ReadTimeout: 1  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: *  |3:     ReadTimeout: 1 *  |4:     ReadTimeout: 1 * |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  t |3:     ReadTimeout: 1 * t |4:     ReadTimeout: 1 *  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * ti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: ti |3:     ReadTimeout: 1 * ti |4:     ReadTimeout: 1 * t |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * tim
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: im |3:     ReadTimeout: 1 * tim |4:     ReadTimeout: 1 * ti |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * ti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: im |3:     ReadTimeout: 1 * ti |4:     ReadTimeout: 1 * tim |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: ti |3:     ReadTimeout: 1 * t |4:     ReadTimeout: 1 * ti |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * ti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: ti |3:     ReadTimeout: 1 * ti |4:     ReadTimeout: 1 * t |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2: ti |3:     ReadTimeout: 1 * t |4:     ReadTimeout: 1 * ti |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2:  t |3:     ReadTimeout: 1 *  |4:     ReadTimeout: 1 * t |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  t |3:     ReadTimeout: 1 * t |4:     ReadTimeout: 1 *  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * ti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: ti |3:     ReadTimeout: 1 * ti |4:     ReadTimeout: 1 * t |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * tim
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: im |3:     ReadTimeout: 1 * tim |4:     ReadTimeout: 1 * ti |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * time
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: me |3:     ReadTimeout: 1 * time |4:     ReadTimeout: 1 * tim |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * time.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: e. |3:     ReadTimeout: 1 * time. |4:     ReadTimeout: 1 * time |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * time.s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: .s |3:     ReadTimeout: 1 * time.s |4:     ReadTimeout: 1 * time. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * time.se
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: se |3:     ReadTimeout: 1 * time.se |4:     ReadTimeout: 1 * time.s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * time.s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: se |3:     ReadTimeout: 1 * time.s |4:     ReadTimeout: 1 * time.se |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * time.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: .s |3:     ReadTimeout: 1 * time. |4:     ReadTimeout: 1 * time.s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * time.S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: .S |3:     ReadTimeout: 1 * time.S |4:     ReadTimeout: 1 * time. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * time.Se
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: Se |3:     ReadTimeout: 1 * time.Se |4:     ReadTimeout: 1 * time.S |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * time.Sec
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: delta |2: ec |3:     ReadTimeout: 1 * time.Sec |4:     ReadTimeout: 1 * time.Se |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * time.Seco
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2: co |3:     ReadTimeout: 1 * time.Seco |4:     ReadTimeout: 1 * time.Sec |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * time.Secon
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2: on |3:     ReadTimeout: 1 * time.Secon |4:     ReadTimeout: 1 * time.Seco |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     ReadTimeout: 1 * time.Second
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: nd |3:     ReadTimeout: 1 * time.Second |4:     ReadTimeout: 1 * time.Secon |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2:  ReadTimeout: 1 * time.Second |3:      |4:     ReadTimeout: 1 * time.Second |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     W
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2:  W |3:     W |4:      |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Wi
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: Wi |3:     Wi |4:     W |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     W
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: Wi |3:     W |4:     Wi |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Wr
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: Wr |3:     Wr |4:     W |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Wri
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: ri |3:     Wri |4:     Wr |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Writ
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: it |3:     Writ |4:     Wri |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     Write
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: te |3:     Write |4:     Writ |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteT
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: eT |3:     WriteT |4:     Write |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTi
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: Ti |3:     WriteTi |4:     WriteT |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTim
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: im |3:     WriteTim |4:     WriteTi |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTime
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 13
󰘫  |1: delta |2: me |3:     WriteTime |4:     WriteTim |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 14
󰘫  |1: delta |2: eo |3:     WriteTimeo |4:     WriteTime |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeou
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 15
󰘫  |1: delta |2: ou |3:     WriteTimeou |4:     WriteTimeo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 16
󰘫  |1: delta |2: ut |3:     WriteTimeout |4:     WriteTimeou |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout:
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 17
󰘫  |1: delta |2: t: |3:     WriteTimeout: |4:     WriteTimeout |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 18
󰘫  |1: delta |2: :  |3:     WriteTimeout:  |4:     WriteTimeout: |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 19
󰘫  |1: delta |2:  1 |3:     WriteTimeout: 1 |4:     WriteTimeout:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1*
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 20
󰘫  |1: delta |2: 1* |3:     WriteTimeout: 1* |4:     WriteTimeout: 1 |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* 
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 21
󰘫  |1: delta |2: *  |3:     WriteTimeout: 1*  |4:     WriteTimeout: 1* |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* t
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 22
󰘫  |1: delta |2:  t |3:     WriteTimeout: 1* t |4:     WriteTimeout: 1*  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* ti
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 23
󰘫  |1: delta |2: ti |3:     WriteTimeout: 1* ti |4:     WriteTimeout: 1* t |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* tim
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 24
󰘫  |1: delta |2: im |3:     WriteTimeout: 1* tim |4:     WriteTimeout: 1* ti |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* time
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 25
󰘫  |1: delta |2: me |3:     WriteTimeout: 1* time |4:     WriteTimeout: 1* tim |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* time.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 26
󰘫  |1: delta |2: e. |3:     WriteTimeout: 1* time. |4:     WriteTimeout: 1* time |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* time.S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 27
󰘫  |1: delta |2: .S |3:     WriteTimeout: 1* time.S |4:     WriteTimeout: 1* time. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* time.Se
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: Se |3:     WriteTimeout: 1* time.Se |4:     WriteTimeout: 1* time.S |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* time.Second
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: econd |3:     WriteTimeout: 1* time.Second |4:     WriteTimeout: 1* time.Se |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* time.Se
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 28
󰘫  |1: delta |2: econd |3:     WriteTimeout: 1* time.Se |4:     WriteTimeout: 1* time.Second |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* time.Se,
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: ,
󰘫  |1: lsp cap:  |2: true |3: true |4: 29
󰘫  |1: delta |2: e, |3:     WriteTimeout: 1* time.Se, |4:     WriteTimeout: 1* time.Se |5: {}

󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* time.Sec
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 29
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* time.Seco
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 30
󰘫  |1: delta |2: co |3:     WriteTimeout: 1* time.Seco |4:     WriteTimeout: 1* time.Sec |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* time.Secon
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2: on |3:     WriteTimeout: 1* time.Secon |4:     WriteTimeout: 1* time.Seco |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* time.Second
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 32
󰘫  |1: delta |2: nd |3:     WriteTimeout: 1* time.Second |4:     WriteTimeout: 1* time.Secon |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:     WriteTimeout: 1* time.Secon
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 31
󰘫  |1: delta |2:     WriteTimeout: 1* time.Secon |3:     WriteTimeout: 1* time.Secon |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: no valid signatures
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   http
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2:   http |3:   http |4:  |5: {}

󰘫  |1: mode:    |2: niI
󰘫  |1: mode:  niI  |2: niI
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  s |3:   s |4:    |5: {}

󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: Insert leave cleanup
󰘫  |1: stack traceback:
	...er/start/lsp_signature.nvim/lua/lsp_signature/helper.lua:341: in function 'cleanup_async'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:813: in function 'on_InsertLeave'
	...cker/start/lsp_signature.nvim/lua/lsp_signature/init.lua:837: in function ''
	vim/_editor.lua: in function <vim/_editor.lua:0>
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: async cleanup:  |2: n
󰘫  |1: cleanup vt |2: 5
󰘫  |1: mode:    |2: n
󰘫  |1: close timer
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.ListenAndServe(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 19
󰘫  |1: delta |2:   s.ListenAndServe( |3:   s.ListenAndServe( |4:  |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: n
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 19,
      line = 30
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = 'ListenAndServe listens on the TCP network address srv.Addr and then calls Serve to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nIf srv.Addr is blank, ":http" is used.\n\nListenAndServe always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.'
      },
      label = "ListenAndServe() error"
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "  s.ListenAndServe(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: no sig
󰘫  |1: trigger from cursor hold, no need to update floating window
󰘫  |1: insert enter
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: delta |2:    |3:    |4:  |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   
󰘫  |1: newline, lets try signature based on setup
󰘫  |1: lsp cap:  |2: true |3: false |4: 2
󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 3
󰘫  |1: delta |2:  s |3:   s |4:    |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 4
󰘫  |1: delta |2: s. |3:   s. |4:   s |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.S
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 5
󰘫  |1: delta |2: .S |3:   s.S |4:   s. |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.Sh
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 6
󰘫  |1: delta |2: Sh |3:   s.Sh |4:   s.S |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.Shu
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 7
󰘫  |1: delta |2: hu |3:   s.Shu |4:   s.Sh |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.Shut
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 8
󰘫  |1: delta |2: ut |3:   s.Shut |4:   s.Shu |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.Shutd
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 9
󰘫  |1: delta |2: td |3:   s.Shutd |4:   s.Shut |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.Shutdo
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 10
󰘫  |1: delta |2: do |3:   s.Shutdo |4:   s.Shutd |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.Shutdow
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 11
󰘫  |1: delta |2: ow |3:   s.Shutdow |4:   s.Shutdo |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.Shutdown
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: lsp cap:  |2: true |3: false |4: 12
󰘫  |1: delta |2: wn |3:   s.Shutdown |4:   s.Shutdow |5: {}

󰘫  |1: changed
󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.Shutdown(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2: n( |3:   s.Shutdown( |4:   s.Shutdown |5: {}

󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 13,
      line = 32
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Shutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners, then closing all idle connections, and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context's error, otherwise it returns any error returned from closing the Server's underlying Listener(s).\n\nWhen Shutdown is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return ErrServerClosed. Make sure the program doesn't exit and waits instead for Shutdown to return.\n\nShutdown does not attempt to close nor wait for hijacked connections such as WebSockets. The caller of Shutdown should separately notify such long-lived connections of shutdown and wait for them to close, if desired. See RegisterOnShutdown for a way to register shutdown notification functions.\n\nOnce Shutdown has been called on a server, it may not be reused; future calls to methods such as Serve will return ErrServerClosed."
      },
      label = "Shutdown(ctx context.Context) error",
      parameters = { {
          label = "ctx context.Context"
        } }
    } }
}
 |4: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  s.Shutdown(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Shutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners, then closing all idle connections, and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context's error, otherwise it returns any error returned from closing the Server's underlying Listener(s).\n\nWhen Shutdown is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return ErrServerClosed. Make sure the program doesn't exit and waits instead for Shutdown to return.\n\nShutdown does not attempt to close nor wait for hijacked connections such as WebSockets. The caller of Shutdown should separately notify such long-lived connections of shutdown and wait for them to close, if desired. See RegisterOnShutdown for a way to register shutdown notification functions.\n\nOnce Shutdown has been called on a server, it may not be reused; future calls to methods such as Serve will return ErrServerClosed."
      },
      label = "Shutdown(ctx context.Context) error",
      parameters = { {
          label = "ctx context.Context"
        } }
    } }
}
 |3: {
  border = "rounded",
  check_completion_visible = true,
  line_to_cursor = "  s.Shutdown(",
  trigger_from_lsp_sig = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "ctx context.Context"
}

󰘫  |1: func |2: Shutdown(ctx context.Context) error |3: {
  label = "ctx context.Context"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 33, 13 }
 |5: 31 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 32 |3: 31 |4: { "               ctx context.Context", "Comment" }

󰘫  |1: {
  triggerCharacters = { "(", "," }
}
 |2:   s.Shutdown(
󰘫  |1: ( |2: true
󰘫  |1: (
󰘫  |1: , |2: false
󰘫  |1: not special |2: ,
󰘫  |1: [%(,][^%(,%)]*$ |2: %(, |3: ^%(,%)
󰘫  |1: last trigger char |2: (
󰘫  |1: lsp cap:  |2: true |3: true |4: 13
󰘫  |1: delta |2:   s.Shutdown( |3:   s.Shutdown( |4:   s.Shutdown( |5: {
  trigger = "CursorHold"
}

󰘫  |1: Insert leave cleanup |2: i
󰘫  |1: signature handler
󰘫  |1: sig result |2: {
  bufnr = 1,
  client_id = 1,
  method = "textDocument/signatureHelp",
  params = {
    position = {
      character = 13,
      line = 32
    },
    textDocument = {
      uri = "file:///home/jsmith49/projects/go/microservice/main.go"
    }
  }
}
 |3: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Shutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners, then closing all idle connections, and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context's error, otherwise it returns any error returned from closing the Server's underlying Listener(s).\n\nWhen Shutdown is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return ErrServerClosed. Make sure the program doesn't exit and waits instead for Shutdown to return.\n\nShutdown does not attempt to close nor wait for hijacked connections such as WebSockets. The caller of Shutdown should separately notify such long-lived connections of shutdown and wait for them to close, if desired. See RegisterOnShutdown for a way to register shutdown notification functions.\n\nOnce Shutdown has been called on a server, it may not be reused; future calls to methods such as Serve will return ErrServerClosed."
      },
      label = "Shutdown(ctx context.Context) error",
      parameters = { {
          label = "ctx context.Context"
        } }
    } }
}
 |4: {
  border = "rounded",
  line_to_cursor = "  s.Shutdown(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: sig actPar
󰘫  |1: incorrect signature response? |2: {
  cfgActiveSignature = 0,
  signatures = { {
      documentation = {
        kind = "markdown",
        value = "Shutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners, then closing all idle connections, and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context's error, otherwise it returns any error returned from closing the Server's underlying Listener(s).\n\nWhen Shutdown is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return ErrServerClosed. Make sure the program doesn't exit and waits instead for Shutdown to return.\n\nShutdown does not attempt to close nor wait for hijacked connections such as WebSockets. The caller of Shutdown should separately notify such long-lived connections of shutdown and wait for them to close, if desired. See RegisterOnShutdown for a way to register shutdown notification functions.\n\nOnce Shutdown has been called on a server, it may not be reused; future calls to methods such as Serve will return ErrServerClosed."
      },
      label = "Shutdown(ctx context.Context) error",
      parameters = { {
          label = "ctx context.Context"
        } }
    } }
}
 |3: {
  border = "rounded",
  line_to_cursor = "  s.Shutdown(",
  trigger_from_cursor_hold = true,
  triggered_chars = { "(", "," }
}

󰘫  |1: nextpara: |2: {
  label = "ctx context.Context"
}

󰘫  |1: func |2: Shutdown(ctx context.Context) error |3: {
  label = "ctx context.Context"
}

󰘫  |1: virtual text only : |2:  |3: } |4: { 33, 13 }
 |5: 31 |6: 
󰘫  |1: cleanup vt |2: 5
󰘫  |1: virtual text:  |2: 32 |3: 31 |4: { "               ctx context.Context", "Comment" }

